<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì—‘ì…€ë§ˆìŠ¤í„° - ì‹¤ì‹œê°„ í˜‘ì—…</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- PDF, DOCX, PPTX ë³€í™˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ (ì½ê¸°) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- ë¬¸ì„œ ìƒì„± ë¼ì´ë¸ŒëŸ¬ë¦¬ (ì“°ê¸°) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js"></script>
    <script src="https://unpkg.com/docx@7.8.2/build/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    
    <script>
        // PDF.js ì›Œì»¤ ì„¤ì •
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    
    <script>
        // Firebase ì„¤ì •
        const firebaseConfig = {
            apiKey: "AIzaSyDK8WxX8K2r7LCPeepRq2tN5f58Tw63FDA",
            authDomain: "excelmaster-436c8.firebaseapp.com",
            projectId: "excelmaster-436c8",
            storageBucket: "excelmaster-436c8.firebasestorage.app",
            messagingSenderId: "488097994132",
            appId: "1:488097994132:web:33cdf5f15924051fa7eb81",
            measurementId: "G-3G5PYYRK8V"
        };
        
        // Firebase ë³€ìˆ˜ ì„ ì–¸ (ì´ˆê¸°í™”ëŠ” DOMContentLoadedì—ì„œ)
        let db = null;
        let auth = null;
        let storage = null;
        
        // í˜„ì¬ ë¡œê·¸ì¸ ì‚¬ìš©ì
        let currentUser = null;
        
        // íŒŒì¼ ë³´ê´€í•¨ ë°ì´í„° (ì „ì—­ ë³€ìˆ˜ë¡œ ì„ ì–¸)
        var fileStorage = [];
        var fileFolders = {}; // íŒŒì¼ í´ë” êµ¬ì¡° { folderId: { name, parentId, createdAt } }
        var fileToFolder = {}; // íŒŒì¼-í´ë” ë§¤í•‘ { fileId: folderId }
        var currentFileFolderId = null; // í˜„ì¬ íŒŒì¼ í´ë”
        var multiSelectedFiles = new Set(); // ë‹¤ì¤‘ ì„ íƒëœ íŒŒì¼
        var fileViewMode = 'icon'; // 'card', 'list', 'icon' (ê¸°ë³¸: icon)
        var fileFolderViewMode = 'icon'; // íŒŒì¼ í´ë” ë·° ëª¨ë“œ: 'card', 'icon'
        var favoriteFiles = new Set(); // ì¦ê²¨ì°¾ê¸° íŒŒì¼
        var fileDownloadMode = false; // íŒŒì¼ ë‹¤ìš´ë¡œë“œ ëª¨ë“œ
        var selectedFiles = new Set(); // ë‹¤ìš´ë¡œë“œìš© ì„ íƒëœ íŒŒì¼
        var fileDragItem = null; // ë“œë˜ê·¸ ì¤‘ì¸ íŒŒì¼ ì•„ì´í…œ
        
        // Firebase ì´ˆê¸°í™” í•¨ìˆ˜
        function initFirebase() {
            if (typeof firebase === 'undefined') {
                console.error('Firebase SDKê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return false;
            }
            
            try {
                // ì´ë¯¸ ì´ˆê¸°í™”ë˜ì—ˆëŠ”ì§€ í™•ì¸
                if (firebase.apps.length === 0) {
                    firebase.initializeApp(firebaseConfig);
                }
                db = firebase.firestore();
                auth = firebase.auth();
                storage = firebase.storage();
                console.log('Firebase ì´ˆê¸°í™” ì™„ë£Œ (Storage í¬í•¨)');
                return true;
            } catch (error) {
                console.error('Firebase ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                return false;
            }
        }
    </script>
    <script>
        // ëŒ€ìš©ëŸ‰ íŒŒì¼ ìµœì í™” ì„¤ì • (100MB ì§€ì›)
        const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
        const CHUNK_SIZE = 5000; // ì²­í¬ ë‹¨ìœ„ ì²˜ë¦¬ (ëŒ€ìš©ëŸ‰ ìµœì í™”)
        const SEARCH_DELAY = 200; // ì‹¤ì‹œê°„ ê²€ìƒ‰ ë””ë°”ìš´ìŠ¤
        const RENDER_BATCH_SIZE = 100; // ë Œë”ë§ ë°°ì¹˜ í¬ê¸°
        const VIRTUAL_SCROLL_BUFFER = 20; // ê°€ìƒ ìŠ¤í¬ë¡¤ ë²„í¼
        const GC_INTERVAL = 30000; // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°„ê²© (30ì´ˆ)
        const MEMORY_WARNING_THRESHOLD = 0.8; // ë©”ëª¨ë¦¬ ê²½ê³  ì„ê³„ê°’ (80%)
        let searchTimeout = null;
        let currentSearchResults = []; // ê²€ìƒ‰ ê²°ê³¼ ì €ì¥
        let currentFileSearchResults = []; // íŒŒì¼ ë³´ê´€í•¨ ê²€ìƒ‰ ê²°ê³¼
        let searchViewMode = 'list'; // 'list' or 'table'
        let currentSearchKeyword = ''; // í˜„ì¬ ê²€ìƒ‰ í‚¤ì›Œë“œ
        let mainSearchViewMode = 'list'; // ë©”ì¸ ê²€ìƒ‰ ê²°ê³¼ ë·° ëª¨ë“œ
        let activeSearchSheet = ''; // í˜„ì¬ ì„ íƒëœ ê²€ìƒ‰ ê²°ê³¼ ì‹œíŠ¸
        let gcTimer = null; // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ íƒ€ì´ë¨¸
        let isLargeFile = false; // ëŒ€ìš©ëŸ‰ íŒŒì¼ í”Œë˜ê·¸

        // íŒŒì¼ ê·¸ë£¹ ì‹œìŠ¤í…œ (ì›ë³¸ íŒŒì¼ â†’ ì‹œíŠ¸ ë§¤í•‘)
        let fileGroups = {}; // { fileId: { name, uploadedAt, sheets: [sheetName1, sheetName2, ...] } }
        let sheetToFileGroup = {}; // { sheetName: fileId }
        let collapsedFileGroups = new Set(); // ì ‘íŒ íŒŒì¼ ê·¸ë£¹ë“¤
        let fileGroupViewMode = 'grouped'; // 'grouped' (íŒŒì¼ë³„) or 'flat' (ì „ì²´ ì‹œíŠ¸)
        let currentUploadFileName = ''; // í˜„ì¬ ì—…ë¡œë“œ ì¤‘ì¸ íŒŒì¼ëª…

        // íœ´ì§€í†µ ì‹œìŠ¤í…œ
        let trashBin = []; // { name, data, colOrder, hiddenCols, colWidths, rowHeights, folderId, deletedAt }
        const TRASH_EXPIRE_DAYS = 7; // íœ´ì§€í†µ ë³´ê´€ ê¸°ê°„ (7ì¼)
        const MAX_TRASH_ITEMS = 50; // ìµœëŒ€ íœ´ì§€í†µ í•­ëª© ìˆ˜

        // ìë™ ì €ì¥ ì‹œìŠ¤í…œ
        let autoSaveEnabled = true; // ìë™ ì €ì¥ í™œì„±í™” ì—¬ë¶€
        let autoSaveInterval = 5; // ìë™ ì €ì¥ ê°„ê²© (ë¶„)
        let autoSaveTimer = null; // ìë™ ì €ì¥ íƒ€ì´ë¨¸
        let lastAutoSave = null; // ë§ˆì§€ë§‰ ìë™ ì €ì¥ ì‹œê°„
        let hasUnsavedChanges = false; // ì €ì¥ë˜ì§€ ì•Šì€ ë³€ê²½ì‚¬í•­ ì—¬ë¶€
        
        // ë©”ëª¨ë¦¬ ëª¨ë‹ˆí„°ë§
        function checkMemoryUsage() {
            if (performance && performance.memory) {
                const used = performance.memory.usedJSHeapSize;
                const total = performance.memory.jsHeapSizeLimit;
                if (used / total > MEMORY_WARNING_THRESHOLD) {
                    console.warn('ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê²½ê³ :', Math.round(used/total*100) + '%');
                    forceGarbageCollection();
                }
            }
        }
        
        // ê°•ì œ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ìœ ë„
        function forceGarbageCollection() {
            if (typeof gc === 'function') {
                gc();
            } else {
                // ê°„ì ‘ì  GC ìœ ë„
                let temp = [];
                for (let i = 0; i < 10000; i++) temp.push({});
                temp = null;
            }
        }
        
        // ì£¼ê¸°ì  ë©”ëª¨ë¦¬ ì •ë¦¬
        function startMemoryManagement() {
            if (gcTimer) clearInterval(gcTimer);
            gcTimer = setInterval(() => {
                checkMemoryUsage();
            }, GC_INTERVAL);
        }
    </script>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- ë¡œê·¸ì¸ í™”ë©´ -->
    <div id="loginScreen">
        <div class="login-box">
            <div class="login-logo">E</div>
            <div class="login-title">ì—‘ì…€ë§ˆìŠ¤í„°</div>
            <div class="login-subtitle">ì‹¤ì‹œê°„ í˜‘ì—… ìŠ¤í”„ë ˆë“œì‹œíŠ¸</div>
            <button class="google-login-btn" onclick="googleLogin()">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
                Google ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸
            </button>
            <div class="login-divider">ë˜ëŠ”</div>
            <button class="login-enter-btn" onclick="enterOfflineMode()" style="background:var(--retro-warm-gray);">
                ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì‹œì‘
            </button>
            <p style="font-size:11px;color:var(--retro-warm-gray);margin-top:15px;">ì˜¤í”„ë¼ì¸ ëª¨ë“œ: ë¡œê·¸ì¸ ì—†ì´ íŒŒì¼ ì‘ì—… ê°€ëŠ¥<br>(ì„œë²„ ì €ì¥ ê¸°ëŠ¥ ì œì™¸)</p>
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="loading-content">
            <div class="spinner"></div>
            <div id="loadingText">ì²˜ë¦¬ ì¤‘...</div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>
    
    <!-- ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜¤ë²„ë ˆì´ -->
    <div class="drop-overlay" id="dropOverlay">
        <div class="drop-overlay-content">
            <div class="drop-overlay-icon">ğŸ“‚</div>
            <div class="drop-overlay-text">íŒŒì¼ì„ ì—¬ê¸°ì— ë†“ìœ¼ì„¸ìš”</div>
            <div class="drop-overlay-subtext">Excel, CSV, PDF, PPT, DOCX, TXT, HTML íŒŒì¼ ì§€ì›</div>
        </div>
    </div>
    
    <!-- ê²€ìƒ‰ ê²°ê³¼ ìƒì„¸ ëª¨ë‹¬ -->
    <div class="detail-modal" id="detailModal">
        <div class="detail-modal-content">
            <div class="detail-modal-header">
                <div class="detail-modal-title">
                    <span class="sheet-badge" id="detailSheetName"></span>
                    <span class="row-badge" id="detailRowNum"></span>
                </div>
                <button class="detail-modal-close" onclick="closeDetailModal()">&times;</button>
            </div>
            <div class="detail-modal-body" id="detailModalBody"></div>
            <div class="detail-modal-footer">
                <button class="detail-modal-btn" onclick="closeDetailModal()">ë‹«ê¸°</button>
                <button class="detail-modal-btn primary" id="goToSheetBtn" onclick="goToSheetFromDetail()">í•´ë‹¹ ì‹œíŠ¸ë¡œ ì´ë™</button>
            </div>
        </div>
    </div>
    
    <!-- ì—…ë¡œë“œ ë¦¬ë·° ëª¨ë‹¬ -->
    <div class="modal-overlay upload-review-modal" id="uploadReviewModal">
        <div class="modal-content compact">
            <div class="modal-header">
                <h3>ğŸ“‹ ì—…ë¡œë“œ ê²€í† </h3>
                <button class="modal-close" onclick="closeUploadReview()">&times;</button>
            </div>

            <!-- ê°„ì†Œí™”ëœ ìš”ì•½ (í•œ ì¤„) -->
            <div class="upload-review-summary compact" id="reviewSummary">
                <span class="summary-item"><strong id="summarySheets">0</strong> ìƒˆì‹œíŠ¸</span>
                <span class="summary-item"><strong id="summaryAdditions">0</strong> ì¶”ê°€</span>
                <span class="summary-item"><strong id="summaryChanges">0</strong> ë³€ê²½</span>
                <span class="summary-item error"><strong id="summaryErrors">0</strong> ì˜¤ë¥˜</span>
            </div>

            <!-- ê°„ì†Œí™”ëœ íƒ­ -->
            <div class="review-tabs compact">
                <button class="review-tab active" data-tab="additions" onclick="switchReviewTab('additions')">ì¶”ê°€ <span class="badge green" id="tabAdditions">0</span></button>
                <button class="review-tab" data-tab="changes" onclick="switchReviewTab('changes')">ë³€ê²½ <span class="badge orange" id="tabChanges">0</span></button>
                <button class="review-tab" data-tab="errors" onclick="switchReviewTab('errors')">ì˜¤ë¥˜ <span class="badge red" id="tabErrors">0</span></button>
                <button class="review-tab" data-tab="sheets" onclick="switchReviewTab('sheets')">ìƒˆì‹œíŠ¸ <span class="badge blue" id="tabSheets">0</span></button>
            </div>

            <div class="review-content" id="reviewContent">
                <ul class="review-list" id="reviewList"></ul>
            </div>

            <!-- ê°„ì†Œí™”ëœ ë²„íŠ¼ (2ê°œë¡œ ì¶•ì†Œ) -->
            <div class="review-actions compact">
                <button class="modal-btn" onclick="closeUploadReview()">ì·¨ì†Œ</button>
                <button class="modal-btn success" onclick="applyAllReview()">âœ“ ì „ì²´ ì ìš©</button>
            </div>
        </div>
    </div>

    <!-- íœ´ì§€í†µ ëª¨ë‹¬ -->
    <div class="modal-overlay trash-modal" id="trashModal" onclick="if(event.target===this) closeTrashModal()">
        <div class="modal-content trash-content">
            <div class="modal-header">
                <h3>ğŸ—‘ï¸ íœ´ì§€í†µ</h3>
                <button class="modal-close" onclick="closeTrashModal()">&times;</button>
            </div>
            <div class="trash-info">
                <span>ì‚­ì œëœ í•­ëª©ì€ <strong>7ì¼ í›„</strong> ìë™ ì‚­ì œë©ë‹ˆë‹¤</span>
                <button class="trash-empty-btn" onclick="emptyTrash()">ë¹„ìš°ê¸°</button>
            </div>
            <div class="trash-list" id="trashList">
                <div class="trash-empty-state">íœ´ì§€í†µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</div>
            </div>
        </div>
    </div>

    <!-- ìë™ì €ì¥ ì„¤ì • ëª¨ë‹¬ -->
    <div class="modal-overlay autosave-modal" id="autoSaveModal" onclick="if(event.target===this) closeAutoSaveModal()">
        <div class="modal-content autosave-content">
            <div class="modal-header">
                <h3>ğŸ’¾ ìë™ ì €ì¥ ì„¤ì •</h3>
                <button class="modal-close" onclick="closeAutoSaveModal()">&times;</button>
            </div>
            <div class="autosave-options">
                <label class="autosave-toggle">
                    <input type="checkbox" id="autoSaveToggle" onchange="toggleAutoSave(this.checked)" checked>
                    <span>ìë™ ì €ì¥ ì‚¬ìš©</span>
                </label>
                <div class="autosave-interval">
                    <span>ì €ì¥ ì£¼ê¸°:</span>
                    <select id="autoSaveIntervalSelect" onchange="setAutoSaveInterval(this.value)">
                        <option value="1">1ë¶„</option>
                        <option value="3">3ë¶„</option>
                        <option value="5" selected>5ë¶„</option>
                        <option value="10">10ë¶„</option>
                        <option value="30">30ë¶„</option>
                    </select>
                </div>
                <div class="autosave-last" id="autoSaveLastInfo">
                    ë§ˆì§€ë§‰ ìë™ì €ì¥: -
                </div>
            </div>
        </div>
    </div>

    <!-- ë©”ì¸ í™”ë©´ -->
    <div id="mainScreen" style="display:none;">
        <div class="main-header compact">
            <!-- ê°„ì†Œí™”ëœ ë‹¨ì¼ í—¤ë” -->
            <div class="main-header-row single">
                <div class="main-title">ì—‘ì…€ë§ˆìŠ¤í„°</div>

                <div class="header-compact-group">
                    <input type="text" id="mainSearchInput" class="main-search compact" placeholder="ê²€ìƒ‰..." oninput="handleMainSearchInput(event)" onkeydown="handleMainSearchKeydown(event)" oncompositionstart="isComposing=true" oncompositionend="isComposing=false; doMainSearch()">

                    <input type="file" id="mainFileInput" class="file-input" accept=".xlsx,.xls,.csv,.tsv,.txt,.pdf,.pptx,.docx,.html,.htm">
                    <button class="main-btn compact" onclick="document.getElementById('mainFileInput').click()">ğŸ“ ì—´ê¸°</button>
                    <button class="main-btn compact" onclick="addSheetFromMain()">â• ìƒˆì‹œíŠ¸</button>

                    <button class="main-btn compact" onclick="simpleServerSave()" style="background:var(--retro-green);color:white;">â¬†ï¸ ì €ì¥</button>
                    <button class="main-btn compact" onclick="simpleServerLoad()" style="background:var(--retro-blue);color:white;">â¬‡ï¸ ë¶ˆëŸ¬ì˜¤ê¸°</button>

                    <!-- ê¸°ê°„ ë“œë¡­ë‹¤ìš´ -->
                    <div class="date-dropdown-wrapper">
                        <button class="main-btn compact date-dropdown-btn" onclick="toggleDateDropdown()">
                            ğŸ“… <span id="selectedDateLabel">ì „ì²´</span> â–¼
                        </button>
                        <div class="date-dropdown-menu" id="dateDropdownMenu">
                            <div class="date-dropdown-item" onclick="setQuickDate('all')">ì „ì²´</div>
                            <div class="date-dropdown-item" onclick="setQuickDate('today')">ì˜¤ëŠ˜</div>
                            <div class="date-dropdown-item" onclick="setQuickDate('week')">ì´ë²ˆì£¼</div>
                            <div class="date-dropdown-item" onclick="setQuickDate('month')">ì´ë²ˆë‹¬</div>
                            <div class="date-dropdown-item" onclick="setQuickDate('3months')">ìµœê·¼ 3ê°œì›”</div>
                            <div class="date-dropdown-item" onclick="setQuickDate('6months')">6ê°œì›”</div>
                            <div class="date-dropdown-item" onclick="setQuickDate('1year')">1ë…„</div>
                            <div class="date-dropdown-divider"></div>
                            <div class="date-dropdown-custom">
                                <input type="date" id="dateFrom" class="date-input compact">
                                <span>~</span>
                                <input type="date" id="dateTo" class="date-input compact">
                                <button class="main-btn compact" onclick="doDateSearch()">ì ìš©</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="user-info compact" id="userInfo">
                    <img class="user-avatar" id="userAvatar" src="" alt="">
                    <span class="user-name" id="userName"></span>
                    <button class="logout-btn compact" onclick="logout()">ë¡œê·¸ì•„ì›ƒ</button>
                </div>
            </div>
        </div>
        <div class="main-content">
            <div id="pendingAdditionsSection" style="display:none;">
                <div class="section-title" style="color:var(--retro-green);">
                    ì‹ ê·œ ì¶”ê°€ ê±´<span id="additionsCountBadge">0ê±´</span>
                    <span style="float:right;">
                        <button class="pending-btn apply" onclick="applyAllAdditions()" style="margin-right:5px;">ì „ì²´ ì ìš©</button>
                        <button class="pending-btn skip" onclick="skipAllAdditions()">ì „ì²´ ë¬´ì‹œ</button>
                    </span>
                </div>
                <div class="pending-additions-list" id="pendingAdditionsList"></div>
            </div>
            
            <div id="pendingChangesSection" style="display:none;">
                <div class="section-title" style="color:var(--retro-coral);">
                    ë³€ê²½ ì˜ì‹¬ ê±´<span id="pendingCountBadge">0ê±´</span>
                    <span style="float:right;">
                        <button class="pending-btn apply" onclick="applyAllChanges()" style="margin-right:5px;">ì „ì²´ ì ìš©</button>
                        <button class="pending-btn skip" onclick="skipAllChanges()">ì „ì²´ ë¬´ì‹œ</button>
                    </span>
                </div>
                <div class="pending-changes-list" id="pendingChangesList"></div>
            </div>
            
            <div class="section-title sheet-list-header">
                <div class="sheet-list-title">
                    <!-- íƒ­ UI -->
                    <div class="main-tabs">
                        <button class="main-tab active" data-tab="sheets" onclick="switchMainTab('sheets')">ì‹œíŠ¸ ëª©ë¡</button>
                        <button class="main-tab" data-tab="files" onclick="switchMainTab('files')">íŒŒì¼ ë³´ê´€í•¨</button>
                        <button class="main-tab" data-tab="rawfiles" onclick="switchMainTab('rawfiles')">ì›ë³¸ íŒŒì¼</button>
                    </div>
                    <span id="sheetCountBadge" class="count-badge" style="margin-left:10px;">0ê°œ</span>
                </div>
                <div class="sheet-list-actions compact">
                    <!-- ë·°ëª¨ë“œ ë“œë¡­ë‹¤ìš´ (í†µí•©) -->
                    <div class="view-dropdown-wrapper">
                        <button class="action-btn compact" onclick="toggleViewDropdown()" id="viewModeBtn">
                            <span id="currentViewIcon">â€¢â€¢â€¢</span> â–¼
                        </button>
                        <div class="view-dropdown-menu" id="viewDropdownMenu">
                            <div class="view-dropdown-item" onclick="setUnifiedViewMode('icon')">â€¢â€¢â€¢ ì•„ì´ì½˜</div>
                            <div class="view-dropdown-item" onclick="setUnifiedViewMode('card')">â–¦ ì¹´ë“œ</div>
                            <div class="view-dropdown-item" onclick="setUnifiedViewMode('list')">â˜° ë¦¬ìŠ¤íŠ¸</div>
                        </div>
                    </div>
                    <label class="favorite-filter compact"><input type="checkbox" id="favoriteFilter" onchange="toggleFavoriteFilter()"> â­</label>
                    <button class="action-btn compact" onclick="showMultiSelectDownloadModal()">ğŸ“¥</button>
                    <button class="action-btn compact" onclick="openTrashModal()" title="íœ´ì§€í†µ">ğŸ—‘ï¸ <span id="trashCount" class="trash-count" style="display:none;">0</span></button>
                    <div class="auto-save-status" id="autoSaveStatus" title="ìë™ì €ì¥ ì„¤ì •" onclick="openAutoSaveModal()">
                        <span class="auto-save-icon">ğŸ’¾</span>
                        <span class="auto-save-text" id="autoSaveText">ìë™ì €ì¥ ON</span>
                    </div>
                    <div class="action-group">
                        <button class="action-btn merge-action-btn" id="mergeActionBtn" onclick="openManualMergeModal()" style="background:var(--retro-coral);color:white;display:none;">ë³‘í•©</button>
                        <button class="action-btn" onclick="resetAllFilters()" style="background:var(--retro-mustard);color:white;">í•„í„° ì´ˆê¸°í™”</button>
                    </div>
                </div>
            </div>
            
            <!-- ì‹œíŠ¸ ëª©ë¡ ì»¨í…Œì´ë„ˆ -->
            <div id="sheetsContainer">
                <!-- í´ë” ë„¤ë¹„ê²Œì´ì…˜ ë°” -->
                <div class="folder-nav-bar" id="folderNavBar">
                    <div class="folder-nav-history">
                        <button class="folder-nav-history-btn" id="folderBackBtn" onclick="folderGoBack()" disabled title="ë’¤ë¡œ">â—€</button>
                        <button class="folder-nav-history-btn" id="folderForwardBtn" onclick="folderGoForward()" disabled title="ì•ìœ¼ë¡œ">â–¶</button>
                    </div>
                    <div class="folder-breadcrumb" id="folderBreadcrumb">
                        <span class="folder-breadcrumb-item current" onclick="navigateToFolder(null)">ğŸ“ ì „ì²´</span>
                    </div>
                    <div class="folder-nav-actions">
                        <button class="folder-nav-btn" onclick="createNewFolder()">ğŸ“ ìƒˆ í´ë”</button>
                    </div>
                </div>
                <div class="sheet-grid" id="sheetGrid"></div>
            </div>
            
            <!-- íŒŒì¼ ë³´ê´€í•¨ ì»¨í…Œì´ë„ˆ -->
            <div id="fileStorageContainer" style="display:none;" oncontextmenu="showFileContextMenu(event)">
                <div class="file-storage-empty">
                    <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“</div>
                    <div>ë³´ê´€ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>
                    <div style="font-size: 12px; margin-top: 8px;">PDF, PPT, DOCX, TXT íŒŒì¼ì„ ì—…ë¡œë“œí•´ë³´ì„¸ìš”</div>
                </div>
            </div>

            <!-- ì›ë³¸ íŒŒì¼ ì»¨í…Œì´ë„ˆ -->
            <div id="rawFilesContainer" style="display:none;">
                <div class="raw-files-header">
                    <div class="raw-files-upload-area" id="rawFilesUploadArea" onclick="document.getElementById('rawFileInput').click()">
                        <input type="file" id="rawFileInput" class="file-input" accept=".xlsx,.xls,.csv" onchange="handleRawFileUpload(event)">
                        <div class="upload-icon">ğŸ“¤</div>
                        <div class="upload-text">ì—‘ì…€ íŒŒì¼ì„ ì—¬ê¸°ì— ë“œë¡­í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œ</div>
                        <div class="upload-hint">ê°™ì€ íŒŒì¼ëª…ì€ ë°ì´í„°ê°€ ëˆ„ì ë©ë‹ˆë‹¤</div>
                    </div>
                </div>
                <!-- ê²€ìƒ‰/ì •ë ¬ íˆ´ë°” -->
                <div class="raw-files-toolbar">
                    <input type="text" id="rawFileSearch" class="raw-file-search-input" placeholder="íŒŒì¼ëª… ê²€ìƒ‰..."
                           oninput="rawFileSearchKeyword = this.value; renderRawFilesList()">
                    <select id="rawFileSortSelect" class="raw-file-sort-select" onchange="setRawFileSort(this.value)">
                        <option value="lastUpdated-desc">ìµœê·¼ ì—…ë°ì´íŠ¸ìˆœ</option>
                        <option value="lastUpdated-asc">ì˜¤ë˜ëœìˆœ</option>
                        <option value="name-asc">ì´ë¦„ìˆœ (A-Z)</option>
                        <option value="name-desc">ì´ë¦„ìˆœ (Z-A)</option>
                        <option value="totalRows-desc">í–‰ ìˆ˜ ë§ì€ìˆœ</option>
                        <option value="totalRows-asc">í–‰ ìˆ˜ ì ì€ìˆœ</option>
                    </select>
                    <button class="raw-file-select-btn" id="rawFileSelectModeBtn" onclick="toggleRawFileSelectMode()">ì„ íƒ</button>
                    <button class="raw-folder-create-btn" onclick="createRawFileFolder()" title="ìƒˆ í´ë” ë§Œë“¤ê¸°">ğŸ“+</button>
                    <span class="raw-file-count">0ê°œ íŒŒì¼</span>
                </div>
                <!-- ì„ íƒ ëª¨ë“œ ì•¡ì…˜ ë°” -->
                <div class="raw-files-action-bar" id="rawFilesActionBar" style="display:none;">
                    <span class="raw-file-selected-count">0ê°œ ì„ íƒ</span>
                    <button class="raw-file-action-btn" onclick="selectAllRawFiles()">ì „ì²´ ì„ íƒ</button>
                    <button class="raw-file-action-btn" onclick="deselectAllRawFiles()">ì„ íƒ í•´ì œ</button>
                    <button class="raw-file-action-btn" onclick="showMoveSelectedToFolderModal()">ğŸ“ ì´ë™</button>
                    <button class="raw-file-action-btn primary" onclick="downloadSelectedRawFiles()">ë‹¤ìš´ë¡œë“œ</button>
                    <button class="raw-file-action-btn danger" onclick="deleteSelectedRawFiles()">ì‚­ì œ</button>
                </div>
                <div class="raw-files-list" id="rawFilesList">
                    <div class="raw-files-empty">
                        <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“Š</div>
                        <div>ì›ë³¸ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>
                        <div style="font-size: 12px; margin-top: 8px;">ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ë°ì´í„°ê°€ ëˆ„ì ë©ë‹ˆë‹¤</div>
                    </div>
                </div>
            </div>
            
            <div id="searchResultsSection" style="display:none;">
                <div class="section-title" style="margin-top:20px;">
                    ê²€ìƒ‰ ê²°ê³¼<span id="searchCountBadge">0ê±´</span>
                    <span class="search-view-toggle">
                        <button class="search-view-btn active" id="listViewBtn" onclick="setSearchView('list')">ëª©ë¡</button>
                        <button class="search-view-btn" id="tableViewBtn" onclick="setSearchView('table')">í‘œ</button>
                    </span>
                    <button class="main-btn" onclick="clearSearchResults()" style="margin-left:10px;padding:4px 10px;font-size:11px;">ê²€ìƒ‰ ì´ˆê¸°í™”</button>
                    <button class="main-btn" onclick="downloadSearchResults()" style="float:right;padding:4px 10px;font-size:11px;">ê²€ìƒ‰ê²°ê³¼ ë‹¤ìš´ë¡œë“œ</button>
                </div>
                <div class="search-results" id="searchResults"></div>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="columnModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>ì—´ í‘œì‹œ/ìˆ¨ê¸°ê¸°</h3>
                <button class="modal-close" onclick="closeColumnManager()">Ã—</button>
            </div>
            <ul class="col-list" id="columnList"></ul>
            <div class="modal-footer">
                <button class="modal-btn" onclick="selectAllColumns()">ì „ì²´ ì„ íƒ</button>
                <button class="modal-btn" onclick="deselectAllColumns()">ì „ì²´ í•´ì œ</button>
                <button class="modal-btn primary" onclick="applyColumnVisibility()">ì ìš©</button>
            </div>
        </div>
    </div>
    
    <div id="detailScreen" style="display:none;">
        <!-- ê°„ì†Œí™”ëœ ë‹¨ì¼ íˆ´ë°” -->
        <div class="toolbar compact">
            <button class="tool-btn" onclick="goToMain()">â—€</button>
            <span class="current-sheet-name" id="currentSheetName"></span>

            <div class="toolbar-group">
                <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls,.csv,.tsv,.txt,.pdf,.pptx,.docx,.html,.htm">
                <button class="tool-btn" onclick="downloadExcel()" title="ì €ì¥">ğŸ’¾</button>
                <button class="tool-btn" onclick="saveSheetToFirestore(SHEET)" title="ì„œë²„ ì €ì¥" style="background:var(--retro-green);color:white;">â˜ï¸</button>
            </div>

            <div class="toolbar-group">
                <button class="tool-btn" onclick="undo()" title="ì‹¤í–‰ì·¨ì†Œ">â†©</button>
                <button class="tool-btn" onclick="redo()" title="ë‹¤ì‹œì‹¤í–‰">â†ª</button>
                <button class="tool-btn" onclick="insertRow()" title="í–‰ ì¶”ê°€">+í–‰</button>
                <button class="tool-btn danger" onclick="deleteSelected()" title="ì‚­ì œ">ğŸ—‘ï¸</button>
            </div>

            <div class="toolbar-group">
                <input type="date" id="workDate" class="date-input compact">
                <button class="tool-btn primary" onclick="addNewEntry()">+ ì‹ ê·œ</button>
                <button class="tool-btn" id="finishEntryBtn" onclick="finishNewEntryMode()" style="display:none;background:var(--retro-mustard);">ì™„ë£Œ</button>
            </div>

            <!-- ë”ë³´ê¸° ë“œë¡­ë‹¤ìš´ -->
            <div class="toolbar-more-wrapper">
                <button class="tool-btn" onclick="toggleToolbarMore()">â‹¯</button>
                <div class="toolbar-more-menu" id="toolbarMoreMenu">
                    <div class="toolbar-more-item" onclick="document.getElementById('fileInput').click(); closeToolbarMore();">ğŸ“‚ íŒŒì¼ ì—´ê¸°</div>
                    <div class="toolbar-more-item" onclick="showCurrentSheetExportModal(); closeToolbarMore();">ğŸ“¥ ë‹¤ìš´ë¡œë“œ</div>
                    <div class="toolbar-more-item" onclick="printSheet(); closeToolbarMore();">ğŸ–¨ï¸ ì¸ì‡„</div>
                    <div class="toolbar-more-divider"></div>
                    <div class="toolbar-more-item" onclick="insertCol(); closeToolbarMore();">â• ì—´ ì¶”ê°€</div>
                    <div class="toolbar-more-item" onclick="showColumnManager(); closeToolbarMore();">ğŸ“Š ì—´ ê´€ë¦¬</div>
                    <div class="toolbar-more-item" onclick="toggleResizeMode(); closeToolbarMore();">â†”ï¸ í¬ê¸° ì¡°ì ˆ</div>
                    <div class="toolbar-more-divider"></div>
                    <div class="toolbar-more-item" onclick="toggleCopyMode(); closeToolbarMore();">ğŸ“‹ ë³µì‚¬ ëª¨ë“œ</div>
                    <div class="toolbar-more-item" onclick="decreaseFontSize(); closeToolbarMore();">A- ê¸€ì ì‘ê²Œ</div>
                    <div class="toolbar-more-item" onclick="increaseFontSize(); closeToolbarMore();">A+ ê¸€ì í¬ê²Œ</div>
                    <div class="toolbar-more-divider"></div>
                    <div class="toolbar-more-item danger" onclick="toggleResetMenu(); closeToolbarMore();">ğŸ—‘ï¸ ì´ˆê¸°í™”</div>
                </div>
            </div>
        </div>

        <!-- ì´ˆê¸°í™” ë©”ë‰´ (ê¸°ì¡´ ìœ ì§€) -->
        <div class="reset-menu" id="resetMenu" style="display:none;">
            <div class="menu-item" onclick="resetSheetData()">ë°ì´í„°ë§Œ ì‚­ì œ</div>
            <div class="menu-item" onclick="resetColumnOrder()">ì—´ ìˆœì„œ ì´ˆê¸°í™”</div>
            <div class="menu-item" onclick="resetAllSizes()">í¬ê¸° ì´ˆê¸°í™”</div>
            <div class="menu-item danger" onclick="resetSheetAll()">ì „ì²´ ì‚­ì œ</div>
        </div>
        
        <div class="formula-bar">
            <input type="text" class="cell-address" id="cellAddress" readonly value="A1">
            <input type="text" class="formula-input" id="formulaInput" placeholder="ì…€ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”">
        </div>
        
        <div class="spreadsheet-container" id="spreadsheetContainer">
            <table class="spreadsheet" id="spreadsheet"></table>
        </div>
        
        <!-- ê²€ìƒ‰ ê²°ê³¼ ì „ìš© í™”ë©´ (ë©”ì¸ ì˜ì—­) -->
        <div class="search-results-main" id="searchResultsMain" style="display:none;">
            <div class="search-results-header">
                <div class="search-results-title">
                    <span class="search-results-icon">ğŸ”</span>
                    <h2>ê²€ìƒ‰ ê²°ê³¼</h2>
                    <span class="search-results-count" id="mainSearchCount">0ê±´</span>
                    <span class="search-results-keyword" id="mainSearchKeyword"></span>
                </div>
                <div class="search-results-actions">
                    <button class="search-action-btn" onclick="downloadSearchResults()">ğŸ“¥ ë‹¤ìš´ë¡œë“œ</button>
                    <button class="search-action-btn primary" onclick="closeSearchResultsMain(true)">âœ• ë‹«ê¸°</button>
                </div>
            </div>
            <div class="search-sheet-tabs" id="searchSheetTabs">
                <!-- ì‹œíŠ¸ íƒ­ë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
            </div>
            <div class="search-results-body" id="searchResultsMainBody">
                <!-- ê²€ìƒ‰ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë¨ -->
            </div>
            <div class="search-results-footer">
                <span id="searchResultsStatus">ê²€ìƒ‰ ê²°ê³¼ë¥¼ í´ë¦­í•˜ë©´ í•´ë‹¹ ì…€ë¡œ ì´ë™í•©ë‹ˆë‹¤</span>
            </div>
        </div>
        
        <div class="sheet-tabs-container" id="sheetTabsContainer"></div>
        
        <div class="status-bar">
            <span id="statusLeft">ì¤€ë¹„</span>
            <span id="statusRight">í–‰: 0 | ì—´: 0</span>
        </div>
        
        <div class="page-navigator" id="pageNavigator">
            <button class="page-nav-btn" onclick="goToTop()" title="ìµœìƒë‹¨">â–²</button>
            <div class="page-nav-numbers" id="pageNavNumbers"></div>
            <button class="page-nav-btn" onclick="goToBottom()" title="ìµœí•˜ë‹¨">â–¼</button>
        </div>
    </div>

    <div class="context-menu" id="contextMenu">
        <div class="menu-item" onclick="insertRowAbove()">â†‘ ìœ„ì— í–‰ ì‚½ì…</div>
        <div class="menu-item" onclick="insertRowBelow()">â†“ ì•„ë˜ì— í–‰ ì‚½ì…</div>
        <div class="menu-divider"></div>
        <div class="menu-item" onclick="copyCell()">ë³µì‚¬</div>
        <div class="menu-item" onclick="pasteCell()">ë¶™ì—¬ë„£ê¸°</div>
        <div class="menu-divider"></div>
        <div class="menu-item danger" onclick="deleteRow()">í–‰ ì‚­ì œ</div>
    </div>
    
    <div class="context-menu" id="colContextMenu">
        <div class="menu-item" onclick="insertColLeft()">â† ì™¼ìª½ì— ì—´ ì‚½ì…</div>
        <div class="menu-item" onclick="insertColRight()">â†’ ì˜¤ë¥¸ìª½ì— ì—´ ì‚½ì…</div>
        <div class="menu-divider"></div>
        <div class="menu-item" onclick="autoFitSelectedCol()">ì—´ ë„ˆë¹„ ìë™ ë§ì¶¤</div>
        <div class="menu-item" onclick="hideSelectedCol()">ì—´ ìˆ¨ê¸°ê¸°</div>
        <div class="menu-divider"></div>
        <div class="menu-item danger" onclick="deleteCol()">ì—´ ì‚­ì œ</div>
    </div>
    
    <div class="context-menu" id="rowContextMenu">
        <div class="menu-item" onclick="insertRowAbove()">â†‘ ìœ„ì— í–‰ ì‚½ì…</div>
        <div class="menu-item" onclick="insertRowBelow()">â†“ ì•„ë˜ì— í–‰ ì‚½ì…</div>
        <div class="menu-divider"></div>
        <div class="menu-item" onclick="autoFitSelectedRow()">í–‰ ë†’ì´ ìë™ ë§ì¶¤</div>
        <div class="menu-item" onclick="copyRow()">í–‰ ë³µì‚¬</div>
        <div class="menu-item" onclick="pasteRow()">í–‰ ë¶™ì—¬ë„£ê¸°</div>
        <div class="menu-divider"></div>
        <div class="menu-item danger" onclick="deleteRow()">í–‰ ì‚­ì œ</div>
    </div>
    
    <!-- ë©”ì¸ í™”ë©´ ë¹ˆ ê³µê°„ ìš°í´ë¦­ ë©”ë‰´ -->
    <div class="context-menu" id="mainContextMenu">
        <div class="menu-item" onclick="createNewFolder()">ğŸ“ ìƒˆ í´ë”</div>
        <div class="menu-divider"></div>
        <div class="menu-item" onclick="document.getElementById('mainFileInput').click()">ğŸ“„ íŒŒì¼ ì—…ë¡œë“œ</div>
        <div class="menu-item" onclick="refreshMainScreen()">ğŸ”„ ìƒˆë¡œê³ ì¹¨</div>
    </div>

<script>
// ===== ìœ í‹¸ë¦¬í‹° ê°ì²´ë“¤ (ë¦¬íŒ©í† ë§) =====

/**
 * í¬ë§· ìœ í‹¸ë¦¬í‹° - ë‚ ì§œ, ìˆ«ì, íŒŒì¼ í¬ê¸° ë“± ë³€í™˜
 */
const Format = {
    // ë‚ ì§œ í¬ë§· (ê¸°ë³¸: YYYY.MM.DD)
    date(date, format = 'YYYY.MM.DD') {
        if (!date) return '';
        const d = date instanceof Date ? date : new Date(date);
        if (isNaN(d.getTime())) return '';
        const map = {
            YYYY: d.getFullYear(),
            MM: String(d.getMonth() + 1).padStart(2, '0'),
            DD: String(d.getDate()).padStart(2, '0'),
            HH: String(d.getHours()).padStart(2, '0'),
            mm: String(d.getMinutes()).padStart(2, '0'),
            ss: String(d.getSeconds()).padStart(2, '0')
        };
        return format.replace(/YYYY|MM|DD|HH|mm|ss/g, m => map[m]);
    },
    
    // í•œê¸€ ë‚ ì§œ (YYYYë…„ MMì›” DDì¼)
    dateKorean(date) {
        if (!date) return '';
        const d = date instanceof Date ? date : new Date(date);
        if (isNaN(d.getTime())) return '';
        return `${d.getFullYear()}ë…„ ${d.getMonth() + 1}ì›” ${d.getDate()}ì¼`;
    },
    
    // ìˆ«ì ì½¤ë§ˆ í¬ë§·
    number(num) {
        if (num === null || num === undefined) return '0';
        return Number(num).toLocaleString();
    },
    
    // íŒŒì¼ í¬ê¸° í¬ë§·
    fileSize(bytes) {
        if (!bytes || bytes === 0) return '0B';
        if (bytes < 1024) return bytes + 'B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + 'KB';
        if (bytes < 1024 * 1024 * 1024) return (bytes / 1024 / 1024).toFixed(1) + 'MB';
        return (bytes / 1024 / 1024 / 1024).toFixed(1) + 'GB';
    },
    
    // ê²½ê³¼ ì‹œê°„ (ë°©ê¸ˆ, Në¶„ ì „, Nì‹œê°„ ì „, Nì¼ ì „)
    timeAgo(date) {
        if (!date) return '';
        const d = date instanceof Date ? date : new Date(date);
        const now = new Date();
        const diff = Math.floor((now - d) / 1000);
        
        if (diff < 60) return 'ë°©ê¸ˆ';
        if (diff < 3600) return Math.floor(diff / 60) + 'ë¶„ ì „';
        if (diff < 86400) return Math.floor(diff / 3600) + 'ì‹œê°„ ì „';
        if (diff < 604800) return Math.floor(diff / 86400) + 'ì¼ ì „';
        return Format.date(d);
    },
    
    // í¼ì„¼íŠ¸ í¬ë§·
    percent(value, decimals = 1) {
        if (value === null || value === undefined) return '0%';
        return Number(value).toFixed(decimals) + '%';
    }
};

/**
 * ì—ëŸ¬ ì²˜ë¦¬ ìœ í‹¸ë¦¬í‹°
 */
const ErrorHandler = {
    // ì—ëŸ¬ ì²˜ë¦¬
    handle(error, context = '') {
        const prefix = context ? `[${context}] ` : '';
        console.error(prefix, error);
        
        // ì—ëŸ¬ ìœ í˜•ë³„ ë©”ì‹œì§€
        if (error.name === 'QuotaExceededError') {
            toast('ì €ì¥ ê³µê°„ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ë¶ˆí•„ìš”í•œ ë°ì´í„°ë¥¼ ì‚­ì œí•´ì£¼ì„¸ìš”.');
        } else if (error.message?.includes('network') || error.message?.includes('Network')) {
            toast('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
        } else if (error.message?.includes('permission') || error.message?.includes('Permission')) {
            toast('ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.');
        } else if (error.message?.includes('timeout') || error.message?.includes('Timeout')) {
            toast('ìš”ì²­ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        } else {
            toast(prefix + (error.message || 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤'));
        }
    },
    
    // async í•¨ìˆ˜ ë˜í¼ (ìë™ ì—ëŸ¬ ì²˜ë¦¬)
    async wrap(fn, context = '') {
        try {
            return await fn();
        } catch (e) {
            this.handle(e, context);
            return null;
        }
    },
    
    // ë™ê¸° í•¨ìˆ˜ ë˜í¼
    wrapSync(fn, context = '') {
        try {
            return fn();
        } catch (e) {
            this.handle(e, context);
            return null;
        }
    }
};

/**
 * ëª¨ë‹¬ ìœ í‹¸ë¦¬í‹° - í†µí•© ëª¨ë‹¬ ìƒì„±/ê´€ë¦¬
 */
const Modal = {
    // ëª¨ë‹¬ ìƒì„±
    create({ id, title, body, footer, width = '400px', className = '', onClose = null }) {
        // ê¸°ì¡´ ëª¨ë‹¬ ì œê±°
        this.close(id);
        
        const html = `
            <div class="modal-overlay ${className}" id="${id}" style="display:flex;align-items:center;justify-content:center;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10000;">
                <div class="modal-content" style="background:white;border-radius:12px;width:${width};max-width:95vw;max-height:90vh;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.3);">
                    <div class="modal-header" style="display:flex;justify-content:space-between;align-items:center;padding:16px 20px;border-bottom:1px solid #eee;">
                        <h3 style="margin:0;font-size:16px;">${title}</h3>
                        <button class="modal-close-btn" data-modal-close="${id}" style="background:none;border:none;font-size:24px;cursor:pointer;color:#999;">&times;</button>
                    </div>
                    <div class="modal-body" style="padding:20px;overflow-y:auto;max-height:60vh;">
                        ${body}
                    </div>
                    ${footer ? `<div class="modal-footer" style="padding:15px 20px;border-top:1px solid #eee;display:flex;gap:10px;justify-content:flex-end;">${footer}</div>` : ''}
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', html);
        
        const modal = document.getElementById(id);
        
        // ë‹«ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
        const closeBtn = modal.querySelector(`[data-modal-close="${id}"]`);
        if (closeBtn) {
            closeBtn.onclick = () => {
                if (onClose) onClose();
                this.close(id);
            };
        }
        
        // ë°°ê²½ í´ë¦­ ì‹œ ë‹«ê¸°
        modal.onclick = (e) => {
            if (e.target === modal) {
                if (onClose) onClose();
                this.close(id);
            }
        };
        
        return modal;
    },
    
    // ëª¨ë‹¬ ë‹«ê¸°
    close(id) {
        const modal = document.getElementById(id);
        if (modal) modal.remove();
    },
    
    // í™•ì¸ ëª¨ë‹¬ (Promise ë°˜í™˜)
    confirm({ title = 'í™•ì¸', message, confirmText = 'í™•ì¸', cancelText = 'ì·¨ì†Œ' }) {
        return new Promise((resolve) => {
            const id = 'confirmModal_' + Date.now();
            
            this.create({
                id,
                title,
                body: `<p style="margin:0;color:#333;">${message}</p>`,
                footer: `
                    <button class="modal-btn cancel" onclick="Modal.close('${id}'); Modal._resolve(false);" style="padding:8px 16px;border:1px solid #ddd;background:white;border-radius:6px;cursor:pointer;">${cancelText}</button>
                    <button class="modal-btn primary" onclick="Modal.close('${id}'); Modal._resolve(true);" style="padding:8px 16px;border:none;background:var(--retro-teal, #2a9d8f);color:white;border-radius:6px;cursor:pointer;">${confirmText}</button>
                `,
                width: '350px',
                onClose: () => resolve(false)
            });
            
            Modal._resolve = resolve;
        });
    },
    
    // ì•Œë¦¼ ëª¨ë‹¬
    alert({ title = 'ì•Œë¦¼', message }) {
        return new Promise((resolve) => {
            const id = 'alertModal_' + Date.now();
            
            this.create({
                id,
                title,
                body: `<p style="margin:0;color:#333;">${message}</p>`,
                footer: `
                    <button class="modal-btn primary" onclick="Modal.close('${id}'); Modal._alertResolve();" style="padding:8px 16px;border:none;background:var(--retro-teal, #2a9d8f);color:white;border-radius:6px;cursor:pointer;">í™•ì¸</button>
                `,
                width: '300px',
                onClose: () => resolve()
            });
            
            Modal._alertResolve = resolve;
        });
    },
    
    // ì…ë ¥ ëª¨ë‹¬
    prompt({ title = 'ì…ë ¥', message = '', defaultValue = '', placeholder = '' }) {
        return new Promise((resolve) => {
            const id = 'promptModal_' + Date.now();
            
            this.create({
                id,
                title,
                body: `
                    ${message ? `<p style="margin:0 0 10px;color:#333;">${message}</p>` : ''}
                    <input type="text" id="${id}_input" value="${defaultValue}" placeholder="${placeholder}" style="width:100%;padding:10px;border:1px solid #ddd;border-radius:6px;font-size:14px;box-sizing:border-box;">
                `,
                footer: `
                    <button class="modal-btn cancel" onclick="Modal.close('${id}'); Modal._promptResolve(null);" style="padding:8px 16px;border:1px solid #ddd;background:white;border-radius:6px;cursor:pointer;">ì·¨ì†Œ</button>
                    <button class="modal-btn primary" onclick="Modal._promptSubmit('${id}');" style="padding:8px 16px;border:none;background:var(--retro-teal, #2a9d8f);color:white;border-radius:6px;cursor:pointer;">í™•ì¸</button>
                `,
                width: '350px',
                onClose: () => resolve(null)
            });
            
            Modal._promptResolve = resolve;
            
            // ì…ë ¥ í•„ë“œ í¬ì»¤ìŠ¤ ë° ì—”í„°í‚¤ ì²˜ë¦¬
            setTimeout(() => {
                const input = document.getElementById(`${id}_input`);
                if (input) {
                    input.focus();
                    input.select();
                    input.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            Modal._promptSubmit(id);
                        }
                    };
                }
            }, 100);
        });
    },
    
    _promptSubmit(id) {
        const input = document.getElementById(`${id}_input`);
        const value = input ? input.value : '';
        Modal.close(id);
        Modal._promptResolve(value);
    }
};

/**
 * ì„¤ì • ìƒìˆ˜ - ì•± ì „ì²´ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì„¤ì •ê°’
 */
const Config = {
    // í˜ì´ì§•
    PAGE_SIZE: 100,
    CHUNK_ROWS: 100,
    
    // ì„±ëŠ¥
    MAX_UNDO: 30,
    MIN_RENDER_INTERVAL: 50,
    MAX_FOLDER_HISTORY: 50,
    
    // íŒŒì¼
    MAX_FILE_SIZE: 100 * 1024 * 1024, // 100MB
    SUPPORTED_SHEET_EXTENSIONS: ['xlsx', 'xls', 'csv', 'tsv'],
    SUPPORTED_FILE_EXTENSIONS: ['pdf', 'pptx', 'ppt', 'docx', 'doc', 'txt', 'html', 'htm'],
    
    // ê²€ìƒ‰
    SEARCH_DELAY: 300,
    MAX_SEARCH_RESULTS: 1000,
    
    // UI
    DEFAULT_COL_WIDTH: 120,
    DEFAULT_ROW_HEIGHT: 26,
    TOAST_DURATION: 2000,
    RESIZE_ZONE: 8,
    
    // ê·¸ë£¹ ë³‘í•©
    MAX_GROUP_DISPLAY: 10
};

/**
 * DOM ìºì‹œ - ìì£¼ ì ‘ê·¼í•˜ëŠ” DOM ìš”ì†Œ ìºì‹±
 */
const DOM = {
    _cache: {},
    
    // Getterë¡œ ì§€ì—° ì´ˆê¸°í™”
    get spreadsheet() { return this._get('spreadsheet'); },
    get sheetGrid() { return this._get('sheetGrid'); },
    get toast() { return this._get('toast'); },
    get loading() { return this._get('loadingOverlay'); },
    get loadingText() { return this._get('loadingText'); },
    get formulaInput() { return this._get('formulaInput'); },
    get searchInput() { return this._get('mainSearchInput'); },
    get folderBreadcrumb() { return this._get('folderBreadcrumb'); },
    get folderBackBtn() { return this._get('folderBackBtn'); },
    get folderForwardBtn() { return this._get('folderForwardBtn'); },
    get currentSheetName() { return this._get('currentSheetName'); },
    get sheetCountBadge() { return this._get('sheetCountBadge'); },
    get sheetsContainer() { return this._get('sheetsContainer'); },
    get filesContainer() { return this._get('fileStorageContainer'); },
    
    // ìºì‹œì—ì„œ ê°€ì ¸ì˜¤ê¸° (ì—†ìœ¼ë©´ ì¡°íšŒ í›„ ìºì‹±)
    _get(id) {
        if (!this._cache[id]) {
            this._cache[id] = document.getElementById(id);
        }
        return this._cache[id];
    },
    
    // ìºì‹œ ì´ˆê¸°í™” (í™”ë©´ ì „í™˜ ì‹œ)
    clear() {
        this._cache = {};
    },
    
    // íŠ¹ì • ìš”ì†Œë§Œ ìºì‹œì—ì„œ ì œê±°
    invalidate(id) {
        delete this._cache[id];
    }
};

/**
 * ì•¡ì…˜ ë§µ - ê³µí†µ ì•¡ì…˜ì„ ì¤‘ì•™ì—ì„œ ê´€ë¦¬
 */
const Actions = {
    // ì‹œíŠ¸ ê´€ë ¨
    'sheet:open': (name) => typeof openSheet === 'function' && openSheet(name),
    'sheet:delete': (name) => typeof deleteSheet === 'function' && deleteSheet(name),
    'sheet:rename': (name) => typeof startRenameSheet === 'function' && startRenameSheet(name),
    'sheet:favorite': (name) => typeof toggleFavorite === 'function' && toggleFavorite(name),
    'sheet:download': (name) => typeof downloadCurrentSheet === 'function' && downloadCurrentSheet(name),
    
    // í´ë” ê´€ë ¨
    'folder:create': () => typeof createNewFolder === 'function' && createNewFolder(),
    'folder:delete': (id) => typeof deleteFolder === 'function' && deleteFolder(id),
    'folder:rename': (id) => typeof startRenameFolder === 'function' && startRenameFolder(id),
    'folder:navigate': (id) => typeof navigateToFolder === 'function' && navigateToFolder(id),
    'folder:back': () => typeof folderGoBack === 'function' && folderGoBack(),
    'folder:forward': () => typeof folderGoForward === 'function' && folderGoForward(),
    
    // íŒŒì¼ ê´€ë ¨
    'file:open': (id) => typeof showFileViewer === 'function' && showFileViewer(id),
    'file:delete': (idx) => typeof deleteStoredFile === 'function' && deleteStoredFile(idx),
    'file:download': (idx) => typeof downloadStoredFile === 'function' && downloadStoredFile(idx),
    
    // ë„¤ë¹„ê²Œì´ì…˜
    'nav:sheets': () => typeof switchMainTab === 'function' && switchMainTab('sheets'),
    'nav:files': () => typeof switchMainTab === 'function' && switchMainTab('files'),
    
    // ì‹¤í–‰
    dispatch(action, param) {
        const handler = this[action];
        if (typeof handler === 'function') {
            handler(param);
        } else {
            console.warn('Unknown action:', action);
        }
    }
};

// ì „ì—­ ì´ë²¤íŠ¸ ìœ„ì„ (data-action ì†ì„± ì²˜ë¦¬)
document.addEventListener('click', (e) => {
    const actionEl = e.target.closest('[data-action]');
    if (actionEl) {
        const action = actionEl.dataset.action;
        const param = actionEl.dataset.name || actionEl.dataset.id || actionEl.dataset.param;
        Actions.dispatch(action, param);
    }
});

// ===== ì „ì—­ ë³€ìˆ˜ =====
let WB = {};
let SHEET = '';
let SELECTED = null;
let SELECTION_START = null; // ë²”ìœ„ ì„ íƒ ì‹œì‘ì 
let SELECTION_END = null; // ë²”ìœ„ ì„ íƒ ëì 
let EDITING = false;
let CLIPBOARD = null;
let PAGE_SIZE = 100; // ëŒ€ìš©ëŸ‰ íŒŒì¼ ì§€ì›ì„ ìœ„í•´ 100ìœ¼ë¡œ ì¦ê°€
let CURRENT_PAGE = 0;
let NEW_ENTRY_MODE = false;
let COPY_MODE = false; // ë³µì‚¬ ëª¨ë“œ
let COL_ORDER = {}; // ì‹œíŠ¸ë³„ ì—´ í‘œì‹œ ìˆœì„œ
let HIDDEN_COLS = {}; // ì‹œíŠ¸ë³„ ìˆ¨ê¸´ ì—´
let UNDO_STACK = []; // ì‹¤í–‰ ì·¨ì†Œ ìŠ¤íƒ
let REDO_STACK = []; // ë‹¤ì‹œ ì‹¤í–‰ ìŠ¤íƒ
const MAX_UNDO = 30; // ëŒ€ìš©ëŸ‰ íŒŒì¼ ì§€ì›ì„ ìœ„í•´ 30ìœ¼ë¡œ ê°ì†Œ (ë©”ëª¨ë¦¬ ì ˆì•½)
let PENDING_CHANGES = []; // ë³€ê²½ ì˜ì‹¬ ê±´
let PENDING_ADDITIONS = []; // ì‹ ê·œ ì¶”ê°€ ê±´
let PENDING_NEW_SHEETS = []; // ìƒˆ ì‹œíŠ¸ ê±´
let PENDING_ERRORS = []; // ì˜¤ë¥˜ ê±´
let currentReviewTab = 'additions'; // í˜„ì¬ ë¦¬ë·° íƒ­
let favoriteSheets = new Set(); // ì¦ê²¨ì°¾ê¸° ì‹œíŠ¸
let newSheets = new Set(); // NEW ë°°ì§€ í‘œì‹œí•  ì‹œíŠ¸ (ë³‘í•© í›„ ìƒˆ ë°ì´í„° ì¶”ê°€ëœ ì‹œíŠ¸)
let showFavoritesOnly = false; // ì¦ê²¨ì°¾ê¸°ë§Œ ë³´ê¸°
let renderRequestId = null; // ë Œë”ë§ ìš”ì²­ ID (ì¤‘ë³µ ë°©ì§€)
let lastRenderTime = 0; // ë§ˆì§€ë§‰ ë Œë”ë§ ì‹œê°„
const MIN_RENDER_INTERVAL = 50; // ìµœì†Œ ë Œë”ë§ ê°„ê²© (ms)

// ===== ë·° ëª¨ë“œ ìƒìˆ˜ =====
const VIEW_MODE = {
    ICON: 'icon',
    LIST: 'list',
    CARD: 'card',
    TABLE: 'table'
};

let sheetViewMode = VIEW_MODE.ICON; // ì‹œíŠ¸ ë·° ëª¨ë“œ
let folderViewMode = VIEW_MODE.ICON; // í´ë” ë·° ëª¨ë“œ
let RESIZE_MODE = false; // ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œ
let currentViewerFile = null; // íŒŒì¼ ë·°ì–´ í˜„ì¬ íŒŒì¼

// ===== í´ë” ì‹œìŠ¤í…œ =====
let sheetFolders = {}; // { folderId: { name, parentId, createdAt } }
let sheetToFolder = {}; // { sheetName: folderId }
let currentFolderId = null; // í˜„ì¬ ë³´ê³ ìˆëŠ” í´ë” (null = ë£¨íŠ¸)
let folderDragItem = null; // ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ

// ===== í´ë” íˆìŠ¤í† ë¦¬ (ë’¤ë¡œ/ì•ìœ¼ë¡œ) =====
let folderHistory = [null]; // ë°©ë¬¸ ê¸°ë¡ (null = ë£¨íŠ¸)
let folderHistoryIndex = 0; // í˜„ì¬ ìœ„ì¹˜
const MAX_FOLDER_HISTORY = 50; // ìµœëŒ€ ê¸°ë¡ ìˆ˜

// ===== ì•„ì´ì½˜ ììœ  ë°°ì¹˜ ì‹œìŠ¤í…œ =====
let sheetIconPositions = {}; // { sheetName: { x, y } } ì‹œíŠ¸ ì•„ì´ì½˜ ìœ„ì¹˜
let folderIconPositions = {}; // { folderId: { x, y } } ì‹œíŠ¸ í´ë” ì•„ì´ì½˜ ìœ„ì¹˜
let fileIconPositions = {}; // { fileId: { x, y } } íŒŒì¼ ì•„ì´ì½˜ ìœ„ì¹˜
let fileFolderIconPositions = {}; // { folderId: { x, y } } íŒŒì¼ í´ë” ì•„ì´ì½˜ ìœ„ì¹˜
let freePositionMode = true; // ììœ  ë°°ì¹˜ ëª¨ë“œ í™œì„±í™” ì—¬ë¶€
let positionDragState = null; // ìœ„ì¹˜ ë“œë˜ê·¸ ìƒíƒœ { element, startX, startY, offsetX, offsetY }

// DOM ìš”ì†Œ ìºì‹œ (ì„±ëŠ¥ ìµœì í™”) - ê¸°ì¡´ í˜¸í™˜ì„± ìœ ì§€
let DOM_CACHE = {};

function getDOM(id) {
    // ìƒˆ DOM ê°ì²´ ì‚¬ìš© (ê¸°ì¡´ í•¨ìˆ˜ í˜¸í™˜ì„± ìœ ì§€)
    return DOM._get(id);
}

// DOM ìºì‹œ ì´ˆê¸°í™” (í™”ë©´ ì „í™˜ ì‹œ)
function clearDOMCache() {
    DOM.clear();
    DOM_CACHE = {};
}

document.addEventListener('DOMContentLoaded', () => {
    // Firebase ì´ˆê¸°í™”
    if (!initFirebase()) {
        console.error('Firebase ì´ˆê¸°í™” ì‹¤íŒ¨ - ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì‹¤í–‰');
    }
    console.log('ì—‘ì…€ë§ˆìŠ¤í„° ë¡œë”©...');
    
    // ê¸€ì í¬ê¸° ë¡œë“œ
    loadFontSizeFromStorage();
    const fontSizeDisplay = document.getElementById('fontSizeDisplay');
    if (fontSizeDisplay) {
        fontSizeDisplay.textContent = currentFontSize + '%';
    }
    
    // ë©”ì¸ í™”ë©´ íŒŒì¼ ì…ë ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    const mainFileInput = document.getElementById('mainFileInput');
    if (mainFileInput) {
        mainFileInput.addEventListener('change', (e) => {
            handleDocumentUpload(e);
        });
    }
    
    // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸ ì„¤ì •
    setupDragAndDrop();

    // ì›ë³¸ íŒŒì¼ ë¡œë“œ ë° ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„¤ì •
    loadRawFilesFromLocalStorage();
    loadRawFileFolders();
    setupRawFilesDragDrop();
});

// ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„¤ì •
function setupDragAndDrop() {
    const dropOverlay = document.getElementById('dropOverlay');
    if (!dropOverlay) {
        console.warn('dropOverlay ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    let dragCounter = 0;
    
    // ì „ì²´ í™”ë©´ì— ë“œë˜ê·¸ ì´ë²¤íŠ¸ (ì™¸ë¶€ íŒŒì¼ ë“œë¡­ìš©)
    document.addEventListener('dragenter', (e) => {
        // ë‚´ë¶€ ë“œë˜ê·¸(ì‹œíŠ¸/íŒŒì¼ ì¹´ë“œ)ì¸ ê²½ìš° ë¬´ì‹œ
        if (e.dataTransfer.types.includes('text/plain')) {
            return; // ë‚´ë¶€ ë“œë˜ê·¸ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
        }
        e.preventDefault();
        dragCounter++;
        if (e.dataTransfer.types.includes('Files')) {
            dropOverlay.classList.add('active');
        }
    });
    
    document.addEventListener('dragleave', (e) => {
        // ë‚´ë¶€ ë“œë˜ê·¸ì¸ ê²½ìš° ë¬´ì‹œ
        if (e.dataTransfer.types.includes('text/plain')) {
            return;
        }
        e.preventDefault();
        dragCounter--;
        if (dragCounter === 0) {
            dropOverlay.classList.remove('active');
        }
    });
    
    document.addEventListener('dragover', (e) => {
        // ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ í•­ìƒ preventDefault í˜¸ì¶œí•´ì•¼ ë“œë¡­ ê°€ëŠ¥
        e.preventDefault();
    });
    
    document.addEventListener('drop', (e) => {
        
        // í´ë” ì¹´ë“œë‚˜ ë¸Œë ˆë“œí¬ëŸ¼ ìœ„ì— ë“œë¡­ëœ ê²½ìš°ëŠ” í•´ë‹¹ ìš”ì†Œì˜ ondropì—ì„œ ì²˜ë¦¬í•˜ë„ë¡ ë¬´ì‹œ
        const dropTarget = e.target.closest('.folder-card, .folder-item, .folder-breadcrumb-item');
        if (dropTarget) {
            return; // í´ë” ìš”ì†Œì˜ ondropì—ì„œ ì²˜ë¦¬
        }
        
        // ë‚´ë¶€ ë“œë˜ê·¸(ì‹œíŠ¸/íŒŒì¼ ì¹´ë“œ ì´ë™)ì¸ ê²½ìš° ë¬´ì‹œ - ë¹ˆ ê³µê°„ì— ë“œë¡­ëœ ê²½ìš°
        if (e.dataTransfer.types.includes('text/plain')) {
            dragCounter = 0;
            dropOverlay.classList.remove('active');
            return;
        }
        
        e.preventDefault();
        dragCounter = 0;
        dropOverlay.classList.remove('active');
        
        // ì™¸ë¶€ì—ì„œ íŒŒì¼ì„ ë“œë¡­í•œ ê²½ìš°ë§Œ ì²˜ë¦¬
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleDroppedFiles(files);
        }
    });
    
    // ì˜¤ë²„ë ˆì´ í´ë¦­ ì‹œ ë‹«ê¸°
    dropOverlay.addEventListener('click', () => {
        dropOverlay.classList.remove('active');
        dragCounter = 0;
    });
}

// ë“œë¡­ëœ íŒŒì¼ ì²˜ë¦¬
function handleDroppedFiles(files) {
    const supportedExts = ['xlsx', 'xls', 'csv', 'tsv', 'txt', 'pdf', 'pptx', 'ppt', 'docx', 'doc', 'html', 'htm'];

    for (const file of files) {
        const ext = file.name.split('.').pop().toLowerCase();

        if (!supportedExts.includes(ext)) {
            toast(`ì§€ì›í•˜ì§€ ì•ŠëŠ” í˜•ì‹: ${file.name}`);
            continue;
        }

        // ì›ë³¸ íŒŒì¼ íƒ­ì—ì„œ ë“œë¡­í•œ ê²½ìš° â†’ ì›ë³¸ íŒŒì¼ë¡œ ì²˜ë¦¬
        if (currentMainTab === 'rawfiles') {
            if (['xlsx', 'xls', 'csv'].includes(ext)) {
                const input = document.getElementById('rawFileInput');
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                input.files = dataTransfer.files;
                handleRawFileUpload({ target: input });
            } else {
                toast('ì›ë³¸ íŒŒì¼ì€ ì—‘ì…€(.xlsx, .xls, .csv)ë§Œ ì§€ì›í•©ë‹ˆë‹¤');
            }
            continue;
        }

        // Excel/CSV íŒŒì¼ì€ ë°”ë¡œ ì‹œíŠ¸ë¡œ ì—´ê¸° â†’ ì‹œíŠ¸ ëª©ë¡ íƒ­ìœ¼ë¡œ ì „í™˜
        if (['xlsx', 'xls', 'csv', 'tsv'].includes(ext)) {
            switchMainTab('sheets'); // ì‹œíŠ¸ ëª©ë¡ íƒ­ìœ¼ë¡œ ì „í™˜
            handleMainUploadOriginal(file);
        }
        // ë¬¸ì„œ íŒŒì¼(PDF, PPT, DOCX, TXT, HTML)ì€ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
        else {
            showUploadChoiceModal(file);
        }
    }
}

// ë¬¸ì„œ íŒŒì¼ì„ ì‹œíŠ¸ë¡œ ë³€í™˜ (ì„œë²„ ì—…ë¡œë“œ ì—†ì´)
async function convertDocumentToSheet(file) {
    showLoading('íŒŒì¼ ë³€í™˜ ì¤‘...');
    try {
        await convertFileToSheet(file);
        hideLoading();
        renderMainScreen();
        toast(`'${file.name}' ì‹œíŠ¸ë¡œ ë³€í™˜ ì™„ë£Œ!`);
    } catch (error) {
        hideLoading();
        console.error('ë³€í™˜ ì˜¤ë¥˜:', error);
        toast('íŒŒì¼ ë³€í™˜ ì‹¤íŒ¨: ' + error.message);
    }
}

// ===== renderMainScreen í—¬í¼ í•¨ìˆ˜ë“¤ =====

// ì‹œíŠ¸ ë°ì´í„° í•„í„°ë§ ë° ì •ë ¬
function prepareSheetData() {
    const names = Object.keys(WB);
    const allNonEmptySheets = names.filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
    let nonEmptySheets = [...allNonEmptySheets];

    // í˜„ì¬ í´ë”ì— í•´ë‹¹í•˜ëŠ” ì‹œíŠ¸ë§Œ í•„í„°ë§
    if (currentFolderId !== null) {
        nonEmptySheets = nonEmptySheets.filter(n => sheetToFolder[n] === currentFolderId);
    } else {
        nonEmptySheets = nonEmptySheets.filter(n => !sheetToFolder[n]);
    }

    // ì¦ê²¨ì°¾ê¸°ë§Œ ë³´ê¸° í•„í„°
    if (showFavoritesOnly) {
        nonEmptySheets = nonEmptySheets.filter(n => favoriteSheets.has(n));
    }

    // ì¦ê²¨ì°¾ê¸° ë¨¼ì € ì •ë ¬
    nonEmptySheets.sort((a, b) => {
        const aFav = favoriteSheets.has(a) ? 0 : 1;
        const bFav = favoriteSheets.has(b) ? 0 : 1;
        return aFav - bFav;
    });

    return { allNonEmptySheets, nonEmptySheets };
}

// ë·° ëª¨ë“œ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
function updateViewModeButtons() {
    const cardViewBtn = document.getElementById('cardViewBtn');
    const listViewModeBtn = document.getElementById('listViewModeBtn');
    const iconViewBtn = document.getElementById('iconViewBtn');
    if (cardViewBtn && listViewModeBtn && iconViewBtn) {
        cardViewBtn.classList.toggle('active', sheetViewMode === VIEW_MODE.CARD);
        listViewModeBtn.classList.toggle('active', sheetViewMode === VIEW_MODE.LIST);
        iconViewBtn.classList.toggle('active', sheetViewMode === VIEW_MODE.ICON);
    }
}

// ë·° ëª¨ë“œ í´ë˜ìŠ¤ ì ìš©
function applyViewModeClasses(grid) {
    grid.classList.remove('list-view', 'icon-view', 'free-position');
    if (sheetViewMode === VIEW_MODE.LIST) {
        grid.classList.add('list-view');
    } else if (sheetViewMode === VIEW_MODE.ICON) {
        grid.classList.add('icon-view');
        if (freePositionMode) {
            grid.classList.add('free-position');
        }
    }
}

// ëª¨ë“œ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì‚­ì œ, ë‹¤ìš´ë¡œë“œ, ì¦ê²¨ì°¾ê¸°)
function updateModeButtons() {
    // ì‚­ì œ ëª¨ë“œ
    const deleteModeBtn = document.getElementById('deleteModeBtn');
    if (deleteModeBtn) {
        deleteModeBtn.classList.toggle('active', deleteMode);
        deleteModeBtn.textContent = deleteMode ? 'ì·¨ì†Œ' : 'ì‚­ì œ';
    }

    // ë‹¤ìš´ë¡œë“œ ëª¨ë“œ
    const downloadModeBtn = document.getElementById('downloadModeBtn');
    const downloadActions = document.getElementById('downloadActions');
    if (downloadModeBtn) {
        downloadModeBtn.classList.toggle('active', downloadMode);
        downloadModeBtn.textContent = downloadMode ? 'ì·¨ì†Œ' : 'ë‹¤ìš´ë¡œë“œ';
        if (downloadActions) {
            downloadActions.classList.toggle('show', downloadMode);
        }
        if (downloadMode) updateDownloadSelectedCount();
    }

    // ì¦ê²¨ì°¾ê¸° ëª¨ë“œ
    const favoriteModeBtn = document.getElementById('favoriteModeBtn');
    if (favoriteModeBtn) {
        favoriteModeBtn.classList.toggle('active', favoriteMode);
        favoriteModeBtn.textContent = favoriteMode ? 'ì™„ë£Œ' : 'ì¦ê²¨ì°¾ê¸°';
    }
}

// ê·¸ë¦¬ë“œ ëª¨ë“œ ìƒíƒœ ì ìš©
function applyGridModeClasses(grid) {
    grid.classList.toggle('download-mode', downloadMode);
    grid.classList.toggle('delete-mode', deleteMode);
    grid.classList.toggle('favorite-mode', favoriteMode);
}

// ë¹ˆ ìƒíƒœ HTML ìƒì„±
function renderEmptyState() {
    if (currentFolderId !== null) {
        return `
            <div class="empty-state" style="grid-column: 1/-1;">
                <div class="empty-state-text">ì´ í´ë”ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</div>
                <button class="main-btn" onclick="navigateToFolder(null)">â† ì „ì²´ë¡œ ëŒì•„ê°€ê¸°</button>
            </div>`;
    }
    return `
        <div class="empty-state" style="grid-column: 1/-1;">
            <div class="empty-state-text">ë°ì´í„°ê°€ ìˆëŠ” ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤</div>
            <button class="main-btn primary" onclick="document.getElementById('mainFileInput').click()">íŒŒì¼ ì—´ê¸°</button>
        </div>`;
}

// í´ë” ì¹´ë“œ HTML ìƒì„±
function renderFolderCardHtml(folder, sheetAutoIndex, iconLayout) {
    const sheetCount = Object.values(sheetToFolder).filter(fid => fid === folder.id).length;
    const safeFolderId = folder.id.replace(/'/g, "\\'");
    const safeFolderName = folder.name.replace(/'/g, "\\'");

    const commonAttrs = `data-folder="${escHtml(folder.id)}"
        ondblclick="navigateToFolder('${safeFolderId}')"
        ondragover="handleFolderDragOver(event)"
        ondragleave="handleFolderDragLeave(event)"
        ondrop="handleFolderDrop(event, '${safeFolderId}')"
        oncontextmenu="showFolderContextMenu(event, '${safeFolderId}', '${safeFolderName}')"`;

    if (sheetViewMode === VIEW_MODE.LIST) {
        return `
            <div class="folder-card" ${commonAttrs}>
                <div class="folder-card-icon">ğŸ“</div>
                <div class="folder-card-name" id="folderName_${escHtml(folder.id)}" ondblclick="event.stopPropagation(); startRenameFolderCard('${safeFolderId}')">${escHtml(folder.name)}</div>
                <div class="folder-card-count">${sheetCount}ê°œ ì‹œíŠ¸</div>
                <button class="folder-card-delete" onclick="event.stopPropagation(); confirmDeleteFolder('${safeFolderId}')" title="í´ë” ì‚­ì œ">&times;</button>
            </div>`;
    } else if (sheetViewMode === VIEW_MODE.ICON) {
        const folderPos = folderIconPositions[folder.id] || {};
        let folderStyle = '';
        if (freePositionMode) {
            if (folderPos.x !== undefined) {
                folderStyle = `style="left:${folderPos.x}px;top:${folderPos.y}px;"`;
            } else {
                const autoX = (sheetAutoIndex % iconLayout.cols) * iconLayout.width + 10;
                const autoY = Math.floor(sheetAutoIndex / iconLayout.cols) * iconLayout.height + 10;
                folderStyle = `style="left:${autoX}px;top:${autoY}px;"`;
            }
        }
        return `
            <div class="folder-card" ${commonAttrs} ${folderStyle}
                 onmousedown="startPositionDrag(event, 'folder', '${safeFolderId}')">
                <div class="folder-card-icon">ğŸ“</div>
                <div class="folder-card-name">${escHtml(folder.name)}</div>
            </div>`;
    } else {
        // ì¹´ë“œ ë·°
        return `
            <div class="folder-card" ${commonAttrs}>
                <div class="folder-card-icon">ğŸ“</div>
                <div class="folder-card-name" id="folderName_${escHtml(folder.id)}" ondblclick="event.stopPropagation(); startRenameFolderCard('${safeFolderId}')">${escHtml(folder.name)}</div>
                <div class="folder-card-count">${sheetCount}ê°œ</div>
                <button class="folder-card-delete" onclick="event.stopPropagation(); confirmDeleteFolder('${safeFolderId}')" title="í´ë” ì‚­ì œ">&times;</button>
            </div>`;
    }
}

// ì‹œíŠ¸ ì¹´ë“œ HTML ìƒì„±
function renderSheetCardHtml(name, sheetAutoIndex, iconLayout) {
    const sheet = WB[name];
    const safeName = name.replace(/'/g, "\\'");
    const isSelected = selectedSheets.has(name);
    const isFavorite = favoriteSheets.has(name);
    const isMultiSelected = multiSelectedSheets && multiSelectedSheets.has(name);
    const isNew = newSheets.has(name);

    const commonClass = `sheet-card${isSelected ? ' selected' : ''}${isFavorite ? ' is-favorite' : ''}${isMultiSelected ? ' multi-selected' : ''}`;
    const commonAttrs = `data-sheet="${escHtml(name)}" draggable="true"
        ondragstart="handleSheetDragStart(event, '${safeName}')"
        ondragend="handleSheetDragEnd(event)"
        oncontextmenu="showSheetCardContextMenu(event, '${safeName}'); return false;"`;

    if (sheetViewMode === VIEW_MODE.LIST) {
        const colPreview = sheet.headers.slice(0, 8).join(', ') + (sheet.headers.length > 8 ? '...' : '');
        return `
            <div class="${commonClass}" ${commonAttrs}
                 onclick="if(toggleMultiSelect(event, '${safeName}')) return; clearNewBadge('${safeName}')">
                <input type="checkbox" class="sheet-card-checkbox" data-sheet="${escHtml(name)}" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleSheetSelect('${safeName}')">
                ${isFavorite ? '<span class="favorite-badge">â˜…</span>' : ''}
                ${isNew ? '<span class="sheet-card-new">NEW</span>' : ''}
                <div class="sheet-card-header" onclick="handleSheetCardClick('${safeName}')">
                    <div class="sheet-card-name" ondblclick="event.stopPropagation(); startRenameSheetCard(event, '${safeName}')">${escHtml(name)}</div>
                    <div class="sheet-card-count">${sheet.data.length}ê±´</div>
                    <div class="sheet-card-info">${sheet.headers.length}ì—´</div>
                    <div class="sheet-card-cols">${escHtml(colPreview)}</div>
                </div>
                <button class="sheet-card-menu" onclick="event.stopPropagation(); showCardMenu(event, '${safeName}', 'sheet')" title="ë©”ë‰´">â‹®</button>
            </div>`;
    } else if (sheetViewMode === VIEW_MODE.ICON) {
        const sheetPos = sheetIconPositions[name] || {};
        let sheetStyle = '';
        if (freePositionMode) {
            if (sheetPos.x !== undefined) {
                sheetStyle = `style="left:${sheetPos.x}px;top:${sheetPos.y}px;"`;
            } else {
                const autoX = (sheetAutoIndex % iconLayout.cols) * iconLayout.width + 10;
                const autoY = Math.floor(sheetAutoIndex / iconLayout.cols) * iconLayout.height + 10;
                sheetStyle = `style="left:${autoX}px;top:${autoY}px;"`;
            }
        }
        return `
            <div class="sheet-card${isFavorite ? ' is-favorite' : ''}${isMultiSelected ? ' multi-selected' : ''}"
                 ${commonAttrs} ${sheetStyle}
                 onmousedown="startPositionDrag(event, 'sheet', '${safeName}')"
                 onclick="handleSheetCardClick('${safeName}')">
                <span class="sheet-icon-star">â­</span>
                <div class="sheet-card-name">${escHtml(name)}</div>
            </div>`;
    } else {
        // ì¹´ë“œ ë·°
        const colPreview = sheet.headers.slice(0, 5).join(', ') + (sheet.headers.length > 5 ? '...' : '');
        return `
            <div class="${commonClass}" ${commonAttrs}
                 onclick="if(toggleMultiSelect(event, '${safeName}')) return; clearNewBadge('${safeName}')">
                <input type="checkbox" class="sheet-card-checkbox" data-sheet="${escHtml(name)}" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleSheetSelect('${safeName}')">
                ${isFavorite ? '<span class="favorite-badge">â˜…</span>' : ''}
                ${isNew ? '<span class="sheet-card-new">NEW</span>' : ''}
                <button class="sheet-card-menu" onclick="event.stopPropagation(); showCardMenu(event, '${safeName}', 'sheet')" title="ë©”ë‰´">â‹®</button>
                <div onclick="handleSheetCardClick('${safeName}')">
                    <div class="sheet-card-header">
                        <div class="sheet-card-name" ondblclick="event.stopPropagation(); startRenameSheetCard(event, '${safeName}')">${escHtml(name)}</div>
                        <div class="sheet-card-count">${sheet.data.length}ê±´</div>
                    </div>
                    <div class="sheet-card-info">${sheet.headers.length}ê°œ ì—´</div>
                    <div class="sheet-card-cols">${escHtml(colPreview)}</div>
                </div>
            </div>`;
    }
}

function renderMainScreen() {

    // ë§¤ ë Œë”ë§ ì‹œ WBì— ì—†ëŠ” ì‹œíŠ¸ ë§¤í•‘ ì •ë¦¬
    cleanupOrphanedMappings();

    const grid = document.getElementById('sheetGrid');
    if (!grid) {
        console.error('renderMainScreen - sheetGrid ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ!');
        return;
    }

    // ë°ì´í„° ì¤€ë¹„
    const { allNonEmptySheets, nonEmptySheets } = prepareSheetData();

    // ì‹œíŠ¸ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
    const sheetCountBadge = document.getElementById('sheetCountBadge');
    if (sheetCountBadge) {
        sheetCountBadge.textContent = showFavoritesOnly
            ? `${nonEmptySheets.length}ê°œ (ì¦ê²¨ì°¾ê¸°)`
            : `${allNonEmptySheets.length}ê°œ`;
    }

    // UI ìƒíƒœ ì—…ë°ì´íŠ¸
    updateFolderBreadcrumb();
    updateViewModeButtons();
    applyViewModeClasses(grid);
    updateModeButtons();

    // ì‹ ê·œ ì¶”ê°€ ê±´ ë Œë”ë§
    renderPendingAdditions();

    // ë³€ê²½ ì˜ì‹¬ ê±´ ë Œë”ë§
    renderPendingChanges();

    // ê²€ìƒ‰ ê²°ê³¼ëŠ” ìœ ì§€ (ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ)

    // íŒŒì¼ ê·¸ë£¹ ë·° ëª¨ë“œì¼ ë•Œ (ì „ì²´ ì‹œíŠ¸ ëŒ€ìƒ)
    let useGroupedView = false;
    if (fileGroupViewMode === 'grouped' && currentFolderId === null && !showFavoritesOnly) {
        const groupedHtml = renderFileGroupedView(allNonEmptySheets);
        if (groupedHtml !== null) {
            grid.innerHTML = groupedHtml;
            useGroupedView = true;
        }
    }

    // í”Œë« ë·° (ê¸°ì¡´ í´ë” ë·°)
    if (!useGroupedView) {
        // í˜„ì¬ í´ë”ì˜ í•˜ìœ„ í´ë”ë“¤ ê°€ì ¸ì˜¤ê¸°
        const childFolders = Object.entries(sheetFolders)
            .filter(([id, folder]) => folder.parentId === currentFolderId)
            .map(([id, folder]) => ({ id, ...folder }));

        // í´ë”ì™€ ì‹œíŠ¸ê°€ ëª¨ë‘ ì—†ìœ¼ë©´ ë¹ˆ ìƒíƒœ í‘œì‹œ
        if (nonEmptySheets.length === 0 && childFolders.length === 0) {
            grid.innerHTML = renderEmptyState();
            // ëª¨ë“œ ìƒíƒœ ì ìš©
            applyGridModeClasses(grid);
            return;
        }

        // ì•„ì´ì½˜ ë·° ë ˆì´ì•„ì›ƒ ì„¤ì •
        const iconLayout = { width: 90, height: 95, cols: 8 };
        let autoIndex = 0;
        let html = '';

        // í´ë” ë¨¼ì € ë Œë”ë§
        for (const folder of childFolders) {
            html += renderFolderCardHtml(folder, autoIndex, iconLayout);
            autoIndex++;
        }

        // ì‹œíŠ¸ ë Œë”ë§
        for (const name of nonEmptySheets) {
            html += renderSheetCardHtml(name, autoIndex, iconLayout);
            autoIndex++;
        }

        grid.innerHTML = html;
    }

    // ëª¨ë“œ ìƒíƒœ ì ìš©
    applyGridModeClasses(grid);

    // ë“œë˜ê·¸ ì„ íƒ ì´ˆê¸°í™”
    initDragSelect();

    // ë©”ì¸ í™”ë©´ í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì´ˆê¸°í™”
    setupMainScreenKeyboard();

    // ìë™ ì €ì¥ (ë””ë°”ìš´ìŠ¤)
    debouncedSaveToLocalStorage();
}

// íŒŒì¼ ê·¸ë£¹ë³„ ë·° ë Œë”ë§
function renderFileGroupedView(allSheets) {
    const iconLayout = { width: 90, height: 95, cols: 8 };
    let html = '';

    // íŒŒì¼ ê·¸ë£¹ë“¤ ì •ë ¬ (ìµœì‹  ì—…ë¡œë“œ ìˆœ)
    const sortedGroups = Object.entries(fileGroups)
        .filter(([id, group]) => group && group.sheets && group.sheets.length > 0)
        .map(([id, group]) => ({ id, ...group }))
        .sort((a, b) => (b.uploadedAt || 0) - (a.uploadedAt || 0));

    // íŒŒì¼ ê·¸ë£¹ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ null ë°˜í™˜ (í”Œë« ë·°ë¡œ ì „í™˜)
    if (sortedGroups.length === 0) {
        return null;
    }

    // ë·° ëª¨ë“œ ì „í™˜ ë²„íŠ¼
    html += `
        <div class="file-group-view-toggle">
            <button class="view-toggle-btn ${fileGroupViewMode === 'grouped' ? 'active' : ''}" onclick="fileGroupViewMode='grouped'; renderMainScreen();">ğŸ“ íŒŒì¼ë³„</button>
            <button class="view-toggle-btn ${fileGroupViewMode === 'flat' ? 'active' : ''}" onclick="fileGroupViewMode='flat'; renderMainScreen();">ğŸ“„ ì „ì²´ ì‹œíŠ¸</button>
        </div>
    `;

    // ê·¸ë£¹í™”ëœ ì‹œíŠ¸ë“¤
    const groupedSheetNames = new Set();

    // ê° íŒŒì¼ ê·¸ë£¹ ë Œë”ë§
    for (const group of sortedGroups) {
        // ì‹¤ì œ ì¡´ì¬í•˜ëŠ” ì‹œíŠ¸ë§Œ í•„í„°ë§
        const validSheets = group.sheets.filter(name =>
            WB[name] && WB[name].data && WB[name].data.length > 0 &&
            allSheets.includes(name)
        );

        if (validSheets.length === 0) continue;

        validSheets.forEach(name => groupedSheetNames.add(name));

        const isCollapsed = collapsedFileGroups.has(group.id);
        const totalRows = validSheets.reduce((sum, name) => sum + (WB[name]?.data?.length || 0), 0);

        html += `
            <div class="file-group" data-file-id="${group.id}">
                <div class="file-group-header" onclick="toggleFileGroupCollapse('${group.id}')">
                    <span class="file-group-toggle">${isCollapsed ? 'â–¶' : 'â–¼'}</span>
                    <span class="file-group-icon">ğŸ“</span>
                    <span class="file-group-name">${escHtml(group.name)}</span>
                    <span class="file-group-meta">${validSheets.length}ê°œ ì‹œíŠ¸ Â· ${totalRows}ê±´</span>
                    <div class="file-group-actions" onclick="event.stopPropagation();">
                        <button class="file-group-btn" onclick="downloadFileGroup('${group.id}')" title="ë‹¤ìš´ë¡œë“œ">ğŸ“¥</button>
                        <button class="file-group-btn" onclick="renameFileGroup('${group.id}')" title="ì´ë¦„ë³€ê²½">âœï¸</button>
                        <button class="file-group-btn danger" onclick="deleteFileGroup('${group.id}')" title="ì‚­ì œ">ğŸ—‘ï¸</button>
                    </div>
                </div>
                ${isCollapsed ? '' : `
                    <div class="file-group-sheets">
                        ${validSheets.map((name, idx) => renderSheetCardHtml(name, idx, iconLayout)).join('')}
                    </div>
                `}
            </div>
        `;
    }

    // ë¯¸ë“±ë¡ ì‹œíŠ¸ë“¤ (ê¸°íƒ€)
    const ungroupedSheets = allSheets.filter(name => !groupedSheetNames.has(name));

    if (ungroupedSheets.length > 0) {
        const isCollapsed = collapsedFileGroups.has('__ungrouped__');
        const totalRows = ungroupedSheets.reduce((sum, name) => sum + (WB[name]?.data?.length || 0), 0);

        html += `
            <div class="file-group ungrouped" data-file-id="__ungrouped__">
                <div class="file-group-header" onclick="toggleFileGroupCollapse('__ungrouped__')">
                    <span class="file-group-toggle">${isCollapsed ? 'â–¶' : 'â–¼'}</span>
                    <span class="file-group-icon">ğŸ“‹</span>
                    <span class="file-group-name">ê¸°íƒ€ ì‹œíŠ¸</span>
                    <span class="file-group-meta">${ungroupedSheets.length}ê°œ ì‹œíŠ¸ Â· ${totalRows}ê±´</span>
                </div>
                ${isCollapsed ? '' : `
                    <div class="file-group-sheets">
                        ${ungroupedSheets.map((name, idx) => renderSheetCardHtml(name, idx, iconLayout)).join('')}
                    </div>
                `}
            </div>
        `;
    }

    // ë¹„ì–´ìˆëŠ” ê²½ìš°
    if (sortedGroups.length === 0 && ungroupedSheets.length === 0) {
        html += renderEmptyState();
    }

    return html;
}

function openSheet(name) {
    if (!WB[name]) return;
    SHEET = name;
    CURRENT_PAGE = 0;

    const currentSheetNameEl = document.getElementById('currentSheetName');
    const mainScreenEl = document.getElementById('mainScreen');
    const detailScreenEl = document.getElementById('detailScreen');

    if (currentSheetNameEl) currentSheetNameEl.textContent = SHEET;
    if (mainScreenEl) mainScreenEl.style.display = 'none';
    if (detailScreenEl) detailScreenEl.style.display = 'flex';

    renderSheetTabs();
    renderSpreadsheet();
    updateColManagerBtn();
}

// ë©”ì¸ í™”ë©´ ì‹œíŠ¸ ì¹´ë“œì—ì„œ ì´ë¦„ ë³€ê²½ ì‹œì‘
function startRenameSheetCard(e, sheetName) {
    e.stopPropagation();
    createInlineEdit({
        targetEl: e.target,
        currentValue: sheetName,
        styleStr: 'width:100%;padding:4px 8px;font-size:13px;border:2px solid var(--retro-teal);border-radius:4px;outline:none;box-sizing:border-box;',
        onFinish: (newName) => {
            if (WB[newName]) {
                toast('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‹œíŠ¸ ì´ë¦„ì…ë‹ˆë‹¤');
                renderMainScreen();
            } else {
                renameSheet(sheetName, newName);
            }
        },
        onCancel: () => renderMainScreen()
    });
}

// ì‹œíŠ¸ ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
function handleSheetCardClick(name) {
    if (downloadMode) {
        toggleSheetSelect(name);
    } else if (!deleteMode) {
        openSheet(name);
    }
}

// ë‹¤ìš´ë¡œë“œ ëª¨ë“œ
let downloadMode = false;
let selectedSheets = new Set();

function toggleDownloadMode() {
    // ë‹¤ë¥¸ ëª¨ë“œê°€ ì¼œì ¸ìˆìœ¼ë©´ ë„ê¸°
    if (deleteMode) {
        deleteMode = false;
        const deleteModeBtn = document.getElementById('deleteModeBtn');
        if (deleteModeBtn) {
            deleteModeBtn.classList.remove('active');
            deleteModeBtn.textContent = 'ì‚­ì œ';
        }
        document.getElementById('sheetGrid')?.classList.remove('delete-mode');
    }
    if (favoriteMode) {
        favoriteMode = false;
        const favBtn = document.getElementById('favoriteModeBtn');
        if (favBtn) {
            favBtn.classList.remove('active');
            favBtn.textContent = 'ì¦ê²¨ì°¾ê¸°';
        }
        document.getElementById('sheetGrid')?.classList.remove('favorite-mode');
    }

    downloadMode = !downloadMode;
    const btn = document.getElementById('downloadModeBtn');
    const grid = document.getElementById('sheetGrid');
    const actions = document.getElementById('downloadActions');

    if (downloadMode) {
        if (btn) {
            btn.classList.add('active');
            btn.textContent = 'ì·¨ì†Œ';
        }
        grid?.classList.add('download-mode');
        actions?.classList.add('show');
        selectedSheets.clear();
        updateDownloadSelectedCount();
    } else {
        if (btn) {
            btn.classList.remove('active');
            btn.textContent = 'ë‹¤ìš´ë¡œë“œ';
        }
        grid?.classList.remove('download-mode');
        actions?.classList.remove('show');
        selectedSheets.clear();
        // ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
        document.querySelectorAll('.sheet-card.selected').forEach(card => card.classList.remove('selected'));
        document.querySelectorAll('.sheet-card-checkbox').forEach(cb => cb.checked = false);
        const selectAll = document.getElementById('selectAllSheets');
        if (selectAll) selectAll.checked = false;
    }
}

function toggleSheetSelect(name) {
    const card = document.querySelector(`.sheet-card[data-sheet="${name}"]`);
    const checkbox = card?.querySelector('.sheet-card-checkbox');
    
    if (selectedSheets.has(name)) {
        selectedSheets.delete(name);
        card?.classList.remove('selected');
        if (checkbox) checkbox.checked = false;
    } else {
        selectedSheets.add(name);
        card?.classList.add('selected');
        if (checkbox) checkbox.checked = true;
    }
    
    updateDownloadSelectedCount();
    updateSelectAllCheckbox();
}

function toggleSelectAllSheets() {
    const selectAll = document.getElementById('selectAllSheets');
    const cards = document.querySelectorAll('.sheet-card');
    
    cards.forEach(card => {
        const name = card.dataset.sheet;
        const checkbox = card.querySelector('.sheet-card-checkbox');
        
        if (selectAll.checked) {
            selectedSheets.add(name);
            card.classList.add('selected');
            if (checkbox) checkbox.checked = true;
        } else {
            selectedSheets.delete(name);
            card.classList.remove('selected');
            if (checkbox) checkbox.checked = false;
        }
    });
    
    updateDownloadSelectedCount();
}

function updateSelectAllCheckbox() {
    const cards = document.querySelectorAll('.sheet-card');
    const selectAll = document.getElementById('selectAllSheets');
    
    if (cards.length === 0) {
        selectAll.checked = false;
        return;
    }
    
    selectAll.checked = selectedSheets.size === cards.length;
}

function updateDownloadSelectedCount() {
    const el = document.getElementById('selectedCount');
    if (el) el.textContent = selectedSheets.size + 'ê°œ ì„ íƒ';
}

function executeDownloadSelected() {
    if (selectedSheets.size === 0) {
        toast('ë‹¤ìš´ë¡œë“œí•  ì‹œíŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    
    const wb = XLSX.utils.book_new();
    
    selectedSheets.forEach(name => {
        const sheet = WB[name];
        if (!sheet) return;
        
        const data = [sheet.headers, ...sheet.data];
        const ws = XLSX.utils.aoa_to_sheet(data);
        
        let sheetName = name.substring(0, 31);
        XLSX.utils.book_append_sheet(wb, ws, sheetName);
    });
    
    const fileName = `í™˜ë¶ˆì¥_${selectedSheets.size}ê°œì‹œíŠ¸_${new Date().toISOString().slice(0,10)}.xlsx`;
    XLSX.writeFile(wb, fileName);
    
    toast(`${selectedSheets.size}ê°œ ì‹œíŠ¸ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
    
    // ë‹¤ìš´ë¡œë“œ ëª¨ë“œ ì¢…ë£Œ
    toggleDownloadMode();
}

// ì‹œíŠ¸ ì‚­ì œ ëª¨ë“œ
let deleteMode = false;

// ===== ìŠ¤ë§ˆíŠ¸ ë‹¤ìš´ë¡œë“œ ì‹œìŠ¤í…œ =====
let multiDownloadSelected = { sheets: new Set(), folders: new Set(), files: new Set() };
let downloadOutputType = 'merge'; // 'merge', 'individual', 'structure'

// ë‹¤ìš´ë¡œë“œ ë“œë¡­ë‹¤ìš´ í† ê¸€
function toggleDownloadDropdown() {
    const menu = document.getElementById('downloadDropdownMenu');
    if (!menu) return;
    if (menu.classList.contains('show')) {
        menu.classList.remove('show');
    } else {
        // ë‹¤ë¥¸ ë“œë¡­ë‹¤ìš´ ë‹«ê¸°
        document.querySelectorAll('.download-dropdown-menu.show, .save-dropdown-menu.show').forEach(m => m.classList.remove('show'));
        menu.classList.add('show');
    }
}

// ë“œë¡­ë‹¤ìš´ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
document.addEventListener('click', (e) => {
    if (!e.target.closest('.download-dropdown-wrapper')) {
        document.getElementById('downloadDropdownMenu')?.classList.remove('show');
    }
});

// í˜„ì¬ ì‹œíŠ¸ ë‹¤ìš´ë¡œë“œ (í˜•ì‹ ì„ íƒ ëª¨ë‹¬)
function downloadCurrentSheet() {
    document.getElementById('downloadDropdownMenu')?.classList.remove('show');
    
    if (!SHEET || !WB[SHEET]) {
        toast('ë‹¤ìš´ë¡œë“œí•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    showCurrentSheetExportModal();
}

// í˜„ì¬ ì‹œíŠ¸ ë‚´ë³´ë‚´ê¸° ëª¨ë‹¬ (í˜•ì‹ ì„ íƒ)
function showCurrentSheetExportModal() {
    document.getElementById('downloadDropdownMenu')?.classList.remove('show');
    
    const sheetName = SHEET || Object.keys(WB)[0];
    if (!sheetName || !WB[sheetName]) {
        toast('ë‹¤ìš´ë¡œë“œí•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    const modalHtml = `
        <div class="multi-download-modal" id="currentSheetExportModal" onclick="if(event.target===this) closeCurrentSheetExportModal()">
            <div class="multi-download-content" style="width:400px;">
                <div class="multi-download-header">
                    <h3>'${escHtml(sheetName)}' ë‹¤ìš´ë¡œë“œ</h3>
                    <button class="multi-download-close" onclick="closeCurrentSheetExportModal()">âœ•</button>
                </div>
                <div class="multi-download-body" style="padding:20px;">
                    <div class="multi-download-section-title">íŒŒì¼ í˜•ì‹ ì„ íƒ</div>
                    <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:15px;">
                        <div class="export-format-item" onclick="executeCurrentSheetDownload('xlsx')">
                            <span style="font-size:24px;">ğŸ“Š</span>
                            <div style="font-weight:600;margin-top:5px;">Excel</div>
                            <div style="font-size:11px;color:#888;">.xlsx</div>
                        </div>
                        <div class="export-format-item" onclick="executeCurrentSheetDownload('csv')">
                            <span style="font-size:24px;">ğŸ“„</span>
                            <div style="font-weight:600;margin-top:5px;">CSV</div>
                            <div style="font-size:11px;color:#888;">.csv</div>
                        </div>
                        <div class="export-format-item" onclick="executeCurrentSheetDownload('pdf')">
                            <span style="font-size:24px;">ğŸ“•</span>
                            <div style="font-weight:600;margin-top:5px;">PDF</div>
                            <div style="font-size:11px;color:#888;">.pdf</div>
                        </div>
                        <div class="export-format-item" onclick="executeCurrentSheetDownload('txt')">
                            <span style="font-size:24px;">ğŸ“</span>
                            <div style="font-weight:600;margin-top:5px;">í…ìŠ¤íŠ¸</div>
                            <div style="font-size:11px;color:#888;">.txt</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <style>
            .export-format-item {
                display:flex;flex-direction:column;align-items:center;padding:20px 15px;
                border:2px solid var(--retro-border);border-radius:8px;cursor:pointer;transition:all 0.15s;
                background:white;
            }
            .export-format-item:hover {
                border-color:var(--retro-teal);background:var(--retro-mint);transform:translateY(-2px);
            }
        </style>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeCurrentSheetExportModal() {
    document.getElementById('currentSheetExportModal')?.remove();
}

function executeCurrentSheetDownload(format) {
    const sheetName = SHEET || Object.keys(WB)[0];
    const sheet = WB[sheetName];
    if (!sheet) return;
    
    closeCurrentSheetExportModal();
    
    const data = [sheet.headers, ...sheet.data];
    const fileName = `${sheetName}_${new Date().toISOString().slice(0,10)}`;
    
    switch(format) {
        case 'xlsx':
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(data);
            XLSX.utils.book_append_sheet(wb, ws, sheetName.substring(0,31));
            XLSX.writeFile(wb, fileName + '.xlsx');
            break;
        case 'csv':
            const csvWb = XLSX.utils.book_new();
            const csvWs = XLSX.utils.aoa_to_sheet(data);
            XLSX.utils.book_append_sheet(csvWb, csvWs, 'Sheet1');
            XLSX.writeFile(csvWb, fileName + '.csv', { bookType: 'csv' });
            break;
        case 'pdf':
            exportToPdf(sheet, fileName);
            break;
        case 'txt':
            exportToTxt(sheet, fileName);
            break;
    }
    
    toast(`${format.toUpperCase()} ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
}

// ë‹¤ì¤‘ ì„ íƒ ë‹¤ìš´ë¡œë“œ ëª¨ë‹¬ í‘œì‹œ
function showMultiSelectDownloadModal() {
    document.getElementById('downloadDropdownMenu')?.classList.remove('show');
    
    // ì„ íƒ ì´ˆê¸°í™”
    multiDownloadSelected = { sheets: new Set(), folders: new Set(), files: new Set() };
    downloadOutputType = 'merge';
    
    // ì‹œíŠ¸ ëª©ë¡ ìƒì„±
    const sheetNames = Object.keys(WB);
    const folderNames = Object.keys(sheetFolders || {});
    
    let sheetsHtml = '';
    
    // í´ë” ë¨¼ì € í‘œì‹œ
    folderNames.forEach(folderId => {
        const folder = sheetFolders[folderId];
        if (!folder || folder.parentId) return; // ë£¨íŠ¸ í´ë”ë§Œ
        
        const sheetsInFolder = sheetNames.filter(name => sheetToFolder[name] === folderId);
        const count = sheetsInFolder.length;
        
        sheetsHtml += `
            <div class="multi-download-item folder" data-type="folder" data-id="${folderId}" onclick="toggleMultiDownloadItem(this)">
                <input type="checkbox" onclick="event.stopPropagation()">
                <span class="multi-download-item-icon">ğŸ“</span>
                <span class="multi-download-item-name">${escHtml(folder.name)}</span>
                <span class="multi-download-item-count">${count}ê°œ ì‹œíŠ¸</span>
            </div>
        `;
        
        // í´ë” ë‚´ ì‹œíŠ¸
        sheetsInFolder.forEach(name => {
            sheetsHtml += `
                <div class="multi-download-item" data-type="sheet" data-name="${escHtml(name)}" style="padding-left:35px;" onclick="toggleMultiDownloadItem(this)">
                    <input type="checkbox" onclick="event.stopPropagation()">
                    <span class="multi-download-item-icon">ğŸ“Š</span>
                    <span class="multi-download-item-name">${escHtml(name)}</span>
                    <span class="multi-download-item-count">${WB[name]?.data?.length || 0}í–‰</span>
                </div>
            `;
        });
    });
    
    // í´ë” ì—†ëŠ” ì‹œíŠ¸
    const noFolderSheets = sheetNames.filter(name => !sheetToFolder[name]);
    noFolderSheets.forEach(name => {
        sheetsHtml += `
            <div class="multi-download-item" data-type="sheet" data-name="${escHtml(name)}" onclick="toggleMultiDownloadItem(this)">
                <input type="checkbox" onclick="event.stopPropagation()">
                <span class="multi-download-item-icon">ğŸ“Š</span>
                <span class="multi-download-item-name">${escHtml(name)}</span>
                <span class="multi-download-item-count">${WB[name]?.data?.length || 0}í–‰</span>
            </div>
        `;
    });
    
    // íŒŒì¼ ë³´ê´€í•¨ í•­ëª©
    let filesHtml = '';
    if (fileStorage && fileStorage.length > 0) {
        fileStorage.forEach((file, idx) => {
            filesHtml += `
                <div class="multi-download-item" data-type="file" data-idx="${idx}" onclick="toggleMultiDownloadItem(this)">
                    <input type="checkbox" onclick="event.stopPropagation()">
                    <span class="multi-download-item-icon">${getSmFileIcon(file.type)}</span>
                    <span class="multi-download-item-name">${escHtml(file.name)}</span>
                    <span class="multi-download-item-count">${file.type}</span>
                </div>
            `;
        });
    }
    
    const modalHtml = `
        <div class="multi-download-modal" id="multiDownloadModal" onclick="if(event.target===this) closeMultiDownloadModal()">
            <div class="multi-download-content">
                <div class="multi-download-header">
                    <h3>ë‹¤ìš´ë¡œë“œí•  í•­ëª© ì„ íƒ</h3>
                    <button class="multi-download-close" onclick="closeMultiDownloadModal()">âœ•</button>
                </div>
                <div class="multi-download-body">
                    <div class="multi-download-section">
                        <div class="multi-download-section-title">ğŸ“Š ì‹œíŠ¸ ëª©ë¡</div>
                        <div class="multi-download-select-all">
                            <input type="checkbox" id="selectAllSheetsDownload" onchange="toggleSelectAllDownload('sheets')">
                            <label for="selectAllSheetsDownload">ì „ì²´ ì„ íƒ</label>
                        </div>
                        <div class="multi-download-list" id="multiDownloadSheetList">
                            ${sheetsHtml || '<div style="padding:20px;text-align:center;color:#888;">ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤</div>'}
                        </div>
                    </div>
                    
                    ${filesHtml ? `
                    <div class="multi-download-section">
                        <div class="multi-download-section-title">ğŸ“ íŒŒì¼ ë³´ê´€í•¨</div>
                        <div class="multi-download-select-all">
                            <input type="checkbox" id="selectAllFilesDownload" onchange="toggleSelectAllDownload('files')">
                            <label for="selectAllFilesDownload">ì „ì²´ ì„ íƒ</label>
                        </div>
                        <div class="multi-download-list" id="multiDownloadFileList">
                            ${filesHtml}
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="multi-download-options">
                        <div class="multi-download-options-title">ì¶œë ¥ ë°©ì‹</div>
                        <div class="multi-download-option selected" onclick="selectDownloadOption(this, 'merge')">
                            <input type="radio" name="downloadType" value="merge" checked>
                            <div class="multi-download-option-content">
                                <div class="multi-download-option-title">ğŸ“¦ í•˜ë‚˜ë¡œ ë³‘í•©</div>
                                <div class="multi-download-option-desc">ëª¨ë“  ì‹œíŠ¸ë¥¼ í•˜ë‚˜ì˜ Excel íŒŒì¼ì— íƒ­ìœ¼ë¡œ ì €ì¥</div>
                            </div>
                        </div>
                        <div class="multi-download-option" onclick="selectDownloadOption(this, 'individual')">
                            <input type="radio" name="downloadType" value="individual">
                            <div class="multi-download-option-content">
                                <div class="multi-download-option-title">ğŸ“ ê°œë³„ íŒŒì¼ (ZIP)</div>
                                <div class="multi-download-option-desc">ê°ê°ì˜ íŒŒì¼ë¡œ ì €ì¥ í›„ ZIPìœ¼ë¡œ ì••ì¶•</div>
                            </div>
                        </div>
                        <div class="multi-download-option" onclick="selectDownloadOption(this, 'structure')">
                            <input type="radio" name="downloadType" value="structure">
                            <div class="multi-download-option-content">
                                <div class="multi-download-option-title">ğŸ—‚ï¸ í´ë” êµ¬ì¡° ìœ ì§€ (ZIP)</div>
                                <div class="multi-download-option-desc">í´ë” êµ¬ì¡° ê·¸ëŒ€ë¡œ ZIP ì••ì¶•</div>
                            </div>
                        </div>
                        
                        <div class="multi-download-format" id="mergeFormatSection">
                            <label>ë³‘í•© í˜•ì‹:</label>
                            <select id="multiDownloadFormat">
                                <option value="xlsx">Excel (.xlsx)</option>
                                <option value="csv">CSV (.csv) - ì²« ë²ˆì§¸ ì‹œíŠ¸ë§Œ</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="multi-download-footer">
                    <div class="multi-download-summary" id="multiDownloadSummary">ì„ íƒ: 0ê°œ</div>
                    <div class="multi-download-actions">
                        <button class="multi-download-btn cancel" onclick="closeMultiDownloadModal()">ì·¨ì†Œ</button>
                        <button class="multi-download-btn primary" id="executeMultiDownloadBtn" onclick="executeMultiDownload()" disabled>ë‹¤ìš´ë¡œë“œ</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeMultiDownloadModal() {
    document.getElementById('multiDownloadModal')?.remove();
}

// í•­ëª© ì„ íƒ í† ê¸€
function toggleMultiDownloadItem(el) {
    const checkbox = el.querySelector('input[type="checkbox"]');
    const isChecked = !checkbox.checked;
    checkbox.checked = isChecked;
    
    // datasetì—ì„œ ì‹¤ì œ ê°’ ê°€ì ¸ì˜¤ê¸° (HTML ì´ìŠ¤ì¼€ì´í”„ ë¬¸ì œ ë°©ì§€)
    const type = el.dataset.type;
    const actualId = type === 'sheet' ? el.dataset.name : 
                     type === 'file' ? el.dataset.idx : 
                     el.dataset.id;
    
    if (isChecked) {
        el.classList.add('selected');
        if (type === 'folder') {
            multiDownloadSelected.folders.add(actualId);
            // í´ë” ë‚´ ëª¨ë“  ì‹œíŠ¸ë„ ì„ íƒ
            const sheetsInFolder = Object.keys(WB).filter(name => sheetToFolder[name] === actualId);
            sheetsInFolder.forEach(name => {
                multiDownloadSelected.sheets.add(name);
                const sheetEl = document.querySelector(`.multi-download-item[data-name="${CSS.escape(name)}"]`);
                if (sheetEl) {
                    sheetEl.classList.add('selected');
                    sheetEl.querySelector('input[type="checkbox"]').checked = true;
                }
            });
        } else if (type === 'sheet') {
            multiDownloadSelected.sheets.add(actualId);
        } else if (type === 'file') {
            multiDownloadSelected.files.add(parseInt(actualId));
        }
    } else {
        el.classList.remove('selected');
        if (type === 'folder') {
            multiDownloadSelected.folders.delete(actualId);
            // í´ë” ë‚´ ëª¨ë“  ì‹œíŠ¸ë„ í•´ì œ
            const sheetsInFolder = Object.keys(WB).filter(name => sheetToFolder[name] === actualId);
            sheetsInFolder.forEach(name => {
                multiDownloadSelected.sheets.delete(name);
                const sheetEl = document.querySelector(`.multi-download-item[data-name="${CSS.escape(name)}"]`);
                if (sheetEl) {
                    sheetEl.classList.remove('selected');
                    sheetEl.querySelector('input[type="checkbox"]').checked = false;
                }
            });
        } else if (type === 'sheet') {
            multiDownloadSelected.sheets.delete(actualId);
        } else if (type === 'file') {
            multiDownloadSelected.files.delete(parseInt(actualId));
        }
    }
    
    updateMultiDownloadSummary();
}

// ì „ì²´ ì„ íƒ í† ê¸€
function toggleSelectAllDownload(type) {
    const isChecked = document.getElementById(type === 'sheets' ? 'selectAllSheetsDownload' : 'selectAllFilesDownload').checked;
    const list = document.getElementById(type === 'sheets' ? 'multiDownloadSheetList' : 'multiDownloadFileList');
    
    list.querySelectorAll('.multi-download-item').forEach(el => {
        const itemType = el.dataset.type;
        const checkbox = el.querySelector('input[type="checkbox"]');
        checkbox.checked = isChecked;
        
        if (isChecked) {
            el.classList.add('selected');
            if (itemType === 'sheet') multiDownloadSelected.sheets.add(el.dataset.name);
            else if (itemType === 'folder') multiDownloadSelected.folders.add(el.dataset.id);
            else if (itemType === 'file') multiDownloadSelected.files.add(parseInt(el.dataset.idx));
        } else {
            el.classList.remove('selected');
            if (itemType === 'sheet') multiDownloadSelected.sheets.delete(el.dataset.name);
            else if (itemType === 'folder') multiDownloadSelected.folders.delete(el.dataset.id);
            else if (itemType === 'file') multiDownloadSelected.files.delete(parseInt(el.dataset.idx));
        }
    });
    
    updateMultiDownloadSummary();
}

// ì¶œë ¥ ì˜µì…˜ ì„ íƒ
function selectDownloadOption(el, type) {
    document.querySelectorAll('.multi-download-option').forEach(opt => opt.classList.remove('selected'));
    el.classList.add('selected');
    el.querySelector('input[type="radio"]').checked = true;
    downloadOutputType = type;
    
    // ë³‘í•© í˜•ì‹ ì„¹ì…˜ í‘œì‹œ/ìˆ¨ê¹€
    const mergeSection = document.getElementById('mergeFormatSection');
    if (mergeSection) mergeSection.style.display = type === 'merge' ? 'flex' : 'none';
}

// ì„ íƒ ìš”ì•½ ì—…ë°ì´íŠ¸
function updateMultiDownloadSummary() {
    const sheetCount = multiDownloadSelected.sheets.size;
    const fileCount = multiDownloadSelected.files.size;
    const total = sheetCount + fileCount;
    
    let summary = [];
    if (sheetCount > 0) summary.push(`ì‹œíŠ¸ ${sheetCount}ê°œ`);
    if (fileCount > 0) summary.push(`íŒŒì¼ ${fileCount}ê°œ`);
    
    document.getElementById('multiDownloadSummary').textContent = 
        summary.length > 0 ? `ì„ íƒ: ${summary.join(', ')}` : 'ì„ íƒ: 0ê°œ';
    
    document.getElementById('executeMultiDownloadBtn').disabled = total === 0;
}

// ë‹¤ì¤‘ ë‹¤ìš´ë¡œë“œ ì‹¤í–‰
async function executeMultiDownload() {
    const sheets = Array.from(multiDownloadSelected.sheets);
    const files = Array.from(multiDownloadSelected.files);
    
    if (sheets.length === 0 && files.length === 0) {
        toast('ë‹¤ìš´ë¡œë“œí•  í•­ëª©ì„ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    
    const format = document.getElementById('multiDownloadFormat')?.value || 'xlsx';
    const dateStr = new Date().toISOString().slice(0,10);
    
    closeMultiDownloadModal();
    
    try {
        if (downloadOutputType === 'merge') {
            // í•˜ë‚˜ë¡œ ë³‘í•©
            const wb = XLSX.utils.book_new();
            
            sheets.forEach(name => {
                const sheet = WB[name];
                if (!sheet || !sheet.data) return;
                const data = [sheet.headers || [], ...sheet.data];
                const ws = XLSX.utils.aoa_to_sheet(data);
                XLSX.utils.book_append_sheet(wb, ws, name.substring(0,31));
            });
            
            if (format === 'xlsx') {
                XLSX.writeFile(wb, `í†µí•©_${sheets.length}ê°œì‹œíŠ¸_${dateStr}.xlsx`);
            } else {
                XLSX.writeFile(wb, `í†µí•©_${dateStr}.csv`, { bookType: 'csv' });
            }
            
            toast(`${sheets.length}ê°œ ì‹œíŠ¸ ë³‘í•© ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
            
        } else if (downloadOutputType === 'individual' || downloadOutputType === 'structure') {
            // ZIP ìƒì„±
            const zip = new JSZip();
            
            sheets.forEach(name => {
                const sheet = WB[name];
                if (!sheet) return;
                
                const data = [sheet.headers, ...sheet.data];
                const ws = XLSX.utils.aoa_to_sheet(data);
                const miniWb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(miniWb, ws, 'Sheet1');
                const xlsxData = XLSX.write(miniWb, { type: 'array', bookType: 'xlsx' });
                
                if (downloadOutputType === 'structure' && sheetToFolder[name]) {
                    // í´ë” êµ¬ì¡° ìœ ì§€
                    const folderId = sheetToFolder[name];
                    const folderName = sheetFolders[folderId]?.name || 'ê¸°íƒ€';
                    zip.file(`${folderName}/${name}.xlsx`, xlsxData);
                } else {
                    zip.file(`${name}.xlsx`, xlsxData);
                }
            });
            
            // íŒŒì¼ ë³´ê´€í•¨ í•­ëª© ì¶”ê°€
            files.forEach(idx => {
                const file = fileStorage[idx];
                if (!file || !file.data) return;
                
                try {
                    const binary = atob(file.data);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    zip.file(file.name, bytes);
                } catch (e) {
                    console.error('íŒŒì¼ ì¶”ê°€ ì˜¤ë¥˜:', file.name, e);
                }
            });
            
            const content = await zip.generateAsync({ type: 'blob' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = `ë‹¤ìš´ë¡œë“œ_${dateStr}.zip`;
            link.click();
            URL.revokeObjectURL(link.href);
            
            toast(`ZIP ë‹¤ìš´ë¡œë“œ ì™„ë£Œ (${sheets.length}ê°œ ì‹œíŠ¸, ${files.length}ê°œ íŒŒì¼)`);
        }
    } catch (error) {
        console.error('ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
        toast('ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}

// ì „ì²´ ë°±ì—… (ZIP)
async function downloadAllAsZip() {
    document.getElementById('downloadDropdownMenu')?.classList.remove('show');
    
    const sheetNames = Object.keys(WB);
    if (sheetNames.length === 0 && (!fileStorage || fileStorage.length === 0)) {
        toast('ë‹¤ìš´ë¡œë“œí•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    try {
        const zip = new JSZip();
        const dateStr = new Date().toISOString().slice(0,10);
        
        // ì‹œíŠ¸ í´ë”
        const sheetsFolder = zip.folder('ì‹œíŠ¸');
        sheetNames.forEach(name => {
            const sheet = WB[name];
            if (!sheet) return;
            
            const data = [sheet.headers, ...sheet.data];
            const ws = XLSX.utils.aoa_to_sheet(data);
            const miniWb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(miniWb, ws, 'Sheet1');
            const xlsxData = XLSX.write(miniWb, { type: 'array', bookType: 'xlsx' });
            
            if (sheetToFolder[name] && sheetFolders[sheetToFolder[name]]) {
                const folderName = sheetFolders[sheetToFolder[name]].name;
                sheetsFolder.folder(folderName).file(`${name}.xlsx`, xlsxData);
            } else {
                sheetsFolder.file(`${name}.xlsx`, xlsxData);
            }
        });
        
        // íŒŒì¼ ë³´ê´€í•¨
        if (fileStorage && fileStorage.length > 0) {
            const filesFolder = zip.folder('íŒŒì¼ë³´ê´€í•¨');
            fileStorage.forEach(file => {
                if (!file || !file.data) return;
                try {
                    const binary = atob(file.data);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    filesFolder.file(file.name, bytes);
                } catch (e) {
                    console.error('íŒŒì¼ ì¶”ê°€ ì˜¤ë¥˜:', file.name);
                }
            });
        }
        
        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `ì—‘ì…€ë§ˆìŠ¤í„°_ì „ì²´ë°±ì—…_${dateStr}.zip`;
        link.click();
        URL.revokeObjectURL(link.href);
        
        toast(`ì „ì²´ ë°±ì—… ì™„ë£Œ (${sheetNames.length}ê°œ ì‹œíŠ¸, ${fileStorage?.length || 0}ê°œ íŒŒì¼)`);
    } catch (error) {
        console.error('ë°±ì—… ì˜¤ë¥˜:', error);
        toast('ë°±ì—… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}

// íŒŒì¼ ì•„ì´ì½˜ í—¬í¼
function toggleDeleteMode() {
    // ë‹¤ë¥¸ ëª¨ë“œê°€ ì¼œì ¸ìˆìœ¼ë©´ ë„ê¸°
    if (downloadMode) toggleDownloadMode();
    if (favoriteMode) toggleFavoriteMode();
    
    deleteMode = !deleteMode;
    const btn = document.getElementById('deleteModeBtn');
    const grid = document.getElementById('sheetGrid');
    
    if (!btn) return; // ë²„íŠ¼ì´ ì—†ìœ¼ë©´ ì¢…ë£Œ
    
    if (deleteMode) {
        btn.classList.add('active');
        btn.textContent = 'ì·¨ì†Œ';
        grid?.classList.add('delete-mode');
    } else {
        btn.classList.remove('active');
        btn.textContent = 'ì‚­ì œ';
        grid?.classList.remove('delete-mode');
    }
}

// ì¦ê²¨ì°¾ê¸° ëª¨ë“œ
let favoriteMode = false;

function toggleFavoriteMode() {
    // ë‹¤ë¥¸ ëª¨ë“œê°€ ì¼œì ¸ìˆìœ¼ë©´ ë„ê¸°
    if (downloadMode) toggleDownloadMode();
    if (deleteMode) toggleDeleteMode();
    
    favoriteMode = !favoriteMode;
    const btn = document.getElementById('favoriteModeBtn');
    const grid = document.getElementById('sheetGrid');

    if (favoriteMode) {
        if (btn) {
            btn.classList.add('active');
            btn.textContent = 'ì™„ë£Œ';
        }
        grid?.classList.add('favorite-mode');
    } else {
        if (btn) {
            btn.classList.remove('active');
            btn.textContent = 'ì¦ê²¨ì°¾ê¸°';
        }
        grid?.classList.remove('favorite-mode');
    }
}

function toggleFavorite(name) {
    const card = document.querySelector(`.sheet-card[data-sheet="${name}"]`);
    const star = card?.querySelector('.sheet-card-star');
    
    if (favoriteSheets.has(name)) {
        favoriteSheets.delete(name);
        card?.classList.remove('is-favorite');
        star?.classList.remove('favorited');
        toast(`"${name}" ì¦ê²¨ì°¾ê¸° í•´ì œ`);
    } else {
        favoriteSheets.add(name);
        card?.classList.add('is-favorite');
        star?.classList.add('favorited');
        toast(`"${name}" ì¦ê²¨ì°¾ê¸° ì¶”ê°€`);
    }
    
    // ì¦ê²¨ì°¾ê¸°ë§Œ ë³´ê¸° ìƒíƒœë©´ ë‹¤ì‹œ ë Œë”ë§
    if (showFavoritesOnly) {
        renderMainScreen();
    }
}

function toggleFavoriteFilter() {
    showFavoritesOnly = document.getElementById('favoriteFilter').checked;
    renderMainScreen();
}

// NEW ë°°ì§€ ì œê±° (ì‹œíŠ¸ í´ë¦­ ì‹œ)
function clearNewBadge(sheetName) {
    if (newSheets.has(sheetName)) {
        newSheets.delete(sheetName);
        // ì¹´ë“œì—ì„œ ë°°ì§€ ì¦‰ì‹œ ì œê±°
        const card = document.querySelector(`.sheet-card[data-sheet="${sheetName}"] .sheet-card-new`);
        if (card) card.remove();
    }
}

// ì‹œíŠ¸ ë·° ëª¨ë“œ ì „í™˜ (ì¹´ë“œ/ë¦¬ìŠ¤íŠ¸)
function setSheetViewMode(mode) {
    sheetViewMode = mode;
    renderMainScreen();
}

// í†µí•© ë·°ëª¨ë“œ ì „í™˜ (ëª¨ë“  íƒ­ì— ì ìš©)
function setUnifiedViewMode(mode) {
    closeViewDropdown();

    // ì•„ì´ì½˜ ì—…ë°ì´íŠ¸
    const iconMap = { 'icon': 'â€¢â€¢â€¢', 'card': 'â–¦', 'list': 'â˜°' };
    const iconEl = document.getElementById('currentViewIcon');
    if (iconEl) iconEl.textContent = iconMap[mode] || 'â€¢â€¢â€¢';

    // í˜„ì¬ íƒ­ì— ë”°ë¼ ì ì ˆí•œ ë·°ëª¨ë“œ ì„¤ì •
    switch (currentMainTab) {
        case 'sheets':
            sheetViewMode = mode;
            break;
        case 'files':
            // íŒŒì¼ ë³´ê´€í•¨ë„ ê°™ì€ ë·°ëª¨ë“œ ì ìš©
            break;
        case 'rawfiles':
            rawFileViewMode = mode;
            break;
    }
    renderMainScreen();
}

// ë·°ëª¨ë“œ ë“œë¡­ë‹¤ìš´ í† ê¸€
function toggleViewDropdown() {
    const menu = document.getElementById('viewDropdownMenu');
    if (!menu) return;
    menu.classList.toggle('show');

    if (menu.classList.contains('show')) {
        setTimeout(() => {
            document.addEventListener('click', closeViewDropdownOnClickOutside, { once: true });
        }, 10);
    }
}

function closeViewDropdown() {
    const menu = document.getElementById('viewDropdownMenu');
    if (menu) menu.classList.remove('show');
}

function closeViewDropdownOnClickOutside(e) {
    const wrapper = document.querySelector('.view-dropdown-wrapper');
    if (wrapper && !wrapper.contains(e?.target)) {
        closeViewDropdown();
    }
}

// ì¹´ë“œ ë©”ë‰´ í‘œì‹œ (â‹® ë²„íŠ¼)
function showCardMenu(event, itemName, itemType) {
    event.stopPropagation();
    event.preventDefault();

    // ê¸°ì¡´ ë©”ë‰´ ì œê±°
    closeCardMenu();

    const menu = document.createElement('div');
    menu.className = 'card-menu-popup';
    menu.id = 'cardMenuPopup';

    const safeName = itemName.replace(/'/g, "\\'");
    const isFavorite = favoriteSheets.has(itemName);

    if (itemType === 'sheet') {
        menu.innerHTML = `
            <div class="card-menu-item" onclick="handleSheetCardClick('${safeName}'); closeCardMenu();">ğŸ“„ ì—´ê¸°</div>
            <div class="card-menu-item" onclick="toggleFavorite('${safeName}'); closeCardMenu();">${isFavorite ? 'â­ ì¦ê²¨ì°¾ê¸° í•´ì œ' : 'â˜† ì¦ê²¨ì°¾ê¸°'}</div>
            <div class="card-menu-item" onclick="startRenameSheetCard(event, '${safeName}'); closeCardMenu();">âœï¸ ì´ë¦„ ë³€ê²½</div>
            <div class="card-menu-item" onclick="showMoveSelectedToFolderModal(['${safeName}']); closeCardMenu();">ğŸ“ í´ë” ì´ë™</div>
            <div class="card-menu-divider"></div>
            <div class="card-menu-item danger" onclick="confirmDeleteSheet('${safeName}'); closeCardMenu();">ğŸ—‘ï¸ ì‚­ì œ</div>
        `;
    }

    document.body.appendChild(menu);

    // ìœ„ì¹˜ ì„¤ì •
    const rect = event.target.getBoundingClientRect();
    menu.style.top = rect.bottom + 5 + 'px';
    menu.style.left = rect.left + 'px';

    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì¡°ì •
    const menuRect = menu.getBoundingClientRect();
    if (menuRect.right > window.innerWidth) {
        menu.style.left = (rect.right - menuRect.width) + 'px';
    }
    if (menuRect.bottom > window.innerHeight) {
        menu.style.top = (rect.top - menuRect.height - 5) + 'px';
    }

    // ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
    setTimeout(() => {
        document.addEventListener('click', closeCardMenu, { once: true });
    }, 10);
}

function closeCardMenu() {
    const menu = document.getElementById('cardMenuPopup');
    if (menu) menu.remove();
}

// ì „ì²´ í•„í„° ì´ˆê¸°í™”
function resetAllFilters() {
    // ì¦ê²¨ì°¾ê¸° í•„í„° í•´ì œ
    showFavoritesOnly = false;
    document.getElementById('favoriteFilter').checked = false;
    
    // ë‹¤ìš´ë¡œë“œ ëª¨ë“œ í•´ì œ
    if (downloadMode) toggleDownloadMode();
    
    // ì‚­ì œ ëª¨ë“œ í•´ì œ
    if (deleteMode) toggleDeleteMode();
    
    // ì¦ê²¨ì°¾ê¸° ëª¨ë“œ í•´ì œ
    if (favoriteMode) toggleFavoriteMode();
    
    // ì„ íƒëœ ì‹œíŠ¸ ì´ˆê¸°í™”
    selectedSheets.clear();
    
    // ê²€ìƒ‰ ì´ˆê¸°í™”
    document.getElementById('mainSearchInput').value = '';
    currentSearchResults = [];
    document.getElementById('searchResultsSection').style.display = 'none';
    
    // ë‚ ì§œ í•„í„° ì´ˆê¸°í™”
    document.getElementById('dateFrom').value = '';
    document.getElementById('dateTo').value = '';
    
    renderMainScreen();
    toast('í•„í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
}

// ì‹œíŠ¸ ì •ë¦¬ ëª¨ë‹¬ ì—´ê¸°
function openSheetOrganizer() {
    const folderName = currentFolderId ? sheetFolders[currentFolderId]?.name : 'ì „ì²´';
    
    // í˜„ì¬ í´ë”ì˜ ì‹œíŠ¸ë“¤ ê°€ì ¸ì˜¤ê¸°
    let sheetsInFolder = [];
    if (currentFolderId === null) {
        // ë£¨íŠ¸: í´ë”ì— ì†í•˜ì§€ ì•Šì€ ì‹œíŠ¸ë“¤
        sheetsInFolder = Object.keys(WB).filter(n => !sheetToFolder[n]);
    } else {
        // íŠ¹ì • í´ë” ì•ˆì˜ ì‹œíŠ¸ë“¤
        sheetsInFolder = Object.keys(WB).filter(n => sheetToFolder[n] === currentFolderId);
    }
    
    if (sheetsInFolder.length === 0) {
        toast('í˜„ì¬ í´ë”ì— ì •ë¦¬í•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    // í´ë” ëª©ë¡ (ì´ë™ìš©)
    const folderOptions = Object.entries(sheetFolders).map(([id, f]) => 
        `<option value="${id}" ${id === currentFolderId ? 'disabled' : ''}>${f.name}</option>`
    ).join('');
    
    let itemsHtml = '';
    for (const name of sheetsInFolder) {
        const sheet = WB[name];
        const rowCount = sheet?.data?.length || 0;
        const colCount = sheet?.headers?.length || 0;
        const isEmpty = rowCount === 0;
        
        itemsHtml += `
            <div class="organizer-item ${isEmpty ? 'empty' : ''}" data-sheet="${escHtml(name)}">
                <input type="checkbox" class="organizer-checkbox" data-sheet="${escHtml(name)}" onclick="event.stopPropagation();">
                <span class="organizer-icon">${isEmpty ? 'ğŸ“„' : 'ğŸ“Š'}</span>
                <div class="organizer-info">
                    <div class="organizer-name">${escHtml(name)}</div>
                    <div class="organizer-meta">${colCount}ì—´ Ã— ${rowCount}í–‰</div>
                </div>
                ${isEmpty ? '<span class="organizer-badge empty">ë¹ˆ ì‹œíŠ¸</span>' : `<span class="organizer-badge rows">${rowCount}í–‰</span>`}
            </div>
        `;
    }
    
    const emptyCount = sheetsInFolder.filter(n => !WB[n]?.data?.length).length;
    
    const modalHtml = `
        <div class="modal-overlay sheet-organizer-modal show" id="sheetOrganizerModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>ğŸ“‹ ì‹œíŠ¸ ì •ë¦¬</h3>
                    <button class="modal-close" onclick="closeSheetOrganizer()">Ã—</button>
                </div>
                
                <div class="organizer-header">
                    <div>
                        <div class="organizer-title">ğŸ“ ${escHtml(folderName)}</div>
                        <div class="organizer-folder-name">${sheetsInFolder.length}ê°œ ì‹œíŠ¸ ${emptyCount > 0 ? `(ë¹ˆ ì‹œíŠ¸ ${emptyCount}ê°œ)` : ''}</div>
                    </div>
                </div>
                
                <div class="organizer-toolbar">
                    <button onclick="organizerSelectAll()">ì „ì²´ ì„ íƒ</button>
                    <button onclick="organizerDeselectAll()">ì„ íƒ í•´ì œ</button>
                    <button onclick="organizerSelectEmpty()">ë¹ˆ ì‹œíŠ¸ ì„ íƒ</button>
                    <button class="danger" onclick="organizerDeleteSelected()">ì„ íƒ ì‚­ì œ</button>
                </div>
                
                <div class="organizer-list" id="organizerList">
                    ${itemsHtml}
                </div>
                
                <div class="organizer-footer">
                    <div class="organizer-summary">
                        <span id="organizerSelectedCount">0ê°œ ì„ íƒë¨</span>
                    </div>
                    <div class="organizer-actions">
                        <select class="move-folder-select" id="organizerMoveTarget">
                            <option value="">í´ë”ë¡œ ì´ë™...</option>
                            <option value="__root__" ${currentFolderId === null ? 'disabled' : ''}>ğŸ“ ì „ì²´ (ë£¨íŠ¸)</option>
                            ${folderOptions}
                        </select>
                        <button onclick="organizerMoveSelected()" style="padding:8px 14px; border:2px solid var(--retro-charcoal); border-radius:4px; background:var(--retro-blue); color:white; font-weight:600; cursor:pointer;">ì´ë™</button>
                        <button onclick="closeSheetOrganizer()" style="padding:8px 14px; border:2px solid var(--retro-charcoal); border-radius:4px; background:white; font-weight:600; cursor:pointer;">ë‹«ê¸°</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // ì•„ì´í…œ í´ë¦­ ì‹œ ì²´í¬ë°•ìŠ¤ í† ê¸€
    document.querySelectorAll('.organizer-item').forEach(item => {
        item.addEventListener('click', (e) => {
            if (e.target.type === 'checkbox') return;
            const checkbox = item.querySelector('.organizer-checkbox');
            checkbox.checked = !checkbox.checked;
            item.classList.toggle('selected', checkbox.checked);
            updateOrganizerSelectedCount();
        });
    });
    
    // ì²´í¬ë°•ìŠ¤ ë³€ê²½ ì‹œ
    document.querySelectorAll('.organizer-checkbox').forEach(cb => {
        cb.addEventListener('change', () => {
            cb.closest('.organizer-item').classList.toggle('selected', cb.checked);
            updateOrganizerSelectedCount();
        });
    });
}

// ì‹œíŠ¸ ì •ë¦¬ ëª¨ë‹¬ ë‹«ê¸°
function closeSheetOrganizer() {
    const modal = document.getElementById('sheetOrganizerModal');
    if (modal) modal.remove();
}

// ì„ íƒ ê°œìˆ˜ ì—…ë°ì´íŠ¸
function updateOrganizerSelectedCount() {
    const count = document.querySelectorAll('.organizer-checkbox:checked').length;
    document.getElementById('organizerSelectedCount').textContent = `${count}ê°œ ì„ íƒë¨`;
}

// ì „ì²´ ì„ íƒ
function organizerSelectAll() {
    document.querySelectorAll('.organizer-checkbox').forEach(cb => {
        cb.checked = true;
        cb.closest('.organizer-item').classList.add('selected');
    });
    updateOrganizerSelectedCount();
}

// ì„ íƒ í•´ì œ
function organizerDeselectAll() {
    document.querySelectorAll('.organizer-checkbox').forEach(cb => {
        cb.checked = false;
        cb.closest('.organizer-item').classList.remove('selected');
    });
    updateOrganizerSelectedCount();
}

// ë¹ˆ ì‹œíŠ¸ ì„ íƒ
function organizerSelectEmpty() {
    document.querySelectorAll('.organizer-checkbox').forEach(cb => {
        cb.checked = false;
        cb.closest('.organizer-item').classList.remove('selected');
    });
    document.querySelectorAll('.organizer-item.empty .organizer-checkbox').forEach(cb => {
        cb.checked = true;
        cb.closest('.organizer-item').classList.add('selected');
    });
    updateOrganizerSelectedCount();
}

// ì„ íƒ ì‚­ì œ
function organizerDeleteSelected() {
    const selected = Array.from(document.querySelectorAll('.organizer-checkbox:checked'))
        .map(cb => cb.dataset.sheet);
    
    if (selected.length === 0) {
        toast('ì‚­ì œí•  ì‹œíŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    
    if (!confirm(`${selected.length}ê°œ ì‹œíŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n${selected.join(', ')}`)) return;
    
    for (const name of selected) {
        delete WB[name];
        delete COL_ORDER[name];
        delete HIDDEN_COLS[name];
        delete COL_WIDTHS[name];
        delete ROW_HEIGHTS[name];
        delete sheetToFolder[name];
        favoriteSheets.delete(name);
        if (newSheets) newSheets.delete(name);
        if (multiSelectedSheets) multiSelectedSheets.delete(name);
    }
    
    saveFolderData();
    closeSheetOrganizer();
    renderMainScreen();
    toast(`${selected.length}ê°œ ì‹œíŠ¸ ì‚­ì œ ì™„ë£Œ`);
}

// ì„ íƒ ì‹œíŠ¸ í´ë”ë¡œ ì´ë™
function organizerMoveSelected() {
    const targetFolderId = document.getElementById('organizerMoveTarget').value;
    if (!targetFolderId) {
        toast('ì´ë™í•  í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    
    const selected = Array.from(document.querySelectorAll('.organizer-checkbox:checked'))
        .map(cb => cb.dataset.sheet);
    
    if (selected.length === 0) {
        toast('ì´ë™í•  ì‹œíŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    
    const targetName = targetFolderId === '__root__' ? 'ì „ì²´ (ë£¨íŠ¸)' : sheetFolders[targetFolderId]?.name;
    const actualTargetFolderId = targetFolderId === '__root__' ? null : targetFolderId;
    
    // ë³‘í•© ëŒ€ìƒ ì°¾ê¸°
    const mergeTargets = [];
    const justMove = [];
    
    for (const sheetName of selected) {
        if (!WB[sheetName]) continue;
        
        const movingSheet = WB[sheetName];
        const movingHeaders = JSON.stringify(movingSheet.headers);
        
        // ëŒ€ìƒ í´ë”ì—ì„œ ê°™ì€ í—¤ë”ë¥¼ ê°€ì§„ ì‹œíŠ¸ ì°¾ê¸°
        let targetSheetName = null;
        
        if (actualTargetFolderId === null) {
            // ë£¨íŠ¸ë¡œ ì´ë™
            for (const name of Object.keys(WB)) {
                if (!sheetToFolder[name] && name !== sheetName && !selected.includes(name)) {
                    if (JSON.stringify(WB[name].headers) === movingHeaders) {
                        targetSheetName = name;
                        break;
                    }
                }
            }
        } else {
            // íŠ¹ì • í´ë”ë¡œ ì´ë™
            for (const [name, fid] of Object.entries(sheetToFolder)) {
                if (fid === actualTargetFolderId && WB[name] && name !== sheetName && !selected.includes(name)) {
                    if (JSON.stringify(WB[name].headers) === movingHeaders) {
                        targetSheetName = name;
                        break;
                    }
                }
            }
        }
        
        if (targetSheetName) {
            mergeTargets.push({
                source: sheetName,
                target: targetSheetName,
                sourceRows: movingSheet.data.length,
                targetRows: WB[targetSheetName].data.length
            });
        } else {
            justMove.push(sheetName);
        }
    }
    
    // ì‹œíŠ¸ ì •ë¦¬ ëª¨ë‹¬ ë‹«ê¸°
    closeSheetOrganizer();
    
    // ë³‘í•© ëŒ€ìƒì´ ìˆìœ¼ë©´ í™•ì¸ ëª¨ë‹¬ í‘œì‹œ
    if (mergeTargets.length > 0) {
        showMergeConfirmModalForOrganizer(actualTargetFolderId, targetName, mergeTargets, justMove);
    } else {
        // ë³‘í•© ëŒ€ìƒ ì—†ìœ¼ë©´ ë°”ë¡œ ì´ë™
        executeOrganizerMove(actualTargetFolderId, targetName, [], justMove);
    }
}

// ì‹œíŠ¸ ì •ë¦¬ìš© ë³‘í•© í™•ì¸ ëª¨ë‹¬
function showMergeConfirmModalForOrganizer(folderId, folderName, mergeTargets, justMove) {
    let mergeListHtml = '';
    for (const item of mergeTargets) {
        mergeListHtml += `
            <div class="merge-confirm-item">
                <div style="margin-bottom:8px;">
                    <span class="merge-source">"${escHtml(item.source)}" (${item.sourceRows}í–‰)</span>
                    <span class="merge-arrow">â†’</span>
                    <span class="merge-target">"${escHtml(item.target)}" (${item.targetRows}í–‰)</span>
                </div>
                <div class="merge-option" style="padding-left:0;">
                    <label>
                        <input type="radio" name="merge_org_${item.source.replace(/[^a-zA-Z0-9]/g, '_')}" value="merge" checked>
                        ë³‘í•©í•˜ê¸°
                    </label>
                    <label>
                        <input type="radio" name="merge_org_${item.source.replace(/[^a-zA-Z0-9]/g, '_')}" value="move">
                        ê·¸ëƒ¥ ì´ë™
                    </label>
                </div>
            </div>
        `;
    }
    
    const modalHtml = `
        <div class="modal-overlay merge-confirm-modal show" id="mergeConfirmOrgModal">
            <div class="modal-content" style="max-width:550px;">
                <div class="modal-header">
                    <h3>ğŸ“ "${escHtml(folderName)}"(ìœ¼)ë¡œ ì´ë™</h3>
                    <button class="modal-close" onclick="closeMergeConfirmOrgModal()">Ã—</button>
                </div>
                
                <div style="padding:15px 0;">
                    <p style="margin-bottom:15px;color:var(--retro-warm-gray);">
                        ê°™ì€ í—¤ë”ë¥¼ ê°€ì§„ ì‹œíŠ¸ê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.
                    </p>
                    
                    <div class="merge-confirm-list">
                        ${mergeListHtml}
                    </div>
                    
                    ${justMove.length > 0 ? `
                        <div style="margin-top:15px;padding-top:15px;border-top:1px solid var(--retro-border);">
                            <div style="font-size:13px;color:var(--retro-warm-gray);">
                                ê·¸ëƒ¥ ì´ë™: ${justMove.map(n => `"${n}"`).join(', ')}
                            </div>
                        </div>
                    ` : ''}
                </div>
                
                <div class="modal-footer" style="display:flex;justify-content:flex-end;gap:10px;padding-top:15px;border-top:2px solid var(--retro-border);">
                    <button onclick="closeMergeConfirmOrgModal()" style="padding:10px 20px;border:2px solid var(--retro-charcoal);border-radius:4px;background:white;font-weight:600;cursor:pointer;">ì·¨ì†Œ</button>
                    <button onclick="executeMergeConfirmOrg()" style="padding:10px 20px;border:2px solid var(--retro-charcoal);border-radius:4px;background:var(--retro-blue);color:white;font-weight:600;cursor:pointer;">í™•ì¸</button>
                </div>
            </div>
        </div>
    `;
    
    window._pendingOrgMerge = { folderId, folderName, mergeTargets, justMove };
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeMergeConfirmOrgModal() {
    const modal = document.getElementById('mergeConfirmOrgModal');
    if (modal) modal.remove();
    window._pendingOrgMerge = null;
}

function executeMergeConfirmOrg() {
    const pending = window._pendingOrgMerge;
    if (!pending) return;
    
    const toMerge = [];
    const toMove = [...pending.justMove];
    
    for (const item of pending.mergeTargets) {
        const radioName = `merge_org_${item.source.replace(/[^a-zA-Z0-9]/g, '_')}`;
        const selected = document.querySelector(`input[name="${radioName}"]:checked`);
        
        if (selected && selected.value === 'merge') {
            toMerge.push(item);
        } else {
            toMove.push(item.source);
        }
    }
    
    closeMergeConfirmOrgModal();
    executeOrganizerMove(pending.folderId, pending.folderName, toMerge, toMove);
}

function executeOrganizerMove(folderId, folderName, toMerge, toMove) {
    let movedCount = 0;
    let mergedCount = 0;
    let totalAddedRows = 0;
    
    // ë³‘í•© ì‹¤í–‰
    for (const item of toMerge) {
        const sourceSheet = WB[item.source];
        const targetSheet = WB[item.target];
        
        if (!sourceSheet || !targetSheet) continue;
        
        const existingSet = new Set(targetSheet.data.map(row => JSON.stringify(row)));
        let addedRows = 0;
        
        for (const row of sourceSheet.data) {
            const rowStr = JSON.stringify(row);
            if (!existingSet.has(rowStr)) {
                targetSheet.data.push(row);
                existingSet.add(rowStr);
                addedRows++;
            }
        }
        
        delete WB[item.source];
        delete COL_ORDER[item.source];
        delete HIDDEN_COLS[item.source];
        delete COL_WIDTHS[item.source];
        delete ROW_HEIGHTS[item.source];
        delete sheetToFolder[item.source];
        favoriteSheets.delete(item.source);
        if (newSheets) newSheets.delete(item.source);
        if (multiSelectedSheets) multiSelectedSheets.delete(item.source);
        
        mergedCount++;
        totalAddedRows += addedRows;
    }
    
    // ì´ë™ ì‹¤í–‰
    for (const sheetName of toMove) {
        if (!WB[sheetName]) continue;
        if (folderId === null) {
            delete sheetToFolder[sheetName];
        } else {
            sheetToFolder[sheetName] = folderId;
        }
        movedCount++;
    }
    
    saveFolderData();
    renderMainScreen();
    
    let msg = '';
    if (movedCount > 0) msg += `${movedCount}ê°œ ì´ë™`;
    if (mergedCount > 0) {
        if (msg) msg += ', ';
        msg += `${mergedCount}ê°œ ë³‘í•© (+${totalAddedRows}í–‰)`;
    }
    if (msg) {
        toast(`'${folderName}'(ìœ¼)ë¡œ ${msg}`);
    }
}

// ì‹œíŠ¸ ì •ë¦¬ (ê°™ì€ í—¤ë” ì‹œíŠ¸ ë³‘í•©) - ê¸°ì¡´ í•¨ìˆ˜ ìœ ì§€
function mergeSheetsByHeader() {
    // 1. í—¤ë” ê¸°ì¤€ìœ¼ë¡œ ì‹œíŠ¸ ê·¸ë£¹í™”
    const headerGroups = {};
    const sheetNames = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
    
    for (const name of sheetNames) {
        const headerKey = JSON.stringify(WB[name].headers);
        if (!headerGroups[headerKey]) {
            headerGroups[headerKey] = [];
        }
        headerGroups[headerKey].push(name);
    }
    
    // 2. ì¤‘ë³µ ê·¸ë£¹ ì°¾ê¸° (2ê°œ ì´ìƒ ì‹œíŠ¸ê°€ ê°™ì€ í—¤ë”)
    const mergeGroups = Object.values(headerGroups).filter(g => g.length > 1);
    
    if (mergeGroups.length === 0) {
        toast('ë³‘í•©í•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ëª¨ë“  ì‹œíŠ¸ì˜ í—¤ë”ê°€ ë‹¤ë¦…ë‹ˆë‹¤.');
        return;
    }
    
    // 3. ë³‘í•© ì´ë¦„ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
    showMergeNameModal(mergeGroups);
}

// ë³‘í•© ì´ë¦„ ì„ íƒ ëª¨ë‹¬
function showMergeNameModal(mergeGroups) {
    let modalHtml = `
        <div class="modal-overlay merge-name-modal show" id="mergeNameModal">
            <div class="modal-content" style="max-width:600px;max-height:80vh;overflow-y:auto;">
                <div class="modal-header">
                    <h3>ì‹œíŠ¸ ë³‘í•© - ì´ë¦„ ì„ íƒ</h3>
                    <button class="modal-close" onclick="closeMergeNameModal()">Ã—</button>
                </div>
                <p style="color:var(--retro-warm-gray);font-size:13px;margin-bottom:20px;">
                    ê° ê·¸ë£¹ë³„ë¡œ ë³‘í•© í›„ ì‚¬ìš©í•  ì´ë¦„ì„ ì„ íƒí•˜ê±°ë‚˜ ì§ì ‘ ì…ë ¥í•˜ì„¸ìš”.
                </p>
                <div class="merge-groups-list">
    `;
    
    mergeGroups.forEach((group, groupIdx) => {
        const baseName = getBaseName(group[0]);
        const totalRows = group.reduce((sum, name) => sum + WB[name].data.length, 0);
        
        modalHtml += `
            <div class="merge-group-item" style="margin-bottom:20px;padding:15px;background:var(--retro-mint);border-radius:8px;border:2px solid var(--retro-border);">
                <div style="font-weight:600;margin-bottom:10px;color:var(--retro-charcoal);">
                    ê·¸ë£¹ ${groupIdx + 1} (${group.length}ê°œ ì‹œíŠ¸, ${totalRows}í–‰)
                </div>
                <div style="font-size:12px;color:var(--retro-warm-gray);margin-bottom:10px;">
                    ë³‘í•© ëŒ€ìƒ: ${group.map(n => `"${n}"`).join(', ')}
                </div>
                <div style="margin-bottom:8px;font-size:12px;font-weight:500;">ë³‘í•© í›„ ì´ë¦„:</div>
                <div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px;">
        `;
        
        // ê° ì‹œíŠ¸ ì´ë¦„ì„ ì„ íƒ ì˜µì…˜ìœ¼ë¡œ ì œê³µ
        group.forEach((name, nameIdx) => {
            const isDefault = name === baseName || nameIdx === 0;
            modalHtml += `
                <label style="display:flex;align-items:center;gap:5px;padding:6px 12px;background:white;border:2px solid var(--retro-border);border-radius:4px;cursor:pointer;font-size:12px;">
                    <input type="radio" name="mergeGroup${groupIdx}" value="${escHtml(name)}" ${isDefault ? 'checked' : ''} onchange="updateMergeCustomInput(${groupIdx}, '${escHtml(name.replace(/'/g, "\\'"))}')">
                    ${escHtml(name)}
                </label>
            `;
        });
        
        modalHtml += `
                    <label style="display:flex;align-items:center;gap:5px;padding:6px 12px;background:white;border:2px solid var(--retro-border);border-radius:4px;cursor:pointer;font-size:12px;">
                        <input type="radio" name="mergeGroup${groupIdx}" value="__custom__" onchange="enableMergeCustomInput(${groupIdx})">
                        ì§ì ‘ ì…ë ¥
                    </label>
                </div>
                <input type="text" id="mergeCustomInput${groupIdx}" class="merge-custom-input" 
                    placeholder="ìƒˆ ì´ë¦„ ì…ë ¥..." 
                    style="width:100%;padding:8px 12px;border:2px solid var(--retro-border);border-radius:4px;font-size:13px;display:none;"
                    value="${escHtml(baseName)}">
            </div>
        `;
    });
    
    modalHtml += `
                </div>
                <div class="modal-footer" style="margin-top:20px;padding-top:15px;border-top:2px solid var(--retro-border);">
                    <button class="modal-btn" onclick="closeMergeNameModal()">ì·¨ì†Œ</button>
                    <button class="modal-btn primary" onclick="executeMergeWithNames()">ë³‘í•© ì‹¤í–‰</button>
                </div>
            </div>
        </div>
    `;
    
    // ëª¨ë‹¬ì— ê·¸ë£¹ ë°ì´í„° ì €ì¥
    window.pendingMergeGroups = mergeGroups;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

// ì§ì ‘ ì…ë ¥ í™œì„±í™”
function enableMergeCustomInput(groupIdx) {
    const input = document.getElementById(`mergeCustomInput${groupIdx}`);
    if (input) {
        input.style.display = 'block';
        input.focus();
        input.select();
    }
}

// ê¸°ì¡´ ì´ë¦„ ì„ íƒ ì‹œ ì»¤ìŠ¤í…€ ì…ë ¥ ìˆ¨ê¸°ê¸°
function updateMergeCustomInput(groupIdx, name) {
    const input = document.getElementById(`mergeCustomInput${groupIdx}`);
    if (input) {
        input.style.display = 'none';
        input.value = name;
    }
}

// ë³‘í•© ëª¨ë‹¬ ë‹«ê¸°
function closeMergeNameModal() {
    const modal = document.getElementById('mergeNameModal');
    if (modal) modal.remove();
    window.pendingMergeGroups = null;
}

// ì„ íƒëœ ì´ë¦„ìœ¼ë¡œ ë³‘í•© ì‹¤í–‰
function executeMergeWithNames() {
    const mergeGroups = window.pendingMergeGroups;
    if (!mergeGroups || mergeGroups.length === 0) {
        closeMergeNameModal();
        return;
    }
    
    // ê° ê·¸ë£¹ì˜ ì„ íƒëœ ì´ë¦„ ìˆ˜ì§‘
    const selectedNames = [];
    for (let i = 0; i < mergeGroups.length; i++) {
        const selected = document.querySelector(`input[name="mergeGroup${i}"]:checked`);
        let targetName;
        
        if (selected && selected.value === '__custom__') {
            const customInput = document.getElementById(`mergeCustomInput${i}`);
            targetName = customInput ? customInput.value.trim() : '';
        } else if (selected) {
            targetName = selected.value;
        } else {
            targetName = getBaseName(mergeGroups[i][0]);
        }
        
        if (!targetName) {
            toast(`ê·¸ë£¹ ${i + 1}ì˜ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”`);
            return;
        }
        
        selectedNames.push(targetName);
    }
    
    // ì´ë¦„ ì¤‘ë³µ ê²€ì‚¬
    const nameSet = new Set();
    for (const name of selectedNames) {
        if (nameSet.has(name)) {
            toast(`ì¤‘ë³µëœ ì´ë¦„ì´ ìˆìŠµë‹ˆë‹¤: "${name}"`);
            return;
        }
        nameSet.add(name);
    }
    
    closeMergeNameModal();
    
    // ë³‘í•© ì‹¤í–‰
    showLoading('ì‹œíŠ¸ ë³‘í•© ì¤‘...');
    let mergedCount = 0;
    let addedRows = 0;
    
    for (let i = 0; i < mergeGroups.length; i++) {
        const group = mergeGroups[i];
        const targetName = selectedNames[i];
        
        // ë³‘í•© ì‹œíŠ¸ ìƒì„±
        const headers = WB[group[0]].headers;
        const allData = [];
        const existingSet = new Set();
        
        // ëª¨ë“  ì‹œíŠ¸ì˜ ë°ì´í„°ë¥¼ í•©ì¹˜ê¸° (ì¤‘ë³µ ì œê±°)
        for (const sheetName of group) {
            for (const row of WB[sheetName].data) {
                const rowKey = JSON.stringify(row);
                if (!existingSet.has(rowKey)) {
                    existingSet.add(rowKey);
                    allData.push(row);
                }
            }
        }
        
        // ê¸°ì¡´ ì‹œíŠ¸ë“¤ ì‚­ì œ
        for (const sheetName of group) {
            delete WB[sheetName];
            delete COL_ORDER[sheetName];
            delete HIDDEN_COLS[sheetName];
            delete COL_WIDTHS[sheetName];
            delete ROW_HEIGHTS[sheetName];
            delete sheetToFolder[sheetName];
            if (favoriteSheets) favoriteSheets.delete(sheetName);
            if (newSheets) newSheets.delete(sheetName);
            if (multiSelectedSheets) multiSelectedSheets.delete(sheetName);
            mergedCount++;
        }
        
        // ë³‘í•©ëœ ì‹œíŠ¸ ìƒì„±
        WB[targetName] = { headers: headers, data: allData };
        COL_ORDER[targetName] = headers.map((_, i) => i);
        HIDDEN_COLS[targetName] = new Set();
        
        addedRows += allData.length;
    }
    
    saveFolderData(); // í´ë” ë§¤í•‘ ë³€ê²½ ì €ì¥
    hideLoading();
    renderMainScreen();
    
    toast(`${mergedCount}ê°œ ì‹œíŠ¸ â†’ ${mergeGroups.length}ê°œë¡œ ë³‘í•© ì™„ë£Œ (ì´ ${addedRows}í–‰)`);
}

// ì‹œíŠ¸ ì´ë¦„ì—ì„œ ê¸°ë³¸ ì´ë¦„ ì¶”ì¶œ (ìˆ«ì ì ‘ë¯¸ì‚¬ ì œê±°)
function getBaseName(name) {
    // "êµ­ë¯¼í™˜ë¶ˆì¥(2)" â†’ "êµ­ë¯¼í™˜ë¶ˆì¥"
    // "PGì‚¬_ER(3)" â†’ "PGì‚¬_ER"
    return name.replace(/\(\d+\)$/, '').trim();
}

function confirmDeleteSheet(name) {
    const sheet = WB[name];
    if (!sheet) return;
    
    const dataCount = sheet.data.length;
    const msg = dataCount > 0 
        ? `"${name}" ì‹œíŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nâš ï¸ ${dataCount}ê±´ì˜ ë°ì´í„°ê°€ ëª¨ë‘ ì‚­ì œë©ë‹ˆë‹¤.`
        : `"${name}" ì‹œíŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
    
    if (confirm(msg)) {
        deleteSheetFromMain(name);
    }
}

function deleteSheetFromMain(name) {
    if (!WB[name]) return;

    const dataCount = WB[name].data.length;

    // íœ´ì§€í†µì— ì €ì¥ (ë³µì› ê°€ëŠ¥)
    moveToTrash(name);

    // DOMì—ì„œ í•´ë‹¹ ì¹´ë“œ ì¦‰ì‹œ ì œê±°
    const allCards = document.querySelectorAll('.sheet-card');
    allCards.forEach(card => {
        if (card.getAttribute('data-sheet') === name) {
            card.remove();
        }
    });

    // ì‹œíŠ¸ ì‚­ì œ
    delete WB[name];
    delete COL_ORDER[name];
    delete HIDDEN_COLS[name];
    delete COL_WIDTHS[name];
    delete ROW_HEIGHTS[name];
    delete sheetToFolder[name];
    if (favoriteSheets) favoriteSheets.delete(name);
    if (newSheets) newSheets.delete(name);
    if (multiSelectedSheets) multiSelectedSheets.delete(name);
    removeSheetFromFileGroup(name); // íŒŒì¼ ê·¸ë£¹ì—ì„œ ì œê±°
    saveFolderData(); // í´ë” ë§¤í•‘ ë³€ê²½ ì €ì¥

    // í˜„ì¬ ì‹œíŠ¸ê°€ ì‚­ì œëœ ê²½ìš° ë‹¤ë¥¸ ì‹œíŠ¸ë¡œ ì „í™˜
    if (SHEET === name) {
        const remaining = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
        SHEET = remaining.length > 0 ? remaining[0] : Object.keys(WB)[0] || 'ì‘ì—…ì¥';
    }

    // ì‹œíŠ¸ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
    const totalCount = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0).length;
    document.getElementById('sheetCountBadge').textContent = `${totalCount}ê°œ`;

    // ì‚­ì œ ëª¨ë“œ ìœ ì§€
    if (deleteMode) {
        document.getElementById('sheetGrid')?.classList.add('delete-mode');
    }

    // ë³€ê²½ì‚¬í•­ í‘œì‹œ
    hasUnsavedChanges = true;

    showUndoToast(name, dataCount);
}

function goToMain() {
    if (NEW_ENTRY_MODE) finishNewEntryMode();
    if (COPY_MODE) toggleCopyMode();

    // ê²€ìƒ‰ ê²°ê³¼ ë©”ì¸ í™”ë©´ì´ ì—´ë ¤ìˆìœ¼ë©´ ë‹«ê¸°
    const searchResultsMain = document.getElementById('searchResultsMain');
    if (searchResultsMain && searchResultsMain.style.display !== 'none') {
        searchResultsMain.style.display = 'none';
        document.getElementById('spreadsheetContainer').style.display = '';
    }

    document.getElementById('detailScreen').style.display = 'none';
    document.getElementById('mainScreen').style.display = 'flex';
    
    // ëª¨ë“œ ì´ˆê¸°í™”
    if (downloadMode) toggleDownloadMode();
    if (deleteMode) toggleDeleteMode();
    if (favoriteMode) toggleFavoriteMode();
    
    renderMainScreen();
    
    // ê²€ìƒ‰ ê²°ê³¼ê°€ ìˆìœ¼ë©´ ë³µì›
    if (currentSearchResults.length > 0) {
        const keyword = document.getElementById('mainSearchInput').value.trim();
        const resultsSection = document.getElementById('searchResultsSection');
        const countBadge = document.getElementById('searchCountBadge');
        
        countBadge.textContent = currentSearchResults.length + 'ê±´';
        renderSearchResults(keyword);
        resultsSection.style.display = 'block';
    }
}

function addSheetFromMain() {
    addSheet();
    if (WB[SHEET] && WB[SHEET].data && WB[SHEET].data.length === 0) {
        // ë¹ˆ ì‹œíŠ¸ ìƒì„± í›„ ë°”ë¡œ ìƒì„¸ í™”ë©´ìœ¼ë¡œ
        document.getElementById('mainScreen').style.display = 'none';
        document.getElementById('detailScreen').style.display = 'flex';
        renderSheetTabs();
        renderSpreadsheet();
    }
}

// í•œê¸€ ì…ë ¥ ì¤‘ ì—¬ë¶€
let isComposing = false;

// ì‹¤ì‹œê°„ ê²€ìƒ‰ (ì…ë ¥í•  ë•Œë§ˆë‹¤)
function handleMainSearchInput(e) {
    // í•œê¸€ ì…ë ¥ ì¤‘ì´ë©´ ë¬´ì‹œ (compositionendì—ì„œ ì²˜ë¦¬)
    if (isComposing) return;
    
    if (searchTimeout) clearTimeout(searchTimeout);
    searchTimeout = setTimeout(doMainSearch, SEARCH_DELAY);
}

function handleMainSearchKeydown(e) {
    if (e.key === 'Enter') {
        if (searchTimeout) clearTimeout(searchTimeout);
        e.preventDefault();
        doMainSearch();
    }
}

// ë¹ ë¥¸ ë‚ ì§œ ì„ íƒ
function setQuickDate(type) {
    const today = new Date();
    let fromDate, toDate;
    let labelText = 'ì „ì²´';

    // ë“œë¡­ë‹¤ìš´ ë‹«ê¸°
    closeDateDropdown();

    if (type === 'all') {
        document.getElementById('dateFrom').value = '';
        document.getElementById('dateTo').value = '';
        updateDateLabel('ì „ì²´');
        // ì „ì²´ ì„ íƒ ì‹œ ë°”ë¡œ ì „ì²´ ë°ì´í„° í‘œì‹œ
        doDateSearchAll();
        return;
    }

    toDate = today.toISOString().slice(0, 10);

    switch(type) {
        case 'today':
            fromDate = toDate;
            labelText = 'ì˜¤ëŠ˜';
            break;
        case 'week':
            const dayOfWeek = today.getDay();
            const monday = new Date(today);
            monday.setDate(today.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));
            fromDate = monday.toISOString().slice(0, 10);
            labelText = 'ì´ë²ˆì£¼';
            break;
        case 'month':
            fromDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-01`;
            labelText = 'ì´ë²ˆë‹¬';
            break;
        case '3months':
            const threeMonthsAgo = new Date(today);
            threeMonthsAgo.setMonth(today.getMonth() - 3);
            fromDate = threeMonthsAgo.toISOString().slice(0, 10);
            labelText = '3ê°œì›”';
            break;
        case '6months':
            const sixMonthsAgo = new Date(today);
            sixMonthsAgo.setMonth(today.getMonth() - 6);
            fromDate = sixMonthsAgo.toISOString().slice(0, 10);
            labelText = '6ê°œì›”';
            break;
        case '1year':
            const oneYearAgo = new Date(today);
            oneYearAgo.setFullYear(today.getFullYear() - 1);
            fromDate = oneYearAgo.toISOString().slice(0, 10);
            labelText = '1ë…„';
            break;
    }

    document.getElementById('dateFrom').value = fromDate;
    document.getElementById('dateTo').value = toDate;
    updateDateLabel(labelText);

    // ë°”ë¡œ ë‚ ì§œ ë²”ìœ„ ê²€ìƒ‰ ì‹¤í–‰
    doDateSearch();
}

// ê¸°ê°„ ë“œë¡­ë‹¤ìš´ í† ê¸€
function toggleDateDropdown() {
    const menu = document.getElementById('dateDropdownMenu');
    if (!menu) return;
    menu.classList.toggle('show');

    if (menu.classList.contains('show')) {
        setTimeout(() => {
            document.addEventListener('click', closeDateDropdownOnClickOutside, { once: true });
        }, 10);
    }
}

function closeDateDropdown() {
    const menu = document.getElementById('dateDropdownMenu');
    if (menu) menu.classList.remove('show');
}

function closeDateDropdownOnClickOutside(e) {
    const wrapper = document.querySelector('.date-dropdown-wrapper');
    if (wrapper && !wrapper.contains(e?.target)) {
        closeDateDropdown();
    }
}

function updateDateLabel(text) {
    const label = document.getElementById('selectedDateLabel');
    if (label) label.textContent = text;
}

// ì „ì²´ ë°ì´í„° ê²€ìƒ‰ (ë‚ ì§œ ì œí•œ ì—†ìŒ)
function doDateSearchAll() {
    const resultsSection = document.getElementById('searchResultsSection');
    const resultsContainer = document.getElementById('searchResults');
    const countBadge = document.getElementById('searchCountBadge');
    
    // ë°ì´í„° ìˆëŠ” ì‹œíŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸
    const hasData = Object.keys(WB).some(name => WB[name] && WB[name].data && WB[name].data.length > 0);
    if (!hasData) {
        resultsContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--retro-warm-gray);">ê²€ìƒ‰í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ì„ ë¨¼ì € ì—´ì–´ì£¼ì„¸ìš”.</div>';
        resultsSection.style.display = 'block';
        currentSearchResults = [];
        return;
    }
    
    const results = [];
    const maxResults = 500;
    
    // ëª¨ë“  ì‹œíŠ¸ì˜ ëª¨ë“  ë°ì´í„°
    outerLoop:
    for (const sheetName of Object.keys(WB)) {
        const sheet = WB[sheetName];
        if (!sheet || !sheet.data || sheet.data.length === 0) continue;
        
        for (let i = 0; i < sheet.data.length; i++) {
            const row = sheet.data[i];
            if (!row) continue;
            
            results.push({
                sheet: sheetName,
                rowIdx: i,
                headers: sheet.headers,
                rowData: row  // ì›ë³¸ ì°¸ì¡° (ì½ê¸° ì „ìš©)
            });
            if (results.length >= maxResults) break outerLoop;
        }
    }
    
    currentSearchResults = results;
    countBadge.textContent = results.length + (results.length >= maxResults ? '+' : '') + 'ê±´';
    
    if (results.length === 0) {
        resultsContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--retro-warm-gray);">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
    } else {
        renderSearchResults('');
    }
    
    resultsSection.style.display = 'block';
    document.getElementById('mainSearchInput').value = '';
}

// ë‚ ì§œ íŒŒì‹±ìš© ì •ê·œì‹ ìºì‹œ (ì„±ëŠ¥ ìµœì í™”)
const DATE_REGEX = {
    korean: /(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼/,
    iso: /(\d{4})-(\d{1,2})-(\d{1,2})/,
    slash: /(\d{4})\/(\d{1,2})\/(\d{1,2})/,
    usSlash: /(\d{1,2})\/(\d{1,2})\/(\d{4})/,
    english: /([A-Za-z]+)\s+(\d{1,2}),?\s+(\d{4})/
};
const MONTH_NAMES = {
    'january': 0, 'february': 1, 'march': 2, 'april': 3,
    'may': 4, 'june': 5, 'july': 6, 'august': 7,
    'september': 8, 'october': 9, 'november': 10, 'december': 11
};

// ë‚ ì§œ ë¬¸ìì—´ì„ ë¹„êµ ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜ (ì„±ëŠ¥ ìµœì í™”)
function parseDateString(str) {
    if (!str) return null;
    
    let match;
    
    // "2025ë…„ 1ì›” 15ì¼" í˜•íƒœ
    if ((match = DATE_REGEX.korean.exec(str))) {
        return new Date(+match[1], +match[2] - 1, +match[3]);
    }
    
    // "2025-01-15" í˜•íƒœ (ê°€ì¥ í”í•¨)
    if ((match = DATE_REGEX.iso.exec(str))) {
        return new Date(+match[1], +match[2] - 1, +match[3]);
    }
    
    // "2025/01/15" í˜•íƒœ
    if ((match = DATE_REGEX.slash.exec(str))) {
        return new Date(+match[1], +match[2] - 1, +match[3]);
    }
    
    // "01/15/2025" í˜•íƒœ
    if ((match = DATE_REGEX.usSlash.exec(str))) {
        return new Date(+match[3], +match[1] - 1, +match[2]);
    }
    
    // "April 15, 2024" í˜•íƒœ
    if ((match = DATE_REGEX.english.exec(str))) {
        const monthNum = MONTH_NAMES[match[1].toLowerCase()];
        if (monthNum !== undefined) {
            return new Date(+match[3], monthNum, +match[2]);
        }
    }
    
    return null;
}

// ë‚ ì§œë¥¼ í•œê¸€ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
function formatDateToKorean(str) {
    if (!str) return str;
    
    const date = parseDateString(str);
    if (!date || isNaN(date.getTime())) return str;
    
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    
    return `${year}ë…„ ${month}ì›” ${day}ì¼`;
}

// ë‚ ì§œ ê¸°ê°„ ê²€ìƒ‰
function doDateSearch() {
    const fromStr = document.getElementById('dateFrom').value;
    const toStr = document.getElementById('dateTo').value;
    
    if (!fromStr && !toStr) {
        toast('ê²€ìƒ‰í•  ê¸°ê°„ì„ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    
    const fromDate = fromStr ? new Date(fromStr) : null;
    const toDate = toStr ? new Date(toStr) : null;
    
    if (toDate) {
        toDate.setHours(23, 59, 59, 999); // ì¢…ë£Œì¼ ëê¹Œì§€ í¬í•¨
    }
    
    const resultsSection = document.getElementById('searchResultsSection');
    const resultsContainer = document.getElementById('searchResults');
    const countBadge = document.getElementById('searchCountBadge');
    
    // ë°ì´í„° ìˆëŠ” ì‹œíŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸
    const hasData = Object.keys(WB).some(name => WB[name] && WB[name].data && WB[name].data.length > 0);
    if (!hasData) {
        resultsContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--retro-warm-gray);">ê²€ìƒ‰í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ì„ ë¨¼ì € ì—´ì–´ì£¼ì„¸ìš”.</div>';
        resultsSection.style.display = 'block';
        currentSearchResults = [];
        return;
    }
    
    const results = [];
    const maxResults = 500;
    
    // ëª¨ë“  ì‹œíŠ¸ì—ì„œ ë‚ ì§œ ê²€ìƒ‰
    outerLoop:
    for (const sheetName of Object.keys(WB)) {
        const sheet = WB[sheetName];
        if (!sheet || !sheet.data || sheet.data.length === 0) continue;
        
        // ë‚ ì§œ ì—´ ì°¾ê¸° (ë” ë§ì€ íŒ¨í„´ ì§€ì›)
        const dateColIdx = sheet.headers.findIndex(h => {
            if (!h) return false;
            const lowerH = h.toLowerCase();
            return h.includes('ë‚ ì§œ') || h.includes('ì¼ì') || h.includes('ì¼ì‹œ') ||
                   h === 'ì‘ì„±ì¼' || h === 'ì£¼ë¬¸ë‚ ì§œ' || h === 'ì…ê¸ˆì¼' || h === 'í™˜ë¶ˆì¼' ||
                   h === 'ì‹ ì²­ì¼' || h === 'ì²˜ë¦¬ì¼' || h === 'ë“±ë¡ì¼' || h === 'ìˆ˜ì •ì¼' ||
                   lowerH.includes('date') || lowerH === 'created' || lowerH === 'updated';
        });
        
        if (dateColIdx < 0) continue; // ë‚ ì§œ ì—´ ì—†ìœ¼ë©´ ìŠ¤í‚µ
        
        for (let i = 0; i < sheet.data.length; i++) {
            const row = sheet.data[i];
            if (!row) continue;
            
            const cellValue = String(row[dateColIdx] || '');
            const cellDate = parseDateString(cellValue);
            
            if (cellDate) {
                let match = true;
                if (fromDate && cellDate < fromDate) match = false;
                if (toDate && cellDate > toDate) match = false;
                
                if (match) {
                    results.push({
                        sheet: sheetName,
                        rowIdx: i,
                        headers: sheet.headers,
                        rowData: row  // ì›ë³¸ ì°¸ì¡° (ì½ê¸° ì „ìš©)
                    });
                    if (results.length >= maxResults) break outerLoop;
                }
            }
        }
    }
    
    currentSearchResults = results;
    
    // ê²°ê³¼ í‘œì‹œ
    const fromDisplay = fromStr || 'ì²˜ìŒ';
    const toDisplay = toStr || 'ë';
    countBadge.textContent = results.length + (results.length >= maxResults ? '+' : '') + 'ê±´';
    
    if (results.length === 0) {
        resultsContainer.innerHTML = `<div style="padding:20px;text-align:center;color:var(--retro-warm-gray);">${fromDisplay} ~ ${toDisplay} ê¸°ê°„ì— í•´ë‹¹í•˜ëŠ” ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>`;
    } else {
        renderSearchResults('');
    }
    
    resultsSection.style.display = 'block';
    
    // í‚¤ì›Œë“œ ê²€ìƒ‰ì°½ ì´ˆê¸°í™”
    document.getElementById('mainSearchInput').value = '';
}

function doMainSearch() {
    const keyword = document.getElementById('mainSearchInput').value.trim();
    const resultsSection = document.getElementById('searchResultsSection');
    const resultsContainer = document.getElementById('searchResults');
    const countBadge = document.getElementById('searchCountBadge');
    
    // ë‚ ì§œ í•„í„° í™•ì¸
    const fromStr = document.getElementById('dateFrom')?.value?.trim() || '';
    const toStr = document.getElementById('dateTo')?.value?.trim() || '';
    const hasDateFilter = fromStr.length > 0 || toStr.length > 0;
    
    // í‚¤ì›Œë“œë„ ì—†ê³  ë‚ ì§œ í•„í„°ë„ ì—†ìœ¼ë©´ ê²€ìƒ‰ ì•ˆí•¨
    if (!keyword && !hasDateFilter) {
        resultsSection.style.display = 'none';
        currentSearchResults = [];
        return;
    }
    
    // í‚¤ì›Œë“œë§Œ ìˆê³  2ê¸€ì ë¯¸ë§Œì´ë©´ ì•ˆë‚´
    if (keyword && keyword.length < 2 && !hasDateFilter) {
        resultsContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--retro-warm-gray);">2ê¸€ì ì´ìƒ ì…ë ¥í•˜ì„¸ìš”</div>';
        resultsSection.style.display = 'block';
        currentSearchResults = [];
        return;
    }
    
    // ë°ì´í„° ìˆëŠ” ì‹œíŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸
    const hasData = Object.keys(WB).some(name => WB[name] && WB[name].data && WB[name].data.length > 0);
    if (!hasData) {
        resultsContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--retro-warm-gray);">ê²€ìƒ‰í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ì„ ë¨¼ì € ì—´ì–´ì£¼ì„¸ìš”.</div>';
        resultsSection.style.display = 'block';
        currentSearchResults = [];
        return;
    }
    
    // ëŒ€ìš©ëŸ‰ íŒŒì¼ ê²€ìƒ‰ ì‹œ ë¡œë”© í‘œì‹œ
    const totalDataRows = Object.values(WB).reduce((sum, sheet) => sum + (sheet.data ? sheet.data.length : 0), 0);
    if (totalDataRows > 50000) {
        resultsContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--retro-teal);">ëŒ€ìš©ëŸ‰ ë°ì´í„° ê²€ìƒ‰ ì¤‘...</div>';
    }
    
    // ë¹„ë™ê¸° ê²€ìƒ‰ ì‹¤í–‰
    setTimeout(() => {
        performSearchAsync(keyword, resultsSection, resultsContainer, countBadge);
    }, 10);
}

function performSearchAsync(keyword, resultsSection, resultsContainer, countBadge) {
    const results = [];
    const fileResults = []; // íŒŒì¼ ë³´ê´€í•¨ ê²€ìƒ‰ ê²°ê³¼
    const keywordLower = keyword.toLowerCase();
    const maxResults = isLargeFile ? 1000 : 500;
    
    // ë‚ ì§œ í•„í„° í™•ì¸
    const fromStr = document.getElementById('dateFrom').value;
    const toStr = document.getElementById('dateTo').value;
    const fromDate = fromStr ? new Date(fromStr) : null;
    const toDate = toStr ? new Date(toStr) : null;
    if (toDate) toDate.setHours(23, 59, 59, 999);
    const hasDateFilter = fromDate || toDate;
    
    // ëª¨ë“  ì‹œíŠ¸ì—ì„œ ê²€ìƒ‰
    outerLoop:
    for (const sheetName of Object.keys(WB)) {
        const sheet = WB[sheetName];
        if (!sheet || !sheet.data || sheet.data.length === 0) continue;
        
        // ë‚ ì§œ ì—´ ì°¾ê¸° (ë‚ ì§œ í•„í„°ê°€ ìˆì„ ë•Œë§Œ)
        let dateColIdx = -1;
        if (hasDateFilter) {
            dateColIdx = sheet.headers.findIndex(h => {
                if (!h) return false;
                const lowerH = h.toLowerCase();
                return h.includes('ë‚ ì§œ') || h.includes('ì¼ì') || h.includes('ì¼ì‹œ') ||
                       h === 'ì‘ì„±ì¼' || h === 'ì£¼ë¬¸ë‚ ì§œ' || h === 'ì…ê¸ˆì¼' || h === 'í™˜ë¶ˆì¼' ||
                       h === 'ì‹ ì²­ì¼' || h === 'ì²˜ë¦¬ì¼' || h === 'ë“±ë¡ì¼' || h === 'ìˆ˜ì •ì¼' ||
                       lowerH.includes('date') || lowerH === 'created' || lowerH === 'updated';
            });
        }
        
        const data = sheet.data;
        const len = data.length;
        
        for (let i = 0; i < len; i++) {
            const row = data[i];
            if (!row) continue;
            
            // ë‚ ì§œ í•„í„° ì ìš©
            if (hasDateFilter && dateColIdx >= 0) {
                const cellValue = String(row[dateColIdx] || '');
                const cellDate = parseDateString(cellValue);
                if (cellDate) {
                    if (fromDate && cellDate < fromDate) continue;
                    if (toDate && cellDate > toDate) continue;
                } else {
                    continue; // ë‚ ì§œ íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì œì™¸
                }
            }
            
            // í‚¤ì›Œë“œ ê²€ìƒ‰ (í‚¤ì›Œë“œê°€ ìˆì„ ë•Œë§Œ)
            if (keyword) {
                const rowLen = row.length;
                let found = false;
                for (let j = 0; j < rowLen; j++) {
                    const cellValue = row[j];
                    if (cellValue != null && String(cellValue).toLowerCase().includes(keywordLower)) {
                        found = true;
                        break;
                    }
                }
                if (!found) continue;
            }
            
            results.push({
                sheet: sheetName,
                rowIdx: i,
                headers: sheet.headers,
                rowData: row  // ì›ë³¸ ì°¸ì¡° (ì½ê¸° ì „ìš©ì´ë¯€ë¡œ ë³µì‚¬ ë¶ˆí•„ìš”)
            });
            if (results.length >= maxResults) break outerLoop;
        }
    }
    
    // íŒŒì¼ ë³´ê´€í•¨ TXT ê²€ìƒ‰ (í‚¤ì›Œë“œê°€ ìˆì„ ë•Œë§Œ, ë‚ ì§œ í•„í„° ì—†ì„ ë•Œ)
    if (keyword && !hasDateFilter) {
        for (const file of fileStorage) {
            if (file.textContent && file.textContent.toLowerCase().includes(keywordLower)) {
                // ë§¤ì¹­ëœ ë¶€ë¶„ ì°¾ê¸°
                const content = file.textContent;
                const idx = content.toLowerCase().indexOf(keywordLower);
                const start = Math.max(0, idx - 50);
                const end = Math.min(content.length, idx + keyword.length + 50);
                const preview = (start > 0 ? '...' : '') + content.substring(start, end) + (end < content.length ? '...' : '');
                
                fileResults.push({
                    type: 'file',
                    file: file,
                    preview: preview,
                    matchIndex: idx
                });
            }
        }
    }
    
    currentSearchResults = results;
    currentFileSearchResults = fileResults;
    currentSearchKeyword = keyword;
    
    const totalCount = results.length + fileResults.length;
    countBadge.textContent = totalCount + (results.length >= maxResults ? '+' : '') + 'ê±´';
    
    // ê²€ìƒ‰ ê²°ê³¼ê°€ ìˆì„ ë•Œë§Œ ë©”ì¸ ì˜ì—­ì— í‘œì‹œ
    if (totalCount > 0) {
        showSearchResultsMain(keyword, totalCount, results.length >= maxResults);
    } else {
        // ê²°ê³¼ ì—†ìœ¼ë©´ ì‚¬ì´ë“œë°”ì—ì„œ ì•ˆë‚´ë§Œ í‘œì‹œ
        resultsContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--retro-warm-gray);">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
        resultsSection.style.display = 'block';
    }
}

function renderSearchResults(keyword) {
    const resultsContainer = document.getElementById('searchResults');
    
    if (currentSearchResults.length === 0 && currentFileSearchResults.length === 0) {
        resultsContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--retro-warm-gray);">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
        return;
    }
    
    let html = '';
    
    // íŒŒì¼ ê²€ìƒ‰ ê²°ê³¼ ë¨¼ì € í‘œì‹œ
    if (currentFileSearchResults.length > 0) {
        html += '<div class="file-search-results" style="margin-bottom:15px;padding:10px;background:var(--retro-lavender);border-radius:8px;">';
        html += '<div style="font-weight:bold;margin-bottom:8px;color:var(--retro-charcoal);">ğŸ“ íŒŒì¼ ë³´ê´€í•¨ (' + currentFileSearchResults.length + 'ê±´)</div>';
        
        for (const result of currentFileSearchResults) {
            const file = result.file;
            const safeFileId = (file.id || '').replace(/'/g, "\\'");
            html += `<div class="file-search-item" style="padding:8px;margin:4px 0;background:white;border-radius:4px;cursor:pointer;" onclick="openFileFromSearch('${safeFileId}')">
                <div style="font-weight:bold;">${getFileIcon(file.type)} ${escHtml(file.name)}</div>
                <div style="font-size:11px;color:var(--retro-warm-gray);margin-top:4px;">${escHtml(result.preview)}</div>
            </div>`;
        }
        html += '</div>';
    }
    
    // ì‹œíŠ¸ ê²€ìƒ‰ ê²°ê³¼
    if (currentSearchResults.length > 0) {
        if (searchViewMode === VIEW_MODE.TABLE) {
            resultsContainer.innerHTML = html;
            renderSearchTable(keyword);
            return;
        } else {
            html += renderSearchListHtml(keyword);
        }
    }
    
    resultsContainer.innerHTML = html;
}

// íŒŒì¼ ê²€ìƒ‰ ê²°ê³¼ì—ì„œ íŒŒì¼ ì—´ê¸°
function openFileFromSearch(fileId) {
    const file = fileStorage.find(f => f.id === fileId);
    if (file) {
        currentViewerFile = file;
        showFileViewer(file);
    }
}

function renderSearchListHtml(keyword) {
    let html = '';
    const maxDisplay = Math.min(currentSearchResults.length, 100);
    
    for (let i = 0; i < maxDisplay; i++) {
        const r = currentSearchResults[i];
        // COL_ORDER ì ìš©í•˜ì—¬ ë¯¸ë¦¬ë³´ê¸° ìƒì„±
        const colOrder = COL_ORDER[r.sheet] || r.headers.map((_, idx) => idx);
        const hiddenCols = HIDDEN_COLS[r.sheet] || new Set();
        const visibleCols = colOrder.filter(idx => !hiddenCols.has(idx));
        const previewData = visibleCols.slice(0, 4).map(idx => r.rowData[idx] || '');
        const preview = previewData.join(' | ');
        const highlighted = escHtml(preview).replace(
            new RegExp(escapeRegExp(keyword), 'gi'),
            '<mark>$&</mark>'
        );
        html += `
            <div class="search-result-item" onclick="openDetailModal(${i})">
                <span class="search-result-sheet">${r.sheet}</span>
                <span class="search-result-content">${highlighted}</span>
                <span class="search-result-row">${r.rowIdx + 2}í–‰</span>
            </div>`;
    }
    
    if (currentSearchResults.length > 100) {
        html += `<div style="padding:10px;text-align:center;color:var(--retro-warm-gray);font-size:11px;">í‘œ ë³´ê¸°ë¡œ ì „í™˜í•˜ë©´ ë” ë§ì€ ê²°ê³¼ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤</div>`;
    }
    
    return html;
}

function renderSearchList(keyword) {
    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = renderSearchListHtml(keyword);
}

function renderSearchTable(keyword) {
    const resultsContainer = document.getElementById('searchResults');
    
    // ì‹œíŠ¸ë³„ë¡œ ê·¸ë£¹í™”
    const sheetGroups = {};
    currentSearchResults.forEach(r => {
        if (!sheetGroups[r.sheet]) {
            sheetGroups[r.sheet] = {
                headers: r.headers,
                rows: []
            };
        }
        sheetGroups[r.sheet].rows.push(r);
    });
    
    const sheetNames = Object.keys(sheetGroups);
    
    // í˜„ì¬ ì„ íƒëœ ì‹œíŠ¸ (ì—†ìœ¼ë©´ ì²«ë²ˆì§¸)
    if (!currentSearchSheet || !sheetGroups[currentSearchSheet]) {
        currentSearchSheet = sheetNames[0];
    }
    
    // ì‹œíŠ¸ íƒ­ ìƒì„±
    let html = '<div class="search-sheet-tabs">';
    sheetNames.forEach(name => {
        const count = sheetGroups[name].rows.length;
        const isActive = name === currentSearchSheet;
        html += `<button class="search-sheet-tab${isActive ? ' active' : ''}" onclick="selectSearchSheet('${name.replace(/'/g, "\\'")}')">${escHtml(name)} <span class="tab-count">${count}</span></button>`;
    });
    html += '</div>';
    
    // ì„ íƒëœ ì‹œíŠ¸ í…Œì´ë¸” - COL_ORDER ì ìš©
    const group = sheetGroups[currentSearchSheet];
    if (group) {
        const colOrder = COL_ORDER[currentSearchSheet] || group.headers.map((_, i) => i);
        const hiddenCols = HIDDEN_COLS[currentSearchSheet] || new Set();
        const visibleCols = colOrder.filter(idx => !hiddenCols.has(idx));
        
        html += `<table class="search-table"><thead><tr>`;
        html += '<th>í–‰</th>';
        visibleCols.forEach(colIdx => {
            html += `<th>${escHtml(group.headers[colIdx] || '')}</th>`;
        });
        html += '</tr></thead><tbody>';
        
        group.rows.forEach(r => {
            html += `<tr onclick="goToSearchResult('${r.sheet}', ${r.rowIdx})">`;
            html += `<td class="row-col">${r.rowIdx + 2}</td>`;
            
            visibleCols.forEach(colIdx => {
                let cellValue = r.rowData[colIdx] !== undefined ? String(r.rowData[colIdx]) : '';
                let displayValue = escHtml(cellValue);
                
                // ê²€ìƒ‰ì–´ í•˜ì´ë¼ì´íŠ¸
                if (keyword && cellValue.toLowerCase().includes(keyword.toLowerCase())) {
                    displayValue = displayValue.replace(
                        new RegExp(escapeRegExp(keyword), 'gi'),
                        '<mark>$&</mark>'
                    );
                }
                html += `<td>${displayValue}</td>`;
            });
            html += '</tr>';
        });
        
        html += '</tbody></table>';
    }
    
    resultsContainer.innerHTML = html;
}

let currentSearchSheet = '';

function selectSearchSheet(name) {
    currentSearchSheet = name;
    const keyword = document.getElementById('mainSearchInput').value.trim();
    renderSearchTable(keyword);
}

function setSearchView(mode) {
    searchViewMode = mode;
    document.getElementById('listViewBtn')?.classList.toggle('active', mode === 'list');
    document.getElementById('tableViewBtn')?.classList.toggle('active', mode === 'table');

    const keyword = document.getElementById('mainSearchInput')?.value?.trim() || '';
    renderSearchResults(keyword);
}

// ===== ë©”ì¸ ê²€ìƒ‰ ê²°ê³¼ í™”ë©´ í•¨ìˆ˜ =====

// ë©”ì¸ ê²€ìƒ‰ ê²°ê³¼ í™”ë©´ í‘œì‹œ
function showSearchResultsMain(keyword, totalCount, hasMore) {
    const mainContainer = document.getElementById('searchResultsMain');
    const spreadsheetContainer = document.getElementById('spreadsheetContainer');
    const mainScreen = document.getElementById('mainScreen');
    const detailScreen = document.getElementById('detailScreen');
    
    // mainScreenì´ ë³´ì´ë©´ detailScreenìœ¼ë¡œ ì „í™˜
    if (mainScreen.style.display !== 'none') {
        mainScreen.style.display = 'none';
        detailScreen.style.display = 'flex';
    }
    
    // ìŠ¤í”„ë ˆë“œì‹œíŠ¸ ìˆ¨ê¸°ê³  ê²€ìƒ‰ ê²°ê³¼ í‘œì‹œ
    spreadsheetContainer.style.display = 'none';
    mainContainer.style.display = 'flex';
    
    // í—¤ë” ì •ë³´ ì—…ë°ì´íŠ¸
    document.getElementById('mainSearchCount').textContent = totalCount + (hasMore ? '+' : '') + 'ê±´';
    document.getElementById('mainSearchKeyword').textContent = keyword ? `"${keyword}"` : '(ë‚ ì§œ í•„í„°)';
    
    // ê²€ìƒ‰ ê²°ê³¼ ë Œë”ë§
    renderSearchResultsMain();
}

// ë©”ì¸ ê²€ìƒ‰ ê²°ê³¼ í™”ë©´ ë‹«ê¸°
function closeSearchResultsMain(returnToMain = false) {
    const mainContainer = document.getElementById('searchResultsMain');
    const spreadsheetContainer = document.getElementById('spreadsheetContainer');
    
    mainContainer.style.display = 'none';
    spreadsheetContainer.style.display = '';
    
    // ì‚¬ì´ë“œë°” ê²€ìƒ‰ ê²°ê³¼ë„ ìˆ¨ê¸°ê¸°
    document.getElementById('searchResultsSection').style.display = 'none';
    
    // mainScreenìœ¼ë¡œ ëŒì•„ê°€ê¸° ì˜µì…˜
    if (returnToMain) {
        document.getElementById('detailScreen').style.display = 'none';
        document.getElementById('mainScreen').style.display = 'flex';
        renderMainScreen();
    }
}

// ë©”ì¸ ê²€ìƒ‰ ë·° ëª¨ë“œ ì „í™˜
function setMainSearchView(mode) {
    mainSearchViewMode = mode;
    renderSearchResultsMain();
}

// ë©”ì¸ ê²€ìƒ‰ ê²°ê³¼ ë Œë”ë§
function renderSearchResultsMain() {
    const tabsContainer = document.getElementById('searchSheetTabs');
    const body = document.getElementById('searchResultsMainBody');
    const keyword = currentSearchKeyword;
    
    if (currentSearchResults.length === 0 && currentFileSearchResults.length === 0) {
        tabsContainer.innerHTML = '';
        body.innerHTML = `
            <div class="search-no-results">
                <div class="search-no-results-icon">ğŸ”</div>
                <div class="search-no-results-text">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>
                <div class="search-no-results-hint">ë‹¤ë¥¸ í‚¤ì›Œë“œë¡œ ê²€ìƒ‰í•´ë³´ì„¸ìš”</div>
            </div>
        `;
        return;
    }
    
    // ì‹œíŠ¸ë³„ ê·¸ë£¹í™”
    const sheetGroups = {};
    currentSearchResults.forEach(r => {
        if (!sheetGroups[r.sheet]) {
            sheetGroups[r.sheet] = {
                headers: r.headers,
                rows: []
            };
        }
        sheetGroups[r.sheet].rows.push(r);
    });
    
    const sheetNames = Object.keys(sheetGroups);
    
    // ì²« ë²ˆì§¸ íƒ­ ì„ íƒ (ë˜ëŠ” ì´ì „ ì„ íƒ ìœ ì§€)
    // íŒŒì¼ ê²°ê³¼ê°€ ìˆê³  activeSearchSheetê°€ '__files__'ë©´ ìœ ì§€
    // ì‹œíŠ¸ ê²°ê³¼ì— activeSearchSheetê°€ ìˆìœ¼ë©´ ìœ ì§€
    // ê·¸ ì™¸ì—ëŠ” ì²« ë²ˆì§¸ ì‹œíŠ¸ ë˜ëŠ” íŒŒì¼ íƒ­ ì„ íƒ
    if (activeSearchSheet === '__files__' && currentFileSearchResults.length > 0) {
        // íŒŒì¼ íƒ­ ìœ ì§€
    } else if (activeSearchSheet && sheetGroups[activeSearchSheet]) {
        // ì‹œíŠ¸ íƒ­ ìœ ì§€
    } else {
        // ìƒˆë¡œ ì„ íƒ: ì‹œíŠ¸ê°€ ìˆìœ¼ë©´ ì²« ë²ˆì§¸ ì‹œíŠ¸, ì—†ìœ¼ë©´ íŒŒì¼ íƒ­
        if (sheetNames.length > 0) {
            activeSearchSheet = sheetNames[0];
        } else if (currentFileSearchResults.length > 0) {
            activeSearchSheet = '__files__';
        } else {
            activeSearchSheet = '';
        }
    }
    
    // ì‹œíŠ¸ íƒ­ ë Œë”ë§
    let tabsHtml = '';
    
    // íŒŒì¼ ê²€ìƒ‰ ê²°ê³¼ íƒ­ (ìˆì„ ê²½ìš°)
    if (currentFileSearchResults.length > 0) {
        const isActive = activeSearchSheet === '__files__';
        tabsHtml += `
            <div class="search-sheet-tab ${isActive ? 'active' : ''}" onclick="switchSearchSheet('__files__')">
                ğŸ“ íŒŒì¼ ë³´ê´€í•¨
                <span class="tab-count">${currentFileSearchResults.length}</span>
            </div>
        `;
    }
    
    // ì‹œíŠ¸ íƒ­ë“¤
    for (const sheetName of sheetNames) {
        const count = sheetGroups[sheetName].rows.length;
        const isActive = activeSearchSheet === sheetName;
        const safeSheetName = sheetName.replace(/'/g, "\\'").replace(/"/g, '\\"');
        tabsHtml += `
            <div class="search-sheet-tab ${isActive ? 'active' : ''}" onclick="switchSearchSheet('${safeSheetName}')">
                ${escHtml(sheetName)}
                <span class="tab-count">${count}</span>
            </div>
        `;
    }
    
    tabsContainer.innerHTML = tabsHtml;
    
    // ë³¸ë¬¸ ë Œë”ë§
    let bodyHtml = '';
    
    if (activeSearchSheet === '__files__') {
        // íŒŒì¼ ê²€ìƒ‰ ê²°ê³¼ í‘œì‹œ
        bodyHtml = renderSearchFileResults(keyword);
    } else if (sheetGroups[activeSearchSheet]) {
        // ì‹œíŠ¸ ê²€ìƒ‰ ê²°ê³¼ í‘œì‹œ (ìŠ¤í”„ë ˆë“œì‹œíŠ¸ í˜•íƒœ)
        bodyHtml = renderSearchSpreadsheet(activeSearchSheet, sheetGroups[activeSearchSheet], keyword);
    }
    
    body.innerHTML = bodyHtml;
    
    // ìƒíƒœ ì—…ë°ì´íŠ¸
    const status = document.getElementById('searchResultsStatus');
    if (status) {
        const sheetCount = sheetNames.length;
        const totalCount = currentSearchResults.length + currentFileSearchResults.length;
        status.textContent = `${sheetCount}ê°œ ì‹œíŠ¸ì—ì„œ ${totalCount}ê±´ ë°œê²¬ â€¢ í´ë¦­í•˜ë©´ í•´ë‹¹ ì…€ë¡œ ì´ë™í•©ë‹ˆë‹¤`;
    }
}

// ê²€ìƒ‰ ê²°ê³¼ ì‹œíŠ¸ íƒ­ ì „í™˜
function switchSearchSheet(sheetName) {
    activeSearchSheet = sheetName;
    renderSearchResultsMain();
}

// íŒŒì¼ ê²€ìƒ‰ ê²°ê³¼ ë Œë”ë§
function renderSearchFileResults(keyword) {
    let html = '<div class="search-file-section">';
    html += `<div class="search-file-section-title">ğŸ“ íŒŒì¼ ë³´ê´€í•¨ <span class="file-count">${currentFileSearchResults.length}ê±´</span></div>`;
    html += '<div class="search-file-grid">';
    
    for (const result of currentFileSearchResults) {
        const file = result.file;
        const safeFileId = (file.id || '').replace(/'/g, "\\'");
        html += `
            <div class="search-file-item" onclick="openFileFromSearch('${safeFileId}')">
                <span class="search-file-item-icon">${getFileIcon(file.type)}</span>
                <span class="search-file-item-name">${escHtml(file.name)}</span>
            </div>
        `;
    }
    
    html += '</div></div>';
    return html;
}

// ìŠ¤í”„ë ˆë“œì‹œíŠ¸ í˜•íƒœë¡œ ê²€ìƒ‰ ê²°ê³¼ ë Œë”ë§
function renderSearchSpreadsheet(sheetName, group, keyword) {
    // COL_ORDER ì ìš© - ì‹œíŠ¸ì˜ ì‹¤ì œ ì»¬ëŸ¼ ìˆœì„œ ê°€ì ¸ì˜¤ê¸°
    const colOrder = COL_ORDER[sheetName] || group.headers.map((_, i) => i);
    const hiddenCols = HIDDEN_COLS[sheetName] || new Set();
    
    // ìˆ¨ê¹€ë˜ì§€ ì•Šì€ ì»¬ëŸ¼ë§Œ í•„í„°ë§
    const visibleCols = colOrder.filter(idx => !hiddenCols.has(idx));
    const maxCols = Math.min(visibleCols.length, 10);
    const displayCols = visibleCols.slice(0, maxCols);
    
    let html = '<table class="search-spreadsheet">';
    
    // í—¤ë” - COL_ORDER ìˆœì„œë¡œ í‘œì‹œ
    html += '<thead><tr>';
    html += '<th>í–‰</th>';
    for (let c = 0; c < displayCols.length; c++) {
        const colIdx = displayCols[c];
        html += `<th>${escHtml(group.headers[colIdx] || '')}</th>`;
    }
    if (visibleCols.length > 10) {
        html += `<th>+${visibleCols.length - 10}</th>`;
    }
    html += '</tr></thead>';
    
    // ë°ì´í„° í–‰ - COL_ORDER ìˆœì„œë¡œ í‘œì‹œ
    html += '<tbody>';
    const safeSheetName = sheetName.replace(/'/g, "\\'").replace(/"/g, '\\"');
    
    for (const r of group.rows) {
        html += `<tr onclick="goToSearchResult('${safeSheetName}', ${r.rowIdx})">`;
        html += `<td>${r.rowIdx + 2}</td>`;
        
        for (let c = 0; c < displayCols.length; c++) {
            const colIdx = displayCols[c];
            const cellValue = String(r.rowData[colIdx] || '');
            let displayValue = escHtml(cellValue);
            if (keyword) {
                displayValue = displayValue.replace(
                    new RegExp(escapeRegExp(keyword), 'gi'),
                    '<mark>$&</mark>'
                );
            }
            html += `<td title="${escHtml(cellValue)}">${displayValue}</td>`;
        }
        
        if (visibleCols.length > 10) {
            html += '<td>...</td>';
        }
        html += '</tr>';
    }
    
    html += '</tbody></table>';
    return html;
}

// ê²€ìƒ‰ ê²°ê³¼ì—ì„œ í•´ë‹¹ ì…€ë¡œ ì´ë™
function goToSearchResult(sheetName, rowIdx) {
    // ê²€ìƒ‰ ê²°ê³¼ í™”ë©´ ë‹«ê¸°
    closeSearchResultsMain();
    
    // ì‹œíŠ¸ ë°ì´í„° í™•ì¸
    const sheet = WB[sheetName];
    if (!sheet) {
        toast('ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    const totalRows = sheet.data.length;
    
    // ì—­ìˆœ í‘œì‹œì´ë¯€ë¡œ í˜ì´ì§€ ê³„ì‚° (ìµœì‹  ë°ì´í„°ê°€ ìœ„ì—)
    // rowIdxê°€ ë³´ì´ë ¤ë©´ ì–´ëŠ í˜ì´ì§€ì— ìˆì–´ì•¼ í•˜ëŠ”ì§€ ê³„ì‚°
    const neededPage = Math.max(0, Math.ceil((totalRows - rowIdx) / PAGE_SIZE) - 1);
    
    // ì‹œíŠ¸ ì „í™˜ (renderSpreadsheet í˜¸ì¶œë¨)
    if (SHEET !== sheetName) {
        SHEET = sheetName;
        SELECTED = null;
        CURRENT_PAGE = neededPage;
        if (!COL_ORDER[sheetName]) {
            COL_ORDER[sheetName] = WB[sheetName].headers.map((_, i) => i);
        }
        if (!HIDDEN_COLS[sheetName]) {
            HIDDEN_COLS[sheetName] = new Set();
        }
        document.getElementById('currentSheetName').textContent = sheetName;
        renderSheetTabs();
        renderSpreadsheet();
    } else if (CURRENT_PAGE !== neededPage) {
        // ê°™ì€ ì‹œíŠ¸ì¸ë° í˜ì´ì§€ë§Œ ë‹¤ë¥¸ ê²½ìš°
        CURRENT_PAGE = neededPage;
        renderSpreadsheet();
    }
    
    // í•´ë‹¹ í–‰ìœ¼ë¡œ ìŠ¤í¬ë¡¤ ë° ì„ íƒ
    setTimeout(() => {
        const table = document.getElementById('spreadsheet');
        if (!table) return;
        
        // í˜„ì¬ í‘œì‹œëœ ë°ì´í„°ì—ì„œ í•´ë‹¹ rowIdxì˜ ìœ„ì¹˜ ê³„ì‚°
        const loadCount = Math.min((CURRENT_PAGE + 1) * PAGE_SIZE, totalRows);
        const startIdx = totalRows - loadCount;
        
        // rowIdxê°€ í˜„ì¬ í˜ì´ì§€ì— ìˆëŠ”ì§€ í™•ì¸
        if (rowIdx < startIdx || rowIdx >= totalRows) {
            toast('í•´ë‹¹ í–‰ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
            return;
        }
        
        // í…Œì´ë¸”ì—ì„œì˜ ì‹¤ì œ í–‰ ë²ˆí˜¸ (í—¤ë” ì œì™¸, 0ë¶€í„° ì‹œì‘)
        const displayRowIdx = rowIdx - startIdx + 1; // +1ì€ í—¤ë” í–‰
        
        const rows = table.querySelectorAll('tr');
        if (rows[displayRowIdx]) {
            rows[displayRowIdx].scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // ì²« ë²ˆì§¸ ì…€ ì„ íƒ
            const firstCell = rows[displayRowIdx].querySelector('td');
            if (firstCell) {
                firstCell.click();
            }
            
            // í•˜ì´ë¼ì´íŠ¸ íš¨ê³¼
            rows[displayRowIdx].style.background = '#fff176';
            setTimeout(() => {
                rows[displayRowIdx].style.background = '';
            }, 2000);
        }
        
        toast(`'${sheetName}' ì‹œíŠ¸ ${rowIdx + 2}í–‰ìœ¼ë¡œ ì´ë™`);
    }, 150);
}

function clearSearchResults() {
    currentSearchResults = [];
    currentFileSearchResults = [];
    currentSearchSheet = '';
    currentSearchKeyword = '';
    activeSearchSheet = '';
    
    // ì‚¬ì´ë“œë°” ê²€ìƒ‰ ê²°ê³¼ ìˆ¨ê¸°ê¸°
    document.getElementById('searchResultsSection').style.display = 'none';
    
    // ë©”ì¸ ê²€ìƒ‰ ê²°ê³¼ í™”ë©´ ë‹«ê¸°
    closeSearchResultsMain();
    
    document.getElementById('mainSearchInput').value = '';
    document.getElementById('dateFrom').value = '';
    document.getElementById('dateTo').value = '';
    toast('ê²€ìƒ‰ ì´ˆê¸°í™”');
}

function downloadSearchResults() {
    if (currentSearchResults.length === 0) {
        toast('ë‹¤ìš´ë¡œë“œí•  ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    // ì‹œíŠ¸ë³„ë¡œ ê·¸ë£¹í™”
    const sheetGroups = {};
    currentSearchResults.forEach(r => {
        if (!sheetGroups[r.sheet]) {
            sheetGroups[r.sheet] = {
                headers: r.headers,
                rows: []
            };
        }
        sheetGroups[r.sheet].rows.push(r);
    });
    
    // ì—‘ì…€ ìƒì„± - ì‹œíŠ¸ë³„ë¡œ (COL_ORDER ì ìš©)
    const wb = XLSX.utils.book_new();
    
    Object.keys(sheetGroups).forEach(sheetName => {
        const group = sheetGroups[sheetName];
        
        // COL_ORDER ì ìš©
        const colOrder = COL_ORDER[sheetName] || group.headers.map((_, i) => i);
        const hiddenCols = HIDDEN_COLS[sheetName] || new Set();
        const visibleCols = colOrder.filter(idx => !hiddenCols.has(idx));
        
        // í—¤ë” ì¬ì •ë ¬
        const orderedHeaders = visibleCols.map(idx => group.headers[idx] || '');
        
        // ë°ì´í„° ì¬ì •ë ¬
        const orderedRows = group.rows.map(r => {
            return visibleCols.map(idx => r.rowData[idx] !== undefined ? r.rowData[idx] : '');
        });
        
        const data = [orderedHeaders, ...orderedRows];
        const ws = XLSX.utils.aoa_to_sheet(data);
        
        // ì‹œíŠ¸ëª… ê¸¸ì´ ì œí•œ (31ì)
        let safeName = sheetName.substring(0, 31);
        XLSX.utils.book_append_sheet(wb, ws, safeName);
    });
    
    const keyword = document.getElementById('mainSearchInput').value.trim();
    const sheetCount = Object.keys(sheetGroups).length;
    const fileName = `ê²€ìƒ‰ê²°ê³¼_${keyword}_${sheetCount}ê°œì‹œíŠ¸_${new Date().toISOString().slice(0,10)}.xlsx`;
    XLSX.writeFile(wb, fileName);
    toast(`ê²€ìƒ‰ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ (${sheetCount}ê°œ ì‹œíŠ¸, ${currentSearchResults.length}ê±´)`);
}

// ê²€ìƒ‰ ê²°ê³¼ ìƒì„¸ ëª¨ë‹¬
let currentDetailIdx = -1;

function openDetailModal(idx) {
    const r = currentSearchResults[idx];
    if (!r) return;
    
    currentDetailIdx = idx;
    const keyword = document.getElementById('mainSearchInput').value.trim();
    
    document.getElementById('detailSheetName').textContent = r.sheet;
    document.getElementById('detailRowNum').textContent = `${r.rowIdx + 2}í–‰`;
    
    // COL_ORDER ì ìš©í•˜ì—¬ ì „ì²´ ë°ì´í„° í‘œì‹œ
    const colOrder = COL_ORDER[r.sheet] || r.headers.map((_, i) => i);
    const hiddenCols = HIDDEN_COLS[r.sheet] || new Set();
    const visibleCols = colOrder.filter(idx => !hiddenCols.has(idx));
    
    let html = '';
    visibleCols.forEach(colIdx => {
        const h = r.headers[colIdx] || '';
        let value = r.rowData[colIdx] !== undefined ? String(r.rowData[colIdx]) : '';
        let displayValue = escHtml(value);
        let isEmpty = !value;
        
        // ê²€ìƒ‰ì–´ í•˜ì´ë¼ì´íŠ¸
        if (keyword && value.toLowerCase().includes(keyword.toLowerCase())) {
            displayValue = displayValue.replace(
                new RegExp(escapeRegExp(keyword), 'gi'),
                '<mark>$&</mark>'
            );
        }
        
        html += `<div class="detail-item">
            <span class="detail-label">${escHtml(h)}</span>
            <span class="detail-value${isEmpty ? ' empty' : ''}">${isEmpty ? '(ë¹ˆê°’)' : displayValue}</span>
        </div>`;
    });
    
    document.getElementById('detailModalBody')?.innerHTML && (document.getElementById('detailModalBody').innerHTML = html);
    document.getElementById('detailModal')?.classList.add('show');
}

function closeDetailModal() {
    document.getElementById('detailModal')?.classList.remove('show');
    currentDetailIdx = -1;
}

function goToSheetFromDetail() {
    if (currentDetailIdx < 0) return;
    
    const r = currentSearchResults[currentDetailIdx];
    if (!r) return;
    
    closeDetailModal();
    goToSearchResult(r.sheet, r.rowIdx);
}

function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// í‚¤ ì»¬ëŸ¼ ì°¾ê¸° (ê³„ì¢Œë²ˆí˜¸, ì£¼ë¬¸ë²ˆí˜¸, ì „í™”ë²ˆí˜¸ ë“±)
function findKeyColumn(headers) {
    const keyPatterns = ['ê³„ì¢Œ', 'ì£¼ë¬¸ë²ˆí˜¸', 'ì „í™”ë²ˆí˜¸', 'ì—°ë½ì²˜', 'ê³ ê°ëª…', 'ì˜ˆê¸ˆì£¼', 'ì„±í•¨', 'ì´ë¦„'];
    for (const pattern of keyPatterns) {
        const idx = headers.findIndex(h => h && h.includes(pattern));
        if (idx >= 0) return idx;
    }
    return -1;
}

// ë‘ í–‰ì˜ ì°¨ì´ì  ì°¾ê¸°
function findDifferences(oldRow, newRow, headers) {
    const diffs = [];
    for (let i = 0; i < headers.length; i++) {
        const oldVal = String(oldRow[i] || '').trim();
        const newVal = String(newRow[i] || '').trim();
        if (oldVal !== newVal) {
            diffs.push({
                colIdx: i,
                header: headers[i],
                oldVal: oldVal,
                newVal: newVal
            });
        }
    }
    return diffs;
}

// ë³€ê²½ ì˜ì‹¬ ê±´ ë Œë”ë§
function renderPendingChanges() {
    const section = document.getElementById('pendingChangesSection');
    const list = document.getElementById('pendingChangesList');
    const badge = document.getElementById('pendingCountBadge');
    
    if (PENDING_CHANGES.length === 0) {
        section.style.display = 'none';
        return;
    }
    
    section.style.display = 'block';
    badge.textContent = PENDING_CHANGES.length + 'ê±´';
    
    let html = '';
    PENDING_CHANGES.forEach((item, idx) => {
        const keyHeader = item.headers[item.keyCol] || '';
        const keyValue = item.oldRow[item.keyCol] || '';
        
        html += `<div class="pending-item">
            <div class="pending-header">
                <div>
                    <span class="pending-sheet">${item.sheet}</span>
                    <span style="margin-left:8px;font-size:12px;color:var(--retro-charcoal);">${keyHeader}: ${keyValue}</span>
                </div>
                <div class="pending-actions">
                    <button class="pending-btn apply" onclick="applyChange(${idx})">ì ìš©</button>
                    <button class="pending-btn skip" onclick="skipChange(${idx})">ë¬´ì‹œ</button>
                </div>
            </div>
            <div class="pending-compare">`;
        
        item.diffs.forEach(diff => {
            html += `<div class="pending-row">
                <span class="pending-label">${diff.header}</span>
                <span class="pending-old">${escHtml(diff.oldVal) || '(ë¹ˆê°’)'}</span>
                <span class="pending-new">${escHtml(diff.newVal) || '(ë¹ˆê°’)'}</span>
            </div>`;
        });
        
        html += `</div></div>`;
    });
    
    list.innerHTML = html;
}

// ë³€ê²½ ì ìš©
function applyChange(idx) {
    const item = PENDING_CHANGES[idx];
    if (!item) return;
    
    const sheet = WB[item.sheet];
    if (sheet && sheet.data[item.rowIdx]) {
        // ê¸°ì¡´ í–‰ì„ ìƒˆ í–‰ìœ¼ë¡œ êµì²´
        sheet.data[item.rowIdx] = item.newRow;
        toast(`${item.sheet} ì‹œíŠ¸ ${item.rowIdx + 2}í–‰ ë³€ê²½ ì ìš©`);
    }
    
    // ëª©ë¡ì—ì„œ ì œê±°
    PENDING_CHANGES.splice(idx, 1);
    renderPendingChanges();
    renderMainScreen();
}

// ë³€ê²½ ë¬´ì‹œ
function skipChange(idx) {
    PENDING_CHANGES.splice(idx, 1);
    renderPendingChanges();
    toast('ë³€ê²½ ë¬´ì‹œë¨');
}

// ëª¨ë“  ë³€ê²½ ì ìš©
function applyAllChanges() {
    let count = 0;
    PENDING_CHANGES.forEach(item => {
        const sheet = WB[item.sheet];
        if (sheet && sheet.data[item.rowIdx]) {
            sheet.data[item.rowIdx] = item.newRow;
            count++;
        }
    });
    PENDING_CHANGES = [];
    renderPendingChanges();
    renderMainScreen();
    toast(`${count}ê±´ ë³€ê²½ ì ìš© ì™„ë£Œ`);
}

// ëª¨ë“  ë³€ê²½ ë¬´ì‹œ
function skipAllChanges() {
    const count = PENDING_CHANGES.length;
    PENDING_CHANGES = [];
    renderPendingChanges();
    toast(`${count}ê±´ ë³€ê²½ ë¬´ì‹œë¨`);
}

// ì‹ ê·œ ì¶”ê°€ ê±´ ë Œë”ë§
function renderPendingAdditions() {
    const section = document.getElementById('pendingAdditionsSection');
    const list = document.getElementById('pendingAdditionsList');
    const badge = document.getElementById('additionsCountBadge');
    
    if (PENDING_ADDITIONS.length === 0) {
        section.style.display = 'none';
        return;
    }
    
    section.style.display = 'block';
    badge.textContent = PENDING_ADDITIONS.length + 'ê±´';
    
    let html = '';
    const maxDisplay = Math.min(PENDING_ADDITIONS.length, 50); // ìµœëŒ€ 50ê±´ í‘œì‹œ
    
    for (let i = 0; i < maxDisplay; i++) {
        const item = PENDING_ADDITIONS[i];
        const preview = item.row.slice(0, 5).join(' | ');
        
        html += `<div class="addition-item">
            <span class="addition-sheet">${item.sheet}</span>
            <span class="addition-content">${escHtml(preview)}</span>
            <div class="addition-actions">
                <button class="pending-btn apply" onclick="applyAddition(${i})">ì ìš©</button>
                <button class="pending-btn skip" onclick="skipAddition(${i})">ë¬´ì‹œ</button>
            </div>
        </div>`;
    }
    
    if (PENDING_ADDITIONS.length > 50) {
        html += `<div style="padding:10px;text-align:center;color:var(--retro-warm-gray);font-size:11px;">... ì™¸ ${PENDING_ADDITIONS.length - 50}ê±´ ë” ìˆìŒ</div>`;
    }
    
    list.innerHTML = html;
}

// ê°œë³„ ì‹ ê·œ ì¶”ê°€ ì ìš©
function applyAddition(idx) {
    const item = PENDING_ADDITIONS[idx];
    if (!item) return;
    
    const sheet = WB[item.sheet];
    if (sheet) {
        sheet.data.push(item.row);
        toast(`${item.sheet} ì‹œíŠ¸ì— 1ê±´ ì¶”ê°€`);
    }
    
    PENDING_ADDITIONS.splice(idx, 1);
    renderPendingAdditions();
    renderMainScreen();
}

// ê°œë³„ ì‹ ê·œ ì¶”ê°€ ë¬´ì‹œ
function skipAddition(idx) {
    PENDING_ADDITIONS.splice(idx, 1);
    renderPendingAdditions();
    toast('ì‹ ê·œ ê±´ ë¬´ì‹œë¨');
}

// ëª¨ë“  ì‹ ê·œ ì¶”ê°€ ì ìš©
function applyAllAdditions() {
    let count = 0;
    const sheetCounts = {};
    
    PENDING_ADDITIONS.forEach(item => {
        const sheet = WB[item.sheet];
        if (sheet) {
            sheet.data.push(item.row);
            sheetCounts[item.sheet] = (sheetCounts[item.sheet] || 0) + 1;
            count++;
        }
    });
    
    PENDING_ADDITIONS = [];
    renderPendingAdditions();
    renderMainScreen();
    
    // ì‹œíŠ¸ë³„ ì¶”ê°€ ê±´ìˆ˜ ë©”ì‹œì§€
    const details = Object.entries(sheetCounts).map(([s, c]) => `${s}: ${c}ê±´`).join(', ');
    toast(`${count}ê±´ ì¶”ê°€ ì™„ë£Œ (${details})`);
}

// ëª¨ë“  ì‹ ê·œ ì¶”ê°€ ë¬´ì‹œ
function skipAllAdditions() {
    const count = PENDING_ADDITIONS.length;
    PENDING_ADDITIONS = [];
    renderPendingAdditions();
    toast(`${count}ê±´ ì‹ ê·œ ë¬´ì‹œë¨`);
}

function initDefaultSheets() {
    // ë¹ˆ ì‹œíŠ¸ ìë™ ìƒì„± ì œê±° - íŒŒì¼ ì—…ë¡œë“œ ì‹œ ìë™ìœ¼ë¡œ ì‹œíŠ¸ê°€ ìƒì„±ë¨
    SHEET = '';
}

function initDates() {
    const today = new Date();
    document.getElementById('workDate').value = today.toISOString().slice(0,10);
}

function setupEventListeners() {
    document.getElementById('fileInput').addEventListener('change', handleUpload);
    document.getElementById('mainFileInput').addEventListener('change', handleDocumentUpload);
    document.getElementById('formulaInput').addEventListener('keydown', e => {
        if (e.key === 'Enter') { applyFormulaInput(); e.preventDefault(); }
    });
    document.getElementById('formulaInput').addEventListener('blur', applyFormulaInput);
    document.addEventListener('keydown', handleKeydown);
    document.addEventListener('click', () => {
        document.getElementById('contextMenu')?.classList.remove('show');
        document.getElementById('colContextMenu')?.classList.remove('show');
        document.getElementById('rowContextMenu')?.classList.remove('show');
    });
    
    // ì—´/í–‰ í¬ê¸° ì¡°ì ˆ ì´ë²¤íŠ¸ ì„¤ì •
    setupResizeEvents();
    
    const table = document.getElementById('spreadsheet');
    table.addEventListener('click', e => {
        // ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œì—ì„œëŠ” í´ë¦­ ë¬´ì‹œ
        if (RESIZE_MODE) return;
        
        const isShift = e.shiftKey;
        const cell = e.target.closest('td.cell');
        if (cell) { 
            if (isShift && SELECTION_START) {
                extendSelection(+cell.dataset.row, +cell.dataset.col);
            } else {
                selectCell(+cell.dataset.row, +cell.dataset.col); 
            }
            return; 
        }
        const rh = e.target.closest('.row-header');
        if (rh) { 
            if (isShift && SELECTION_START) {
                extendRowSelection(+rh.dataset.row);
            } else {
                selectRow(+rh.dataset.row); 
            }
            return; 
        }
        const ch = e.target.closest('.col-header');
        if (ch) { 
            if (isShift && SELECTION_START) {
                extendColSelection(+ch.dataset.col);
            } else {
                selectCol(+ch.dataset.col); 
            }
        }
    });
    table.addEventListener('dblclick', e => {
        if (COPY_MODE) return; // ë³µì‚¬ ëª¨ë“œë©´ í¸ì§‘ ì•ˆí•¨
        const cell = e.target.closest('td.cell');
        if (cell) startEdit(+cell.dataset.row, +cell.dataset.col);
    });
    table.addEventListener('contextmenu', e => {
        const cell = e.target.closest('td.cell');
        if (cell) { e.preventDefault(); showCellContextMenu(e, +cell.dataset.row, +cell.dataset.col); return; }
        const rh = e.target.closest('.row-header');
        if (rh) { e.preventDefault(); showRowContextMenu(e, +rh.dataset.row); return; }
        const ch = e.target.closest('.col-header');
        if (ch) { e.preventDefault(); showColContextMenu(e, +ch.dataset.col); }
    });
    
    // ì—´ ë“œë˜ê·¸ ì´ë²¤íŠ¸
    table.addEventListener('dragstart', e => {
        // ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œì—ì„œëŠ” ë“œë˜ê·¸ ì·¨ì†Œ
        if (RESIZE_MODE) {
            e.preventDefault();
            return;
        }
        
        const ch = e.target.closest('.col-header');
        if (ch) {
            e.dataTransfer.setData('text/plain', ch.dataset.col);
            ch.classList.add('dragging');
        }
    });
    table.addEventListener('dragend', e => {
        const ch = e.target.closest('.col-header');
        if (ch) ch.classList.remove('dragging');
        document.querySelectorAll('.col-header.drag-over').forEach(el => el.classList.remove('drag-over'));
    });
    table.addEventListener('dragover', e => {
        const ch = e.target.closest('.col-header');
        if (ch) {
            e.preventDefault();
            document.querySelectorAll('.col-header.drag-over').forEach(el => el.classList.remove('drag-over'));
            ch.classList.add('drag-over');
        }
    });
    table.addEventListener('drop', e => {
        const ch = e.target.closest('.col-header');
        if (ch) {
            e.preventDefault();
            const fromCol = +e.dataTransfer.getData('text/plain');
            const toCol = +ch.dataset.col;
            if (fromCol !== toCol) {
                moveColumn(fromCol, toCol);
            }
            document.querySelectorAll('.col-header.drag-over').forEach(el => el.classList.remove('drag-over'));
        }
    });
    
    // ë©”ì¸ í™”ë©´ ë¹ˆ ê³µê°„ ìš°í´ë¦­ ì´ë²¤íŠ¸
    setupMainScreenContextMenu();
}

// ë©”ì¸ í™”ë©´ ë¹ˆ ê³µê°„ ìš°í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì„¤ì •
function setupMainScreenContextMenu() {
    const mainContent = document.querySelector('.main-content');
    if (!mainContent) return;
    
    mainContent.addEventListener('contextmenu', e => {
        // ì‹œíŠ¸ ì¹´ë“œë‚˜ í´ë” ì¹´ë“œ ìœ„ì—ì„œëŠ” ê¸°ì¡´ ë©”ë‰´ ì‚¬ìš©
        if (e.target.closest('.sheet-card') || e.target.closest('.folder-card')) {
            return;
        }
        
        // ë¹ˆ ê³µê°„ì—ì„œë§Œ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ
        e.preventDefault();
        showMainContextMenu(e);
    });
    
    // í´ë¦­ ì‹œ ë©”ì¸ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ë‹«ê¸°
    document.addEventListener('click', () => {
        const menu = document.getElementById('mainContextMenu');
        if (menu) menu.classList.remove('show');
    });
}

// ë©”ì¸ í™”ë©´ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ
function showMainContextMenu(e) {
    const menu = document.getElementById('mainContextMenu');
    if (!menu) return;
    
    // ë‹¤ë¥¸ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ë‹«ê¸°
    document.querySelectorAll('.context-menu').forEach(m => m.classList.remove('show'));
    
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    menu.classList.add('show');
}

// ë©”ì¸ í™”ë©´ ìƒˆë¡œê³ ì¹¨
function refreshMainScreen() {
    const menu = document.getElementById('mainContextMenu');
    if (menu) menu.classList.remove('show');
    
    renderMainScreen();
    toast('ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ');
}

// ë©”ì¸ í™”ë©´ í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì„¤ì •
let mainScreenKeyboardInitialized = false;
function setupMainScreenKeyboard() {
    if (mainScreenKeyboardInitialized) return;
    mainScreenKeyboardInitialized = true;
    document.addEventListener('keydown', handleMainScreenKeydown);
}

// ë©”ì¸ í™”ë©´ í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
function handleMainScreenKeydown(e) {
    // ë©”ì¸ í™”ë©´ì´ ë³´ì´ëŠ” ìƒíƒœì—ì„œë§Œ ì‘ë™
    const mainScreen = document.getElementById('mainScreen');
    if (!mainScreen || mainScreen.style.display === 'none') return;
    
    // ì…ë ¥ ì¤‘ì´ë©´ ë¬´ì‹œ
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;
    
    // Delete í‚¤: ì„ íƒëœ ì‹œíŠ¸ ì‚­ì œ
    if (e.key === 'Delete') {
        if (multiSelectedSheets.size > 0) {
            e.preventDefault();
            confirmDeleteSelectedSheets();
        }
        return;
    }
    
    // Ctrl+A: ì „ì²´ ì„ íƒ
    if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
        const mainScreen = document.getElementById('mainScreen');
        if (mainScreen && mainScreen.style.display !== 'none') {
            e.preventDefault();
            selectAllSheets();
        }
        return;
    }
    
    // Escape: ì„ íƒ í•´ì œ
    if (e.key === 'Escape') {
        if (multiSelectedSheets.size > 0) {
            e.preventDefault();
            multiSelectedSheets.clear();
            document.querySelectorAll('.sheet-card.multi-selected').forEach(el => {
                el.classList.remove('multi-selected');
            });
            updateMergeActionButton();
            toast('ì„ íƒ í•´ì œë¨');
        }
        return;
    }
}

// ì„ íƒëœ ì‹œíŠ¸ ì‚­ì œ í™•ì¸
function confirmDeleteSelectedSheets() {
    const count = multiSelectedSheets.size;
    if (count === 0) return;
    
    const sheetNames = Array.from(multiSelectedSheets);
    const previewNames = sheetNames.slice(0, 3).join(', ');
    const moreText = count > 3 ? ` ì™¸ ${count - 3}ê°œ` : '';
    
    if (!confirm(`ì„ íƒí•œ ${count}ê°œ ì‹œíŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n${previewNames}${moreText}\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`)) {
        return;
    }
    
    // ì‚­ì œ ì‹¤í–‰
    for (const name of sheetNames) {
        delete WB[name];
        delete COL_ORDER[name];
        delete HIDDEN_COLS[name];
        delete COL_WIDTHS[name];
        delete ROW_HEIGHTS[name];
        delete sheetToFolder[name];
        if (favoriteSheets) favoriteSheets.delete(name);
        if (newSheets) newSheets.delete(name);
    }
    
    saveFolderData(); // í´ë” ë§¤í•‘ ë³€ê²½ ì €ì¥
    
    // ì„ íƒ ì´ˆê¸°í™”
    multiSelectedSheets.clear();
    updateMergeActionButton();
    
    // í˜„ì¬ ì‹œíŠ¸ê°€ ì‚­ì œë˜ì—ˆìœ¼ë©´ ë‹¤ë¥¸ ì‹œíŠ¸ë¡œ ë³€ê²½
    if (!WB[SHEET]) {
        const remaining = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
        SHEET = remaining.length > 0 ? remaining[0] : '';
    }
    
    renderMainScreen();
    toast(`${count}ê°œ ì‹œíŠ¸ ì‚­ì œ ì™„ë£Œ`);
}

// ì „ì²´ ì‹œíŠ¸ ì„ íƒ
function selectAllSheets() {
    const sheetNames = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
    
    multiSelectedSheets.clear();
    sheetNames.forEach(name => multiSelectedSheets.add(name));
    
    document.querySelectorAll('.sheet-card').forEach(card => {
        card.classList.add('multi-selected');
    });
    
    updateMergeActionButton();
    toast(`${sheetNames.length}ê°œ ì‹œíŠ¸ ì „ì²´ ì„ íƒë¨`);
}

async function handleUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    // íŒŒì¼ í¬ê¸° ì²´í¬ (100MB)
    if (file.size > MAX_FILE_SIZE) {
        toast(`íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤ (${(file.size/1024/1024).toFixed(1)}MB). ìµœëŒ€ 100MBê¹Œì§€ ì§€ì›í•©ë‹ˆë‹¤.`);
        e.target.value = '';
        return;
    }
    
    // ëŒ€ìš©ëŸ‰ íŒŒì¼ í”Œë˜ê·¸ ì„¤ì • (50MB ì´ìƒ)
    isLargeFile = file.size > 50 * 1024 * 1024;
    if (isLargeFile) {
        console.log('ëŒ€ìš©ëŸ‰ íŒŒì¼ ëª¨ë“œ í™œì„±í™”');
        startMemoryManagement();
    }
    
    const sizeMB = (file.size / 1024 / 1024).toFixed(1);
    const fileName = file.name.toLowerCase();
    
    showLoading(`íŒŒì¼ ì½ëŠ” ì¤‘... (${sizeMB}MB)`);
    
    try {
        // í…ìŠ¤íŠ¸ íŒŒì¼ ì²˜ë¦¬ (.csv, .tsv, .txt)
        if (fileName.endsWith('.csv') || fileName.endsWith('.tsv') || fileName.endsWith('.txt')) {
            const text = await readFileAsText(file);
            updateLoadingText('í…ìŠ¤íŠ¸ ë°ì´í„° ë¶„ì„ ì¤‘...');
            await parseTextFile(text, file.name);
        } else {
            // ì—‘ì…€ íŒŒì¼ ì²˜ë¦¬
            const data = await readFile(file);
            updateLoadingText('ë°ì´í„° ë¶„ì„ ì¤‘...');
            await parseExcelOptimized(data);
        }
        hideLoading();
        saveToLocalStorage(); // ë¡œì»¬ ì €ì¥ì†Œì— ì €ì¥
        toast('íŒŒì¼ ë¡œë“œ ì™„ë£Œ!');
    } catch (err) {
        console.error(err);
        hideLoading();
        toast('íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜');
    }
    e.target.value = '';
}

async function handleMainUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    // íŒŒì¼ í¬ê¸° ì²´í¬ (100MB)
    if (file.size > MAX_FILE_SIZE) {
        toast(`íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤ (${(file.size/1024/1024).toFixed(1)}MB). ìµœëŒ€ 100MBê¹Œì§€ ì§€ì›í•©ë‹ˆë‹¤.`);
        e.target.value = '';
        return;
    }
    
    // ëŒ€ìš©ëŸ‰ íŒŒì¼ í”Œë˜ê·¸ ì„¤ì • (50MB ì´ìƒ)
    isLargeFile = file.size > 50 * 1024 * 1024;
    if (isLargeFile) {
        console.log('ëŒ€ìš©ëŸ‰ íŒŒì¼ ëª¨ë“œ í™œì„±í™”');
        startMemoryManagement();
    }
    
    const sizeMB = (file.size / 1024 / 1024).toFixed(1);
    const fileName = file.name.toLowerCase();
    
    showLoading(`íŒŒì¼ ì½ëŠ” ì¤‘... (${sizeMB}MB)`);
    
    try {
        // í…ìŠ¤íŠ¸ íŒŒì¼ ì²˜ë¦¬ (.csv, .tsv, .txt)
        if (fileName.endsWith('.csv') || fileName.endsWith('.tsv') || fileName.endsWith('.txt')) {
            const text = await readFileAsText(file);
            updateLoadingText('í…ìŠ¤íŠ¸ ë°ì´í„° ë¶„ì„ ì¤‘...');
            await parseTextFile(text, file.name);
        } else {
            // ì—‘ì…€ íŒŒì¼ ì²˜ë¦¬
            const data = await readFile(file);
            updateLoadingText('ë°ì´í„° ë¶„ì„ ì¤‘...');
            await parseExcelOptimized(data);
        }
        hideLoading();
        renderMainScreen();
        saveToLocalStorage(); // ë¡œì»¬ ì €ì¥ì†Œì— ì €ì¥
        toast('íŒŒì¼ ë¡œë“œ ì™„ë£Œ!');
    } catch (err) {
        console.error(err);
        hideLoading();
        toast('íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜');
    }
    e.target.value = '';
}

// í…ìŠ¤íŠ¸ íŒŒì¼ ì½ê¸°
function readFileAsText(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsText(file, 'UTF-8');
    });
}

// í…ìŠ¤íŠ¸ íŒŒì¼ íŒŒì‹± (CSV, TSV, TXT)
async function parseTextFile(text, fileName) {
    // êµ¬ë¶„ì ê°ì§€
    let delimiter = ',';
    if (fileName.toLowerCase().endsWith('.tsv')) {
        delimiter = '\t';
    } else if (fileName.toLowerCase().endsWith('.txt')) {
        // TXTëŠ” íƒ­ ë˜ëŠ” ì‰¼í‘œ ìë™ ê°ì§€
        const firstLine = text.split('\n')[0];
        if (firstLine.split('\t').length > firstLine.split(',').length) {
            delimiter = '\t';
        }
    }
    
    // ì¤„ ë‹¨ìœ„ë¡œ ë¶„ë¦¬
    const lines = text.split(/\r?\n/).filter(line => line.trim());
    if (lines.length === 0) {
        toast('ë¹ˆ íŒŒì¼ì…ë‹ˆë‹¤');
        return;
    }
    
    // í—¤ë”ì™€ ë°ì´í„° ë¶„ë¦¬
    const headers = parseCSVLine(lines[0], delimiter);
    const data = [];
    
    for (let i = 1; i < lines.length; i++) {
        const row = parseCSVLine(lines[i], delimiter);
        // í—¤ë” ê¸¸ì´ì— ë§ì¶¤
        while (row.length < headers.length) row.push('');
        data.push(row);
        
        // ì§„í–‰ë¥  í‘œì‹œ
        if (i % 1000 === 0) {
            updateLoadingText(`ì²˜ë¦¬ ì¤‘... ${i}/${lines.length}í–‰`);
            await new Promise(r => setTimeout(r, 0));
        }
    }
    
    // ì‹œíŠ¸ ì´ë¦„ ìƒì„±
    let sheetName = fileName.replace(/\.(csv|tsv|txt)$/i, '');
    if (WB[sheetName] && WB[sheetName].data && WB[sheetName].data.length > 0) {
        let suffix = 2;
        while (WB[`${sheetName}(${suffix})`]) suffix++;
        sheetName = `${sheetName}(${suffix})`;
    }
    
    WB[sheetName] = { headers, data };
    COL_ORDER[sheetName] = headers.map((_, i) => i);
    HIDDEN_COLS[sheetName] = new Set();
    
    toast(`'${sheetName}' ì‹œíŠ¸ ì¶”ê°€ (${data.length}í–‰)`);
}

// CSV ë¼ì¸ íŒŒì‹± (ë”°ì˜´í‘œ ì²˜ë¦¬)
function parseCSVLine(line, delimiter) {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (inQuotes) {
            if (char === '"') {
                if (line[i + 1] === '"') {
                    current += '"';
                    i++;
                } else {
                    inQuotes = false;
                }
            } else {
                current += char;
            }
        } else {
            if (char === '"') {
                inQuotes = true;
            } else if (char === delimiter) {
                result.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
    }
    result.push(current.trim());
    
    return result;
}

function updateLoadingText(text) {
    document.getElementById('loadingText').textContent = text;
}

function readFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(new Uint8Array(e.target.result));
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
    });
}

// ìµœì í™”ëœ ì—‘ì…€ íŒŒì‹± (ì²­í¬ ë‹¨ìœ„ + ë¹„ë™ê¸°) - ë‹¨ìˆœí™” ë²„ì „
async function parseExcelOptimized(data) {
    // ì¤‘ë³µ ì‹œíŠ¸ í ì´ˆê¸°í™”
    duplicateQueue = [];
    duplicateGroupQueue = []; // ê·¸ë£¹ ë³‘í•©ìš© í ì¶”ê°€
    currentDuplicateData = null;
    isMerging = false;
    
    let wb;
    try {
        // ëŒ€ìš©ëŸ‰ íŒŒì¼ ìµœì í™” ì˜µì…˜
        const xlsxOptions = {
            type: 'array',
            cellDates: false,
            raw: false,
            cellStyles: false,
            cellFormula: false,
            cellHTML: false,
            cellNF: false,
            sheetStubs: false,
            dense: isLargeFile
        };
        wb = XLSX.read(data, xlsxOptions);
        data = null;
        if (isLargeFile) forceGarbageCollection();
        
    } catch (err) {
        if (err.message && (err.message.includes('password') || err.message.includes('encrypt') || err.message.includes('Password') || err.message.includes('Encrypted'))) {
            toast('ë¹„ë°€ë²ˆí˜¸ ë³´í˜¸ëœ íŒŒì¼ì€ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            alert('ë¹„ë°€ë²ˆí˜¸ ë³´í˜¸ëœ íŒŒì¼ì…ë‹ˆë‹¤.\n\ní•´ê²° ë°©ë²•:\n1. ì—‘ì…€ì—ì„œ íŒŒì¼ ì—´ê¸°\n2. íŒŒì¼ > ì •ë³´ > í†µí•© ë¬¸ì„œ ë³´í˜¸ > ì•”í˜¸ ì„¤ì •\n3. ë¹„ë°€ë²ˆí˜¸ ë¹ˆì¹¸ìœ¼ë¡œ ì €ì¥\n4. ë‹¤ì‹œ ì—…ë¡œë“œ');
            return;
        }
        throw err;
    }
    
    let addedSheets = 0;
    let duplicateSheets = 0;
    const totalSheets = wb.SheetNames.length;
    const addedSheetNames = [];
    
    // ê¸°ì¡´ WBê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸ (ì²« ì—…ë¡œë“œì¸ì§€)
    const isFirstUpload = Object.keys(WB).every(name => !WB[name] || !WB[name].data || WB[name].data.length === 0);

    for (let s = 0; s < totalSheets; s++) {
        const name = wb.SheetNames[s];
        updateLoadingText(`ì‹œíŠ¸ ì²˜ë¦¬ ì¤‘... (${s + 1}/${totalSheets}) ${name}`);
        await new Promise(resolve => setTimeout(resolve, 0));
        
        const ws = wb.Sheets[name];
        const json = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '', raw: false });
        if (json.length === 0) continue;
        
        let newHeaders = json[0].map((h, i) => h ? String(h).trim() : `ì—´${i+1}`);
        if (newHeaders.length === 0) newHeaders = ['ë°ì´í„°'];
        
        // ë‚ ì§œ ì—´ ì¸ë±ìŠ¤ë“¤ ì°¾ê¸°
        const dateColIndices = new Set();
        newHeaders.forEach((h, idx) => {
            if (h && (h.includes('ë‚ ì§œ') || h.includes('ì¼ì') || h.includes('ì¼ì‹œ') || 
                      h.includes('Date') || h.includes('date') || h.includes('DATE') ||
                      h === 'ì‘ì„±ì¼' || h === 'ì…ê¸ˆì¼' || h === 'í‡´ì‚¬ë‚ ì§œ' || h === 'ì…ì‚¬ì¼' ||
                      h === 'ì™„ë£Œì˜ˆì •ì¼' || h === 'ì˜ˆì•½ì¼ì •' || h.includes('ì˜ˆì •ì¼'))) {
                dateColIndices.add(idx);
            }
        });
        
        // ë°ì´í„° ì²˜ë¦¬
        const newData = [];
        for (let i = 1; i < json.length; i++) {
            const row = json[i];
            if (!row || row.every(c => c === '' || c === null || c === undefined)) continue;
            while (row.length < newHeaders.length) row.push('');
            const processedRow = row.slice(0, newHeaders.length).map((cell, idx) => {
                if (idx === 0 || dateColIndices.has(idx)) return convertToKoreanDate(cell);
                if (cell && typeof cell === 'string' && /[A-Za-z]+\s+\d{1,2},?\s*\d{4}/.test(cell)) {
                    return convertToKoreanDate(cell);
                }
                return cell;
            });
            newData.push(processedRow);
        }
        
        // ìƒˆ ë°ì´í„°ê°€ ë¹„ì–´ìˆìœ¼ë©´ ê±´ë„ˆë›°ê¸°
        if (newData.length === 0) {
            continue;
        }

        // ì‹œíŠ¸ëª…ì—ì„œ ë‚ ì§œ ì œê±°í•˜ëŠ” í•¨ìˆ˜
        const getSheetBaseName = (sheetName) => {
            return sheetName
                .replace(/\s*\d{4}\.\d{2}\.\d{2}/g, '')  // 2026.01.15 í˜•ì‹ ì œê±°
                .replace(/\s*\d{4}-\d{2}-\d{2}/g, '')    // 2026-01-15 í˜•ì‹ ì œê±°
                .trim() || sheetName;
        };

        const newBaseName = getSheetBaseName(name);
        const headerStr = JSON.stringify(newHeaders);

        // ê¸°ë³¸ëª… + í—¤ë”ê°€ ê°™ì€ ê¸°ì¡´ ì‹œíŠ¸ ì°¾ê¸°
        let matchedSheet = null;
        for (const existingName of Object.keys(WB)) {
            if (!WB[existingName] || !WB[existingName].data || WB[existingName].data.length === 0) continue;
            const existingBaseName = getSheetBaseName(existingName);
            const existingHeaderStr = JSON.stringify(WB[existingName].headers);

            if (existingBaseName === newBaseName && existingHeaderStr === headerStr) {
                matchedSheet = existingName;
                break;
            }
        }

        if (matchedSheet && !isFirstUpload) {
            // ìŠ¤ë§ˆíŠ¸ ë³‘í•©: ê¸°ë³¸ëª… + í—¤ë” ì¼ì¹˜ â†’ ìë™ ë³‘í•© (ì¤‘ë³µ ì œì™¸)
            const existingSheet = WB[matchedSheet];
            const existingDataSet = new Set(existingSheet.data.map(row => JSON.stringify(row)));
            const uniqueNewRows = newData.filter(row => !existingDataSet.has(JSON.stringify(row)));

            const duplicateCount = newData.length - uniqueNewRows.length;

            // ì‹œíŠ¸ëª…ì—ì„œ ë‚ ì§œ ì¶”ì¶œ í•¨ìˆ˜
            const extractDate = (sheetName) => {
                const match = sheetName.match(/(\d{4})\.(\d{2})\.(\d{2})/);
                if (match) return new Date(match[1], match[2] - 1, match[3]);
                const match2 = sheetName.match(/(\d{4})-(\d{2})-(\d{2})/);
                if (match2) return new Date(match2[1], match2[2] - 1, match2[3]);
                return null;
            };

            const existingDate = extractDate(matchedSheet);
            const newDate = extractDate(name);
            const shouldRename = newDate && existingDate && newDate > existingDate && name !== matchedSheet;

            if (uniqueNewRows.length > 0) {
                existingSheet.data = [...existingSheet.data, ...uniqueNewRows];

                // ìƒˆ ì‹œíŠ¸ ë‚ ì§œê°€ ë” ìµœì‹ ì´ë©´ ì‹œíŠ¸ëª… ë³€ê²½
                if (shouldRename) {
                    WB[name] = existingSheet;
                    delete WB[matchedSheet];
                    COL_ORDER[name] = COL_ORDER[matchedSheet] || newHeaders.map((_, i) => i);
                    delete COL_ORDER[matchedSheet];
                    HIDDEN_COLS[name] = HIDDEN_COLS[matchedSheet] || new Set();
                    delete HIDDEN_COLS[matchedSheet];
                    toast(`'${matchedSheet}' â†’ '${name}' ë³‘í•©: +${uniqueNewRows.length}í–‰ (ì¤‘ë³µ ${duplicateCount}ê±´ ì œì™¸)`);
                } else {
                    toast(`'${matchedSheet}' ë³‘í•©: +${uniqueNewRows.length}í–‰ (ì¤‘ë³µ ${duplicateCount}ê±´ ì œì™¸)`);
                }
            } else {
                // ìƒˆ í–‰ì´ ì—†ì–´ë„ ë‚ ì§œê°€ ë” ìµœì‹ ì´ë©´ ì´ë¦„ ë³€ê²½
                if (shouldRename) {
                    WB[name] = existingSheet;
                    delete WB[matchedSheet];
                    COL_ORDER[name] = COL_ORDER[matchedSheet] || newHeaders.map((_, i) => i);
                    delete COL_ORDER[matchedSheet];
                    HIDDEN_COLS[name] = HIDDEN_COLS[matchedSheet] || new Set();
                    delete HIDDEN_COLS[matchedSheet];
                    toast(`'${matchedSheet}' â†’ '${name}' ì´ë¦„ ë³€ê²½ (ì¤‘ë³µ ${duplicateCount}ê±´)`);
                } else {
                    toast(`'${matchedSheet}' ì¤‘ë³µ ë°ì´í„° (ìƒˆ í–‰ ì—†ìŒ, ${duplicateCount}ê±´ ì œì™¸)`);
                }
            }
            duplicateSheets++;
        } else if (WB[name] && WB[name].data && WB[name].data.length > 0) {
            // ê°™ì€ ì´ë¦„ì´ì§€ë§Œ í—¤ë”ê°€ ë‹¤ë¥¸ ê²½ìš° â†’ ìƒˆ ì´ë¦„ìœ¼ë¡œ ì €ì¥
            let newName = name;
            let suffix = 2;
            while (WB[newName]) {
                newName = `${name}_${suffix}`;
                suffix++;
            }
            WB[newName] = { headers: newHeaders, data: newData };
            COL_ORDER[newName] = newHeaders.map((_, i) => i);
            HIDDEN_COLS[newName] = new Set();
            autoFitColumnWidths(newName);
            addedSheets++;
            addedSheetNames.push(newName);
        } else {
            // ìƒˆ ì‹œíŠ¸ â†’ ë°”ë¡œ ì €ì¥
            WB[name] = { headers: newHeaders, data: newData };
            COL_ORDER[name] = newHeaders.map((_, i) => i);
            HIDDEN_COLS[name] = new Set();
            autoFitColumnWidths(name);
            addedSheets++;
            addedSheetNames.push(name);
        }
    }
    
    // íŒŒì¼ ê·¸ë£¹ì— ì‹œíŠ¸ ë“±ë¡
    if (currentUploadFileName && addedSheetNames.length > 0) {
        registerFileGroup(currentUploadFileName, addedSheetNames);
    }

    // ê²°ê³¼ ë©”ì‹œì§€
    if (addedSheets > 0 && duplicateSheets === 0) {
        toast(`${addedSheets}ê°œ ì‹œíŠ¸ ì¶”ê°€ë¨: ${addedSheetNames.slice(0, 3).join(', ')}${addedSheetNames.length > 3 ? ' ì™¸ ' + (addedSheetNames.length - 3) + 'ê°œ' : ''}`);
    } else if (addedSheets > 0 && duplicateSheets > 0) {
        toast(`${addedSheets}ê°œ ì‹œíŠ¸ ì¶”ê°€ë¨, ${duplicateSheets}ê°œ ìë™ ë³‘í•©ë¨`);
    } else if (duplicateSheets > 0) {
        // ìë™ ë³‘í•©ë¨ - ê°œë³„ toastì—ì„œ ì²˜ë¦¬
    } else {
        toast('ì¶”ê°€ëœ ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
    }
    
    const names = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
    if (names.length > 0 && (!WB[SHEET] || !WB[SHEET].data || WB[SHEET].data.length === 0)) {
        SHEET = names[0];
    }
    CURRENT_PAGE = 0;
    document.getElementById('currentSheetName').textContent = SHEET;
    renderSheetTabs();
    renderSpreadsheet();
    renderMainScreen();
}

// í—¤ë”ê°€ ì¼ì¹˜í•˜ëŠ” ê¸°ì¡´ ì‹œíŠ¸ ì°¾ê¸°
function findSheetsByHeader(newHeaders) {
    const matches = [];
    const newHeaderStr = JSON.stringify(newHeaders);
    
    for (const sheetName of Object.keys(WB)) {
        // null ì²´í¬ ì¶”ê°€
        if (!WB[sheetName] || !WB[sheetName].data || WB[sheetName].data.length === 0) continue;
        const existingHeaderStr = JSON.stringify(WB[sheetName].headers);
        if (newHeaderStr === existingHeaderStr) {
            matches.push(sheetName);
        }
    }
    
    return matches;
}

// ê¸°ì¡´ parseExcelì€ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€
async function parseExcel(data) {
    return parseExcelOptimized(data);
}

function convertToKoreanDate(value) {
    if (value === null || value === undefined || value === '') return '';
    const str = String(value).trim();
    if (/\d{4}ë…„/.test(str)) return str;
    const dayNames = ['ì¼ìš”ì¼', 'ì›”ìš”ì¼', 'í™”ìš”ì¼', 'ìˆ˜ìš”ì¼', 'ëª©ìš”ì¼', 'ê¸ˆìš”ì¼', 'í† ìš”ì¼'];
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    let year, month, day, date;
    const engMatch = str.match(/(?:\w+,\s*)?(\w+)\s+(\d{1,2}),?\s*(\d{4})/);
    if (engMatch) {
        const monthIdx = monthNames.findIndex(m => m.toLowerCase() === engMatch[1].toLowerCase());
        if (monthIdx !== -1) { year = parseInt(engMatch[3]); month = monthIdx + 1; day = parseInt(engMatch[2]); date = new Date(year, month - 1, day); }
    }
    if (!date) {
        const isoMatch = str.match(/(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
        if (isoMatch) { year = parseInt(isoMatch[1]); month = parseInt(isoMatch[2]); day = parseInt(isoMatch[3]); date = new Date(year, month - 1, day); }
    }
    if (!date && !isNaN(value) && Number(value) > 25569 && Number(value) < 60000) {
        const excelEpoch = new Date(Date.UTC(1899, 11, 30));
        date = new Date(excelEpoch.getTime() + Number(value) * 86400000);
        year = date.getUTCFullYear(); month = date.getUTCMonth() + 1; day = date.getUTCDate();
        date = new Date(year, month - 1, day);
    }
    if (date && !isNaN(date.getTime())) {
        return `${year}ë…„ ${month}ì›” ${day}ì¼ ${dayNames[date.getDay()]}`;
    }
    return value;
}

function getKoreanDate(dateStr) {
    if (!dateStr) return '';
    const date = new Date(dateStr);
    const dayNames = ['ì¼ìš”ì¼', 'ì›”ìš”ì¼', 'í™”ìš”ì¼', 'ìˆ˜ìš”ì¼', 'ëª©ìš”ì¼', 'ê¸ˆìš”ì¼', 'í† ìš”ì¼'];
    return `${date.getFullYear()}ë…„ ${date.getMonth() + 1}ì›” ${date.getDate()}ì¼ ${dayNames[date.getDay()]}`;
}

function downloadExcel() {
    // ëŒ€ìš©ëŸ‰ íŒŒì¼ ì €ì¥ ì‹œ ë¡œë”© í‘œì‹œ
    const totalRows = Object.values(WB).reduce((sum, sheet) => sum + (sheet.data ? sheet.data.length : 0), 0);
    if (totalRows > 50000) {
        showLoading('ëŒ€ìš©ëŸ‰ íŒŒì¼ ì €ì¥ ì¤‘...');
    }
    
    setTimeout(() => {
        try {
            const wb = XLSX.utils.book_new();
            Object.keys(WB).forEach(name => {
                const sheet = WB[name];
                const wsData = [sheet.headers, ...sheet.data];
                const ws = XLSX.utils.aoa_to_sheet(wsData);
                XLSX.utils.book_append_sheet(wb, ws, name.substring(0, 31)); // ì‹œíŠ¸ëª… 31ì ì œí•œ
            });
            
            // ëŒ€ìš©ëŸ‰ íŒŒì¼ ìµœì í™” ì˜µì…˜
            const writeOptions = {
                bookType: 'xlsx',
                compression: totalRows > 100000 // 10ë§Œí–‰ ì´ìƒ ì‹œ ì••ì¶•
            };
            
            XLSX.writeFile(wb, 'í™˜ë¶ˆì¥_' + new Date().toISOString().slice(0,10) + '.xlsx', writeOptions);
            hideLoading();
            toast('íŒŒì¼ ì €ì¥ ì™„ë£Œ!');
            
            // ë©”ëª¨ë¦¬ ì •ë¦¬
            if (isLargeFile) forceGarbageCollection();
        } catch (err) {
            hideLoading();
            console.error('ì €ì¥ ì˜¤ë¥˜:', err);
            toast('íŒŒì¼ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
        }
    }, 50);
}

function renderSheetTabs() {
    const container = document.getElementById('sheetTabsContainer');
    if (!container) return;
    const names = Object.keys(WB);
    const p = [];
    for (let i = 0; i < names.length; i++) {
        const name = names[i];
        // ë¹ˆ ì‹œíŠ¸ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ì‹œíŠ¸ëŠ” ìˆ¨ê¹€
        if (!WB[name] || !WB[name].data || WB[name].data.length === 0) continue;
        const isActive = name === SHEET ? ' active' : '';
        const dataLength = WB[name].data.length;
        p.push('<div class="sheet-tab', isActive, '" data-sheet="', escHtml(name), '"><span class="tab-name" ondblclick="startRenameSheet(event, \'', escHtml(name.replace(/'/g, "\\'")), '\')">', escHtml(name), '</span><span class="count">', dataLength, '</span><span class="tab-close" data-del="', escHtml(name), '">Ã—</span></div>');
    }
    p.push('<button class="add-sheet-btn">+</button>');
    container.innerHTML = p.join('');
    
    // í˜„ì¬ ì‹œíŠ¸ê°€ ë¹ˆ ì‹œíŠ¸ë©´ ë°ì´í„° ìˆëŠ” ì²« ë²ˆì§¸ ì‹œíŠ¸ë¡œ ì „í™˜
    if (!WB[SHEET] || !WB[SHEET].data || WB[SHEET].data.length === 0) {
        const nonEmptySheet = names.find(n => WB[n] && WB[n].data && WB[n].data.length > 0);
        if (nonEmptySheet) {
            SHEET = nonEmptySheet;
            document.getElementById('currentSheetName').textContent = SHEET;
            renderSpreadsheet();
        }
    }
}

// ì‹œíŠ¸ ì´ë¦„ ë³€ê²½ ì‹œì‘ (íƒ­ì—ì„œ)
function startRenameSheet(e, sheetName) {
    e.stopPropagation();
    createInlineEdit({
        targetEl: e.target,
        currentValue: sheetName,
        styleStr: 'width:80px;padding:2px 5px;font-size:11px;border:2px solid var(--retro-teal);border-radius:3px;outline:none;',
        onFinish: (newName) => {
            if (WB[newName]) {
                toast('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‹œíŠ¸ ì´ë¦„ì…ë‹ˆë‹¤');
                renderSheetTabs();
            } else {
                renameSheet(sheetName, newName);
            }
        },
        onCancel: () => renderSheetTabs()
    });
}

// ì‹œíŠ¸ ì´ë¦„ ë³€ê²½ (ë°ì´í„° ì´ë™)
function renameSheet(oldName, newName) {
    if (!WB[oldName]) return;
    
    // ë°ì´í„° ì´ë™
    WB[newName] = WB[oldName];
    delete WB[oldName];
    
    // ì—´ ìˆœì„œ ì´ë™
    if (COL_ORDER[oldName]) {
        COL_ORDER[newName] = COL_ORDER[oldName];
        delete COL_ORDER[oldName];
    }
    
    // ìˆ¨ê¸´ ì—´ ì´ë™
    if (HIDDEN_COLS[oldName]) {
        HIDDEN_COLS[newName] = HIDDEN_COLS[oldName];
        delete HIDDEN_COLS[oldName];
    }
    
    // ì—´ ë„ˆë¹„ ì´ë™
    if (COL_WIDTHS[oldName]) {
        COL_WIDTHS[newName] = COL_WIDTHS[oldName];
        delete COL_WIDTHS[oldName];
    }
    
    // í–‰ ë†’ì´ ì´ë™
    if (ROW_HEIGHTS[oldName]) {
        ROW_HEIGHTS[newName] = ROW_HEIGHTS[oldName];
        delete ROW_HEIGHTS[oldName];
    }
    
    // ì¦ê²¨ì°¾ê¸° ì´ë™
    if (FAVORITES.has(oldName)) {
        FAVORITES.delete(oldName);
        FAVORITES.add(newName);
    }
    
    // í´ë” ë§¤í•‘ ì´ë™
    if (sheetToFolder[oldName]) {
        sheetToFolder[newName] = sheetToFolder[oldName];
        delete sheetToFolder[oldName];
        saveFolderData();
    }
    
    // ì‹œíŠ¸ ì¦ê²¨ì°¾ê¸° ì´ë™ (favoriteSheets)
    if (favoriteSheets && favoriteSheets.has(oldName)) {
        favoriteSheets.delete(oldName);
        favoriteSheets.add(newName);
    }
    
    // NEW ë°°ì§€ ì´ë™
    if (newSheets && newSheets.has(oldName)) {
        newSheets.delete(oldName);
        newSheets.add(newName);
    }
    
    // ë‹¤ì¤‘ ì„ íƒ ì´ë™
    if (multiSelectedSheets && multiSelectedSheets.has(oldName)) {
        multiSelectedSheets.delete(oldName);
        multiSelectedSheets.add(newName);
    }
    
    // í˜„ì¬ ì‹œíŠ¸ê°€ ë³€ê²½ëœ ì‹œíŠ¸ë©´ ì—…ë°ì´íŠ¸
    if (SHEET === oldName) {
        SHEET = newName;
        document.getElementById('currentSheetName').textContent = newName;
    }
    
    renderSheetTabs();
    renderMainScreen();
    toast(`'${oldName}' â†’ '${newName}' ì´ë¦„ ë³€ê²½ë¨`);
}

document.getElementById('sheetTabsContainer').addEventListener('click', e => {
    const tab = e.target.closest('.sheet-tab');
    const del = e.target.closest('.tab-close');
    const add = e.target.closest('.add-sheet-btn');
    if (del) { e.stopPropagation(); deleteSheet(del.dataset.del); return; }
    if (tab) { switchSheet(tab.dataset.sheet); return; }
    if (add) { addSheet(); }
});

function switchSheet(name) {
    if (NEW_ENTRY_MODE) finishNewEntryMode();
    
    // ê²€ìƒ‰ ê²°ê³¼ ë©”ì¸ í™”ë©´ì´ ì—´ë ¤ìˆìœ¼ë©´ ë‹«ê¸°
    const searchResultsMain = document.getElementById('searchResultsMain');
    if (searchResultsMain && searchResultsMain.style.display !== 'none') {
        searchResultsMain.style.display = 'none';
        document.getElementById('spreadsheetContainer').style.display = '';
    }
    
    SHEET = name;
    SELECTED = null;
    CURRENT_PAGE = 0;
    // ì—´ ìˆœì„œ ì´ˆê¸°í™” (ì—†ìœ¼ë©´ ê¸°ë³¸ ìˆœì„œ)
    if (!COL_ORDER[name]) {
        COL_ORDER[name] = WB[name].headers.map((_, i) => i);
    }
    // ìˆ¨ê¸´ ì—´ ì´ˆê¸°í™” (ì—†ìœ¼ë©´ ë¹ˆ Set)
    if (!HIDDEN_COLS[name]) {
        HIDDEN_COLS[name] = new Set();
    }
    document.getElementById('currentSheetName').textContent = name;
    renderSheetTabs();
    renderSpreadsheet();
    updateColManagerBtn();
}

function deleteSheet(name) {
    const sheetNames = Object.keys(WB);
    if (sheetNames.length <= 1) {
        toast('ë§ˆì§€ë§‰ ì‹œíŠ¸ëŠ” ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    const dataCount = WB[name] && WB[name].data ? WB[name].data.length : 0;
    if (!confirm(`'${name}' ì‹œíŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ë°ì´í„° ${dataCount}ê±´ì´ ì‚­ì œë©ë‹ˆë‹¤)`)) return;
    delete WB[name];
    delete COL_ORDER[name];
    delete HIDDEN_COLS[name];
    delete COL_WIDTHS[name];
    delete ROW_HEIGHTS[name];
    delete sheetToFolder[name];
    if (favoriteSheets) favoriteSheets.delete(name);
    if (newSheets) newSheets.delete(name);
    if (multiSelectedSheets) multiSelectedSheets.delete(name);
    if (SHEET === name) {
        SHEET = Object.keys(WB)[0];
        document.getElementById('currentSheetName').textContent = SHEET;
    }
    saveFolderData();
    renderSheetTabs();
    renderSpreadsheet();
    saveToLocalStorage(); // ë¡œì»¬ ì €ì¥ì†Œì— ì €ì¥
    toast('ì‹œíŠ¸ ì‚­ì œë¨');
}

function toggleResetMenu() {
    const menu = document.getElementById('resetMenu');
    if (!menu) return;
    menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
}

// íˆ´ë°” ë”ë³´ê¸° ë©”ë‰´
function toggleToolbarMore() {
    const menu = document.getElementById('toolbarMoreMenu');
    if (!menu) return;
    menu.classList.toggle('show');

    if (menu.classList.contains('show')) {
        setTimeout(() => {
            document.addEventListener('click', closeToolbarMoreOnClickOutside, { once: true });
        }, 10);
    }
}

function closeToolbarMore() {
    const menu = document.getElementById('toolbarMoreMenu');
    if (menu) menu.classList.remove('show');
}

function closeToolbarMoreOnClickOutside(e) {
    const wrapper = document.querySelector('.toolbar-more-wrapper');
    if (wrapper && !wrapper.contains(e?.target)) {
        closeToolbarMore();
    }
}

// ë©”ë‰´ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
document.addEventListener('click', e => {
    if (!e.target.closest('.reset-menu') && !e.target.closest('.toolbar-more-item.danger')) {
        const resetMenu = document.getElementById('resetMenu');
        if (resetMenu) resetMenu.style.display = 'none';
    }
});

function resetSheetData() {
    const sheet = WB[SHEET];
    if (!sheet) return;
    document.getElementById('resetMenu')?.classList.remove('show');
    
    if (sheet.data.length === 0) {
        toast('ì´ë¯¸ ë¹„ì–´ìˆìŠµë‹ˆë‹¤');
        return;
    }
    if (!confirm(`'${SHEET}' ì‹œíŠ¸ì˜ ë°ì´í„° ${sheet.data.length}ê±´ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(í—¤ë”ëŠ” ìœ ì§€ë©ë‹ˆë‹¤)`)) return;
    saveState('ë°ì´í„° ì´ˆê¸°í™”');
    sheet.data = [];
    SELECTED = null;
    SELECTION_START = null;
    SELECTION_END = null;
    CURRENT_PAGE = 0;
    if (NEW_ENTRY_MODE) finishNewEntryMode();
    renderSpreadsheet();
    renderSheetTabs();
    toast('ë°ì´í„° ì‚­ì œ ì™„ë£Œ (í—¤ë” ìœ ì§€)');
}

function resetSheetAll() {
    const sheet = WB[SHEET];
    if (!sheet) return;
    document.getElementById('resetMenu')?.classList.remove('show');
    
    if (!confirm(`'${SHEET}' ì‹œíŠ¸ ì „ì²´ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(í—¤ë”ì™€ ë°ì´í„° ëª¨ë‘ ì‚­ì œë©ë‹ˆë‹¤)`)) return;
    saveState('ì „ì²´ ì´ˆê¸°í™”');
    sheet.headers = ['ì—´1'];
    sheet.data = [];
    SELECTED = null;
    SELECTION_START = null;
    SELECTION_END = null;
    CURRENT_PAGE = 0;
    COL_ORDER[SHEET] = [0];
    HIDDEN_COLS[SHEET] = new Set();
    if (NEW_ENTRY_MODE) finishNewEntryMode();
    renderSpreadsheet();
    renderSheetTabs();
    toast('ì „ì²´ ì´ˆê¸°í™” ì™„ë£Œ');
}

function addSheet() {
    const name = prompt('ìƒˆ ì‹œíŠ¸ ì´ë¦„:', 'ìƒˆì‹œíŠ¸' + (Object.keys(WB).length + 1));
    if (!name) return;
    const sheetType = prompt('ì‹œíŠ¸ ìœ í˜•ì„ ì„ íƒí•˜ì„¸ìš”:\n1. ì¼ë°˜í™˜ë¶ˆì¥\n2. ìš°ì²´êµ­í™˜ë¶ˆì¥\n3. ì‚¬ì—…ì†Œë“/í‡´ì§ê¸ˆ\n4. íœ´ëŒ€í°\n5. ë‹¨ì²´ë³µ\n6. PGì‚¬\n7. í•´ì™¸ì†¡ê¸ˆ\n8. ë¯¸ì²˜ë¦¬í˜„í™©\n(ë²ˆí˜¸ ì…ë ¥, ê¸°ë³¸ê°’: 1)', '1');
    let headers;
    switch(sheetType) {
        case '2': headers = ['ë‚ ì§œ','ì‘ì„±ì','ì²˜ë¦¬ì','ì²´í¬','ì€í–‰','ê³„ì¢Œë²ˆí˜¸','ì²˜ë¦¬ì—¬ë¶€','ê¸ˆì•¡','ì˜ˆê¸ˆì£¼','ê³ ê°ëª…','ì£¼ë¬¸ì¼ì','ì „í™”ë²ˆí˜¸','ìƒì„¸ë‚´ìš©','êµ¬ë¶„']; break;
        case '3': headers = ['ë‚ ì§œ','ì‘ì„±ì','ë¹„ê³ ','ì€í–‰','ê³„ì¢Œë²ˆí˜¸','ì²˜ë¦¬ì—¬ë¶€','ê¸ˆì•¡','ì˜ˆê¸ˆì£¼','ê³ ê°ëª…','ì£¼ë¬¸ì¼ì','ì „í™”ë²ˆí˜¸','ìƒì„¸ë‚´ìš©']; break;
        case '4': headers = ['ë‚ ì§œ','ì‘ì„±ì','ë¹„ê³ ','ì€í–‰','ê³„ì¢Œë²ˆí˜¸','ì²˜ë¦¬ì—¬ë¶€','ê¸ˆì•¡','ì˜ˆê¸ˆì£¼','ê³ ê°ëª…','ì£¼ë¬¸ì¼ì','ê³ ê°ì •ë³´','ìƒì„¸ë‚´ìš©','êµ¬ë¶„']; break;
        case '5': headers = ['ì‘ì„±ì¼','ë‹¨ì²´ë³µë‚´ìš©','ê¸ˆì•¡','ì…ê¸ˆí†µì¥','êµ¬ë¶„','ì²­êµ¬/ì˜ìˆ˜','ì…ê¸ˆì¼','ìš”ì²­ì','ë°œí–‰ì—¬ë¶€/ë¹„ê³ ','ë¹„ê³ 2']; break;
        case '6': headers = ['ë‚ ì§œ','ì²˜ë¦¬ì','ê²°ì œì²˜','ê²°ì œìˆ˜ë‹¨','ì‚¬ì´íŠ¸ëª…','ê¸ˆì•¡','ì£¼ë¬¸ì','ì£¼ë¬¸ë²ˆí˜¸','ìƒì„¸ë‚´ìš©','ë¹„ê³ ','ì·¨ì†Œì—¬ë¶€']; break;
        case '7': headers = ['ë‚ ì§œ','ì‘ì„±ì','ì²˜ë¦¬ì','ë°›ëŠ”ì‚¬ëŒ','ì€í–‰ëª…','ê³„ì¢Œì •ë³´','ê¸ˆì•¡(USD)','ì ìš©í™˜ìœ¨','ì›í™”ê¸ˆì•¡','ì†¡ê¸ˆê³„ì¢Œ','ì¤‘ê³„ìˆ˜ìˆ˜ë£Œ','ë¹„ê³ ']; break;
        case '8': headers = ['ì£¼ë¬¸ë‚ ì§œ','ì²˜ë¦¬ì—¬ë¶€','ë‚´ìš©','ì‚¬ì´íŠ¸','ì—…ì²´','ì£¼ë¬¸ë²ˆí˜¸','ì„±í•¨','ì—°ë½ì²˜','ê²°ì œë°©ë²•','êµ¬ë¶„','ê¸ˆì•¡','ìƒí’ˆëª…']; break;
        default: headers = ['ë‚ ì§œ','ì‘ì„±ì','ì²˜ë¦¬ì','ì€í–‰','ê³„ì¢Œë²ˆí˜¸','ì²˜ë¦¬ì—¬ë¶€','ê¸ˆì•¡','ì˜ˆê¸ˆì£¼','ê±°ë˜ì²˜ëª…','ìˆ˜ì·¨ì—¬ë¶€','ê±°ë˜ì²˜ì •ë³´','ìƒì„¸ë‚´ìš©'];
    }
    WB[name] = { headers, data: [] };
    COL_ORDER[name] = headers.map((_, i) => i);
    HIDDEN_COLS[name] = new Set();
    SHEET = name;
    CURRENT_PAGE = 0;
    document.getElementById('currentSheetName').textContent = name;
    renderSheetTabs();
    renderSpreadsheet();
    toast('ì‹œíŠ¸ ì¶”ê°€ë¨');
}

function renderSpreadsheet() {
    // ì“°ë¡œí‹€ë§: ë„ˆë¬´ ë¹ˆë²ˆí•œ ë Œë”ë§ ë°©ì§€
    const now = Date.now();
    if (now - lastRenderTime < MIN_RENDER_INTERVAL) {
        if (renderRequestId) cancelAnimationFrame(renderRequestId);
        renderRequestId = requestAnimationFrame(() => renderSpreadsheet());
        return;
    }
    lastRenderTime = now;
    
    const sheet = WB[SHEET];
    if (!sheet) return;
    
    // ì—´ ìˆœì„œ ì´ˆê¸°í™”
    if (!COL_ORDER[SHEET]) {
        COL_ORDER[SHEET] = sheet.headers.map((_, i) => i);
    }
    // ìˆ¨ê¸´ ì—´ ì´ˆê¸°í™”
    if (!HIDDEN_COLS[SHEET]) {
        HIDDEN_COLS[SHEET] = new Set();
    }
    
    // ì—´ ë„ˆë¹„ ìë™ ê³„ì‚° (ì•„ì§ ì„¤ì • ì•ˆ ëœ ê²½ìš°)
    if (!COL_WIDTHS[SHEET] || Object.keys(COL_WIDTHS[SHEET]).length === 0) {
        autoFitColumnWidths(SHEET);
    }
    
    const colOrder = COL_ORDER[SHEET];
    const hiddenCols = HIDDEN_COLS[SHEET];
    // í‘œì‹œí•  ì—´ë§Œ í•„í„°ë§
    const visibleCols = colOrder.filter(c => !hiddenCols.has(c));
    
    const table = document.getElementById('spreadsheet');
    const totalRows = sheet.data.length;
    const loadCount = Math.min((CURRENT_PAGE + 1) * PAGE_SIZE, totalRows);
    const startIdx = totalRows - loadCount;
    
    // ì»¬ëŸ¼ ë„ˆë¹„ ìºì‹± (ì„±ëŠ¥ ìµœì í™” - í•œ ë²ˆë§Œ ì¡°íšŒ)
    const colWidthCache = {};
    for (let i = 0; i < visibleCols.length; i++) {
        colWidthCache[visibleCols[i]] = getColWidth(SHEET, visibleCols[i]);
    }
    
    // ëŒ€ìš©ëŸ‰ íŒŒì¼ì¼ ê²½ìš° ë°°ì—´ í¬ê¸° ì˜ˆì•½
    const estimatedSize = (loadCount + 10) * (visibleCols.length + 1) * 50;
    const p = new Array(Math.ceil(estimatedSize / 50));
    let pIdx = 0;
    
    p[pIdx++] = '<colgroup><col style="width:50px;">';
    for (let i = 0; i < visibleCols.length; i++) {
        const realCol = visibleCols[i];
        const colWidth = colWidthCache[realCol];
        p[pIdx++] = '<col data-realcol="' + realCol + '" style="width:' + colWidth + 'px;">';
    }
    p[pIdx++] = '</colgroup>';
    
    p[pIdx++] = '<thead><tr><th class="corner-cell"></th>';
    for (let i = 0; i < visibleCols.length; i++) {
        const realCol = visibleCols[i];
        const colWidth = colWidthCache[realCol];
        p[pIdx++] = '<th class="col-header" data-col="' + i + '" data-realcol="' + realCol + '" draggable="true" ondblclick="handleColHeaderDblClick(event,' + realCol + ')" style="width:' + colWidth + 'px;max-width:' + colWidth + 'px;">' + escHtml(sheet.headers[realCol] || '') + '</th>';
    }
    const row0Height = getRowHeight(SHEET, 0);
    p[pIdx++] = '</tr></thead><tbody><tr style="height:' + row0Height + 'px;"><td class="row-header" data-row="0">1</td>';
    for (let i = 0; i < visibleCols.length; i++) {
        const realCol = visibleCols[i];
        const colWidth = colWidthCache[realCol];
        p[pIdx++] = '<td class="cell" data-row="0" data-col="' + i + '" data-realcol="' + realCol + '" style="background:var(--retro-beige);font-weight:bold;width:' + colWidth + 'px;max-width:' + colWidth + 'px;"><span>' + escHtml(sheet.headers[realCol] || '') + '</span></td>';
    }
    p[pIdx++] = '</tr>';
    
    // ë°ì´í„° í–‰ ë Œë”ë§ (ìµœì í™”)
    for (let i = 0; i < loadCount; i++) {
        const realIdx = startIdx + i;
        const row = sheet.data[realIdx];
        const displayRow = i + 1;
        const rowHeight = getRowHeight(SHEET, displayRow);
        p[pIdx++] = '<tr data-displayrow="' + displayRow + '" style="height:' + rowHeight + 'px;"><td class="row-header" data-row="' + displayRow + '" data-realidx="' + realIdx + '">' + (realIdx + 2) + '</td>';
        for (let j = 0; j < visibleCols.length; j++) {
            const realCol = visibleCols[j];
            const cellVal = row[realCol];
            p[pIdx++] = '<td class="cell" data-row="' + displayRow + '" data-realidx="' + realIdx + '" data-col="' + j + '" data-realcol="' + realCol + '" style="height:' + rowHeight + 'px;"><span>' + escHtml(cellVal !== undefined && cellVal !== null ? cellVal : '') + '</span></td>';
        }
        p[pIdx++] = '</tr>';
    }
    
    // ë¹ˆ í–‰ ì¶”ê°€
    for (let i = 0; i < 5; i++) {
        const displayRow = loadCount + i + 1;
        const realIdx = totalRows + i;
        const rowHeight = getRowHeight(SHEET, displayRow);
        p[pIdx++] = '<tr data-displayrow="' + displayRow + '" style="height:' + rowHeight + 'px;"><td class="row-header" data-row="' + displayRow + '">' + (realIdx + 2) + '</td>';
        for (let j = 0; j < visibleCols.length; j++) {
            const realCol = visibleCols[j];
            p[pIdx++] = '<td class="cell" data-row="' + displayRow + '" data-col="' + j + '" data-realcol="' + realCol + '"><span></span></td>';
        }
        p[pIdx++] = '</tr>';
    }
    
    const colCount = visibleCols.length;
    if (startIdx > 0) {
        p[pIdx++] = '<tr><td colspan="' + (colCount + 1) + '" class="load-more-cell"><span onclick="loadMore()">â–² ê³¼ê±° ë°ì´í„° ë” ë³´ê¸° (' + startIdx + 'ê±´ ë‚¨ìŒ)</span><span onclick="loadAll()">â–²â–² ì „ì²´ ë³´ê¸°</span></td></tr>';
    } else if (totalRows > PAGE_SIZE) {
        p[pIdx++] = '<tr><td colspan="' + (colCount + 1) + '" class="load-more-cell load-complete">âœ“ ì „ì²´ ' + totalRows + 'ê±´ ë¡œë“œ ì™„ë£Œ</td></tr>';
    } else if (totalRows > 0) {
        p[pIdx++] = '<tr><td colspan="' + (colCount + 1) + '" class="load-more-cell">ì „ì²´ ' + totalRows + 'ê±´</td></tr>';
    } else {
        p[pIdx++] = '<tr><td colspan="' + (colCount + 1) + '" class="load-more-cell">ë°ì´í„° ì—†ìŒ</td></tr>';
    }
    
    p[pIdx++] = '</tbody>';
    
    // ë°°ì—´ì„ ì˜ë¼ì„œ join (null/undefined ì œê±°)
    table.innerHTML = p.slice(0, pIdx).join('');
    updateStatus();
    
    // ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œë©´ draggable ë¹„í™œì„±í™” ìœ ì§€
    if (RESIZE_MODE) {
        document.querySelectorAll('.col-header').forEach(el => {
            el.setAttribute('draggable', 'false');
        });
    }
    
    // ê¸€ì í¬ê¸° ì ìš©
    if (currentFontSize !== 100) {
        applyFontSize();
    }
}

function moveColumn(fromDisplayCol, toDisplayCol) {
    const colOrder = COL_ORDER[SHEET];
    const hiddenCols = HIDDEN_COLS[SHEET];
    const visibleCols = colOrder.filter(c => !hiddenCols.has(c));
    
    // í‘œì‹œëœ ì—´ ìˆœì„œì—ì„œ ì´ë™
    const fromRealCol = visibleCols[fromDisplayCol];
    const toRealCol = visibleCols[toDisplayCol];
    
    // ì „ì²´ ì—´ ìˆœì„œì—ì„œ ìœ„ì¹˜ ì°¾ê¸°
    const fromIdx = colOrder.indexOf(fromRealCol);
    const toIdx = colOrder.indexOf(toRealCol);
    
    const movedCol = colOrder.splice(fromIdx, 1)[0];
    colOrder.splice(toIdx, 0, movedCol);
    
    renderSpreadsheet();
    toast(`ì—´ ì´ë™ ì™„ë£Œ (í™”ë©´ í‘œì‹œë§Œ ë³€ê²½)`);
}

function resetColumnOrder() {
    const sheet = WB[SHEET];
    if (!sheet) return;
    COL_ORDER[SHEET] = sheet.headers.map((_, i) => i);
    HIDDEN_COLS[SHEET] = new Set();
    renderSpreadsheet();
    toast('ì—´ ìˆœì„œ ë° í‘œì‹œ ì´ˆê¸°í™”');
}

function showColumnManager() {
    const sheet = WB[SHEET];
    if (!sheet) return;
    
    if (!HIDDEN_COLS[SHEET]) {
        HIDDEN_COLS[SHEET] = new Set();
    }
    const hiddenCols = HIDDEN_COLS[SHEET];
    const colOrder = COL_ORDER[SHEET] || sheet.headers.map((_, i) => i);
    
    const list = document.getElementById('columnList');
    let html = '';
    for (let i = 0; i < colOrder.length; i++) {
        const realCol = colOrder[i];
        const isChecked = !hiddenCols.has(realCol) ? 'checked' : '';
        const headerName = sheet.headers[realCol] || '(ë¹ˆ ì—´)';
        html += `<li>
            <input type="checkbox" id="col_${realCol}" data-realcol="${realCol}" ${isChecked}>
            <label for="col_${realCol}"><strong>${i + 1}.</strong> ${escHtml(headerName)}</label>
        </li>`;
    }
    list.innerHTML = html;
    document.getElementById('columnModal')?.classList.add('show');
}

function closeColumnManager() {
    document.getElementById('columnModal')?.classList.remove('show');
}

function selectAllColumns() {
    document.querySelectorAll('#columnList input[type="checkbox"]').forEach(cb => cb.checked = true);
}

function deselectAllColumns() {
    document.querySelectorAll('#columnList input[type="checkbox"]').forEach(cb => cb.checked = false);
}

function applyColumnVisibility() {
    const hiddenCols = new Set();
    document.querySelectorAll('#columnList input[type="checkbox"]').forEach(cb => {
        if (!cb.checked) {
            hiddenCols.add(+cb.dataset.realcol);
        }
    });
    
    // ìµœì†Œ 1ê°œ ì—´ì€ í‘œì‹œ
    const sheet = WB[SHEET];
    if (hiddenCols.size >= sheet.headers.length) {
        toast('ìµœì†Œ 1ê°œ ì—´ì€ í‘œì‹œí•´ì•¼ í•©ë‹ˆë‹¤');
        return;
    }
    
    HIDDEN_COLS[SHEET] = hiddenCols;
    closeColumnManager();
    renderSpreadsheet();
    updateColManagerBtn();
    toast(`${hiddenCols.size}ê°œ ì—´ ìˆ¨ê¹€`);
}

// ì—´ ê´€ë¦¬ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
function updateColManagerBtn() {
    const btn = document.getElementById('colManagerBtn');
    if (!btn) return;
    
    const hiddenCount = HIDDEN_COLS[SHEET] ? HIDDEN_COLS[SHEET].size : 0;
    if (hiddenCount > 0) {
        btn.textContent = `ì—´ ê´€ë¦¬ (${hiddenCount}ê°œ ìˆ¨ê¹€)`;
        btn.style.background = '#e67e22';
        btn.style.color = 'white';
    } else {
        btn.textContent = 'ì—´ ê´€ë¦¬';
        btn.style.background = '';
        btn.style.color = '';
    }
}

function loadMore() {
    CURRENT_PAGE++;
    renderSpreadsheet();
}

function loadAll() {
    if (!WB[SHEET] || !WB[SHEET].data) return;
    const totalRows = WB[SHEET].data.length;
    CURRENT_PAGE = Math.ceil(totalRows / PAGE_SIZE) - 1;
    renderSpreadsheet();
    toast(`ì „ì²´ ${totalRows}ê±´ ë¡œë“œë¨`);
}

function getColLetter(n) {
    let result = '';
    while (n >= 0) { result = String.fromCharCode(65 + (n % 26)) + result; n = Math.floor(n / 26) - 1; }
    return result;
}

// HTML ì´ìŠ¤ì¼€ì´í”„ (ì„±ëŠ¥ ìµœì í™” ë²„ì „)
const escHtmlMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;' };
function escHtml(str) {
    if (str === null || str === undefined) return '';
    const s = String(str);
    // íŠ¹ìˆ˜ë¬¸ì ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜ (ëŒ€ë¶€ë¶„ì˜ ê²½ìš°)
    if (s.indexOf('&') === -1 && s.indexOf('<') === -1 && s.indexOf('>') === -1) return s;
    return s.replace(/[&<>]/g, c => escHtmlMap[c]);
}

// ===== ì¸ë¼ì¸ í¸ì§‘ ìœ í‹¸ë¦¬í‹° =====
// ê³µí†µ ì¸ë¼ì¸ í…ìŠ¤íŠ¸ í¸ì§‘ ìƒì„± (ì‹œíŠ¸/í´ë”/íŒŒì¼ ì´ë¦„ ë³€ê²½ì— ì‚¬ìš©)
function createInlineEdit(options) {
    const {
        targetEl,           // ì…ë ¥ í•„ë“œë¥¼ ë„£ì„ ì—˜ë¦¬ë¨¼íŠ¸
        currentValue,       // í˜„ì¬ ê°’
        styleStr,           // ìŠ¤íƒ€ì¼ ë¬¸ìì—´
        onFinish,           // ì™„ë£Œ ì½œë°± (newValue) => void
        onCancel            // ì·¨ì†Œ ì½œë°± () => void
    } = options;

    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentValue;
    input.className = 'inline-edit-input';
    input.style.cssText = styleStr || 'width:100%;padding:4px 8px;font-size:13px;border:2px solid var(--retro-teal);border-radius:4px;outline:none;box-sizing:border-box;';

    targetEl.innerHTML = '';
    targetEl.appendChild(input);
    input.focus();
    input.select();

    let finished = false;

    const finish = () => {
        if (finished) return;
        finished = true;
        const newValue = input.value.trim();
        if (newValue && newValue !== currentValue) {
            onFinish(newValue);
        } else if (onCancel) {
            onCancel();
        }
    };

    input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
            ev.preventDefault();
            finish();
        } else if (ev.key === 'Escape') {
            ev.preventDefault();
            finished = true;
            if (onCancel) onCancel();
        }
    });

    input.addEventListener('blur', () => {
        setTimeout(() => {
            if (document.contains(input) && !finished) {
                finish();
            }
        }, 100);
    });

    input.addEventListener('click', (ev) => ev.stopPropagation());

    return input;
}

function selectCell(row, col) {
    if (EDITING) finishEdit();
    
    // ë³µì‚¬ ëª¨ë“œë©´ í¸ì§‘ ë¶ˆê°€, ë°”ë¡œ ë³µì‚¬
    if (COPY_MODE) {
        const td = document.querySelector(`td.cell[data-row="${row}"][data-col="${col}"]`);
        const realIdx = td && td.dataset.realidx !== undefined ? +td.dataset.realidx : null;
        const realCol = td && td.dataset.realcol !== undefined ? +td.dataset.realcol : col;
        const value = getCellValue(row, realCol, realIdx);
        
        if (value) {
            // ì‹œìŠ¤í…œ í´ë¦½ë³´ë“œì— ë³µì‚¬
            navigator.clipboard.writeText(value).then(() => {
                toast(`ë³µì‚¬ë¨: ${value.length > 30 ? value.substring(0, 30) + '...' : value}`);
            }).catch(() => {
                fallbackCopy(value);
                toast(`ë³µì‚¬ë¨: ${value.length > 30 ? value.substring(0, 30) + '...' : value}`);
            });
        } else {
            toast('ë¹ˆ ì…€');
        }
        
        // ì„ íƒ í‘œì‹œë§Œ
        clearAllSelections();
        if (td) td.classList.add('selected');
        document.getElementById('cellAddress').value = getColLetter(realCol) + (row + 1);
        document.getElementById('formulaInput').value = value;
        SELECTED = { row, col, realIdx, realCol, fullRow: false };
        return;
    }
    
    const td = document.querySelector(`td.cell[data-row="${row}"][data-col="${col}"]`);
    const realIdx = td && td.dataset.realidx !== undefined ? +td.dataset.realidx : null;
    const realCol = td && td.dataset.realcol !== undefined ? +td.dataset.realcol : col;
    SELECTED = { row, col, realIdx, realCol, fullRow: false };
    SELECTION_START = { row, col, realIdx, realCol };
    SELECTION_END = null;
    
    // ê¸°ì¡´ ì„ íƒ í•´ì œ
    clearAllSelections();
    
    if (td) td.classList.add('selected');
    document.getElementById('cellAddress').value = getColLetter(realCol) + (row + 1);
    const cellValue = getCellValue(row, realCol, realIdx);
    document.getElementById('formulaInput').value = cellValue;
    
    // ê³„ì¢Œë²ˆí˜¸ ë˜ëŠ” ê¸ˆì•¡ ì—´ì´ë©´ ìë™ ë³µì‚¬
    if (row > 0 && cellValue) {
        const sheet = WB[SHEET];
        if (sheet) {
            const headerName = sheet.headers[realCol] || '';
            const isAccount = headerName.includes('ê³„ì¢Œ') || headerName.includes('ê³„ì¢Œë²ˆí˜¸');
            const isAmount = headerName.includes('ê¸ˆì•¡') || headerName === 'ê¸ˆì•¡';
            
            if (isAccount || isAmount) {
                let copyValue = cellValue;
                // ê¸ˆì•¡ì¸ ê²½ìš° ìˆ«ìë§Œ ì¶”ì¶œ (â‚©, ì½¤ë§ˆ ì œê±°)
                if (isAmount) {
                    copyValue = cellValue.replace(/[â‚©,ì›\s]/g, '');
                }
                // ê³„ì¢Œë²ˆí˜¸ì¸ ê²½ìš° í•˜ì´í”ˆ ì œê±° ì˜µì…˜
                if (isAccount) {
                    copyValue = cellValue.replace(/[-\s]/g, '');
                }
                
                navigator.clipboard.writeText(copyValue).then(() => {
                    const type = isAccount ? 'ê³„ì¢Œë²ˆí˜¸' : 'ê¸ˆì•¡';
                    toast(`${type} ë³µì‚¬ë¨: ${copyValue}`);
                }).catch(() => {
                    // í´ë¦½ë³´ë“œ API ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ ë°©ë²•
                    fallbackCopy(copyValue);
                    const type = isAccount ? 'ê³„ì¢Œë²ˆí˜¸' : 'ê¸ˆì•¡';
                    toast(`${type} ë³µì‚¬ë¨: ${copyValue}`);
                });
            }
        }
    }
    
    updateStatus();
}

function clearAllSelections() {
    document.querySelectorAll('td.cell.selected, td.cell.row-selected, td.cell.range-selected').forEach(td => {
        td.classList.remove('selected', 'row-selected', 'range-selected');
    });
    document.querySelectorAll('tr.row-selected').forEach(tr => tr.classList.remove('row-selected'));
    document.querySelectorAll('td.row-header.selected, td.row-header.range-selected').forEach(rh => rh.classList.remove('selected', 'range-selected'));
    document.querySelectorAll('th.col-header.selected, th.col-header.range-selected').forEach(ch => ch.classList.remove('selected', 'range-selected'));
}

function extendSelection(row, col) {
    if (!SELECTION_START) return;
    
    const td = document.querySelector(`td.cell[data-row="${row}"][data-col="${col}"]`);
    const realIdx = td && td.dataset.realidx !== undefined ? +td.dataset.realidx : null;
    const realCol = td && td.dataset.realcol !== undefined ? +td.dataset.realcol : col;
    
    SELECTION_END = { row, col, realIdx, realCol };
    
    // ê¸°ì¡´ ì„ íƒ í•´ì œ
    clearAllSelections();
    
    // ë²”ìœ„ ê³„ì‚°
    const startRow = Math.min(SELECTION_START.row, row);
    const endRow = Math.max(SELECTION_START.row, row);
    const startCol = Math.min(SELECTION_START.col, col);
    const endCol = Math.max(SELECTION_START.col, col);
    
    // ë²”ìœ„ ë‚´ ì…€ ì„ íƒ
    for (let r = startRow; r <= endRow; r++) {
        for (let c = startCol; c <= endCol; c++) {
            const cell = document.querySelector(`td.cell[data-row="${r}"][data-col="${c}"]`);
            if (cell) cell.classList.add('range-selected');
        }
    }
    
    // ì²« ë²ˆì§¸ ì…€ì€ selectedë¡œ
    const firstCell = document.querySelector(`td.cell[data-row="${SELECTION_START.row}"][data-col="${SELECTION_START.col}"]`);
    if (firstCell) firstCell.classList.add('selected');
    
    document.getElementById('cellAddress').value = `${getColLetter(SELECTION_START.realCol)}${SELECTION_START.row + 1}:${getColLetter(realCol)}${row + 1}`;
    updateStatus();
}

function extendRowSelection(row) {
    if (!SELECTION_START || SELECTION_START.type !== 'row') return;
    
    SELECTION_END = { row, type: 'row' };
    
    // ê¸°ì¡´ ì„ íƒ í•´ì œ
    clearAllSelections();
    
    // ë²”ìœ„ ê³„ì‚°
    const startRow = Math.min(SELECTION_START.row, row);
    const endRow = Math.max(SELECTION_START.row, row);
    
    // ë²”ìœ„ ë‚´ í–‰ ì„ íƒ
    for (let r = startRow; r <= endRow; r++) {
        const tr = document.querySelector(`td.row-header[data-row="${r}"]`)?.parentElement;
        if (tr) tr.classList.add('row-selected');
        const rowHeader = document.querySelector(`td.row-header[data-row="${r}"]`);
        if (rowHeader) rowHeader.classList.add('range-selected');
    }
    
    document.getElementById('cellAddress').value = `í–‰ ${startRow + 1}:${endRow + 1}`;
    updateStatus();
}

function extendColSelection(col) {
    if (!SELECTION_START || SELECTION_START.type !== 'col') return;
    
    const th = document.querySelector(`th.col-header[data-col="${col}"]`);
    const realCol = th && th.dataset.realcol !== undefined ? +th.dataset.realcol : col;
    
    SELECTION_END = { col, realCol, type: 'col' };
    
    // ê¸°ì¡´ ì„ íƒ í•´ì œ
    clearAllSelections();
    
    // ë²”ìœ„ ê³„ì‚°
    const startCol = Math.min(SELECTION_START.col, col);
    const endCol = Math.max(SELECTION_START.col, col);
    
    // ë²”ìœ„ ë‚´ ì—´ ì„ íƒ
    for (let c = startCol; c <= endCol; c++) {
        const header = document.querySelector(`th.col-header[data-col="${c}"]`);
        if (header) header.classList.add('range-selected');
        document.querySelectorAll(`td.cell[data-col="${c}"]`).forEach(td => {
            td.classList.add('range-selected');
        });
    }
    
    const sheet = WB[SHEET];
    const startRealCol = SELECTION_START.realCol;
    document.getElementById('cellAddress').value = `ì—´ ${sheet.headers[startRealCol] || ''}:${sheet.headers[realCol] || ''}`;
    updateStatus();
}

function getSelectedRange() {
    if (!SELECTION_START) return null;
    
    if (SELECTION_END) {
        if (SELECTION_START.type === 'row') {
            return {
                type: 'rows',
                startRow: Math.min(SELECTION_START.row, SELECTION_END.row),
                endRow: Math.max(SELECTION_START.row, SELECTION_END.row)
            };
        } else if (SELECTION_START.type === 'col') {
            return {
                type: 'cols',
                startCol: Math.min(SELECTION_START.col, SELECTION_END.col),
                endCol: Math.max(SELECTION_START.col, SELECTION_END.col)
            };
        } else {
            return {
                type: 'cells',
                startRow: Math.min(SELECTION_START.row, SELECTION_END.row),
                endRow: Math.max(SELECTION_START.row, SELECTION_END.row),
                startCol: Math.min(SELECTION_START.col, SELECTION_END.col),
                endCol: Math.max(SELECTION_START.col, SELECTION_END.col)
            };
        }
    }
    
    return null;
}

function fallbackCopy(text) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);
}

function selectRow(row) { 
    if (EDITING) finishEdit();
    const td = document.querySelector(`td.cell[data-row="${row}"]`);
    const realIdx = td && td.dataset.realidx !== undefined ? +td.dataset.realidx : null;
    SELECTED = { row, col: 0, realIdx, fullRow: true };
    SELECTION_START = { row, col: -1, realIdx, type: 'row' }; // col: -1ì€ í–‰ ì „ì²´ ì„ íƒ í‘œì‹œ
    SELECTION_END = null;
    
    // ê¸°ì¡´ ì„ íƒ í•´ì œ
    clearAllSelections();
    
    // í–‰ ì „ì²´ ì„ íƒ
    const tr = document.querySelector(`td.row-header[data-row="${row}"]`)?.parentElement;
    if (tr) tr.classList.add('row-selected');
    
    const rowHeader = document.querySelector(`td.row-header[data-row="${row}"]`);
    if (rowHeader) rowHeader.classList.add('selected');
    
    document.getElementById('cellAddress').value = `í–‰ ${row + 1}`;
    document.getElementById('formulaInput').value = '';
    updateStatus();
}
function selectCol(col) { 
    if (EDITING) finishEdit();
    const th = document.querySelector(`th.col-header[data-col="${col}"]`);
    const realCol = th && th.dataset.realcol !== undefined ? +th.dataset.realcol : col;
    SELECTED = { row: 0, col, realCol, fullCol: true };
    SELECTION_START = { row: -1, col, realCol, type: 'col' }; // row: -1ì€ ì—´ ì „ì²´ ì„ íƒ í‘œì‹œ
    SELECTION_END = null;
    
    // ê¸°ì¡´ ì„ íƒ í•´ì œ
    clearAllSelections();
    
    // ì—´ ì „ì²´ ì„ íƒ
    if (th) th.classList.add('selected');
    document.querySelectorAll(`td.cell[data-col="${col}"]`).forEach(td => {
        td.classList.add('range-selected');
    });
    
    const sheet = WB[SHEET];
    document.getElementById('cellAddress').value = `ì—´ ${sheet.headers[realCol] || getColLetter(realCol)}`;
    document.getElementById('formulaInput').value = '';
    updateStatus();
}

function getCellValue(row, col, realIdx) {
    const sheet = WB[SHEET];
    if (!sheet) return '';
    if (row === 0) return sheet.headers[col] || '';
    const idx = realIdx !== null && realIdx !== undefined ? realIdx : row - 1;
    if (sheet.data[idx]) return sheet.data[idx][col] || '';
    return '';
}

function setCellValue(row, col, value, realIdx) {
    const sheet = WB[SHEET];
    if (!sheet) return;
    if (row === 0) { sheet.headers[col] = value; return; }
    const idx = realIdx !== null && realIdx !== undefined ? realIdx : row - 1;
    while (sheet.data.length <= idx) sheet.data.push(new Array(sheet.headers.length).fill(''));
    while (sheet.data[idx].length <= col) sheet.data[idx].push('');
    sheet.data[idx][col] = value;
}

function startEdit(row, col) {
    // ë³µì‚¬ ëª¨ë“œë©´ í¸ì§‘ ë¶ˆê°€
    if (COPY_MODE) {
        toast('ë³µì‚¬ ëª¨ë“œì—ì„œëŠ” í¸ì§‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    selectCell(row, col);
    const td = document.querySelector(`td.cell[data-row="${row}"][data-col="${col}"]`);
    if (!td) return;
    EDITING = true;
    const value = getCellValue(row, SELECTED.realCol, SELECTED.realIdx);
    td.classList.add('editing');
    td.innerHTML = `<input type="text" value="${escAttr(value)}" id="cellInput" inputmode="text" lang="ko">`;
    const input = document.getElementById('cellInput');
    input.focus();
    input.select();
    input.onkeydown = e => {
        if (e.isComposing || e.keyCode === 229) return;
        if (e.key === 'Enter') { e.preventDefault(); finishEditAndMove('down'); }
        else if (e.key === 'Tab') { e.preventDefault(); finishEditAndMove(e.shiftKey ? 'left' : 'right'); }
        else if (e.key === 'Escape') { 
            cancelEdit(); 
            if (NEW_ENTRY_MODE) finishNewEntryMode();
        }
    };
    input.onblur = () => { setTimeout(() => { if (EDITING && document.getElementById('cellInput')) finishEditOnly(); }, 50); };
}

function finishEditAndMove(direction) {
    if (!EDITING || !SELECTED) return;
    const input = document.getElementById('cellInput');
    if (input) {
        const oldValue = getCellValue(SELECTED.row, SELECTED.realCol, SELECTED.realIdx);
        const newValue = input.value;
        if (oldValue !== newValue) {
            saveState('ì…€ í¸ì§‘');
            setCellValue(SELECTED.row, SELECTED.realCol, newValue, SELECTED.realIdx);
        }
    }
    EDITING = false;
    const sheet = WB[SHEET];
    const totalRows = sheet.data.length;
    const loadCount = Math.min((CURRENT_PAGE + 1) * PAGE_SIZE, totalRows);
    const maxRow = loadCount + 5;
    const hiddenCols = HIDDEN_COLS[SHEET] || new Set();
    const visibleCols = (COL_ORDER[SHEET] || sheet.headers.map((_, i) => i)).filter(c => !hiddenCols.has(c));
    const maxCol = visibleCols.length - 1;
    let nextRow = SELECTED.row, nextCol = SELECTED.col;
    
    // ì‹ ê·œ ì…ë ¥ ëª¨ë“œì—ì„œ ì•„ë˜ë¡œ ì´ë™ ì‹œ ìƒˆ í–‰ ìë™ ì¶”ê°€
    if (NEW_ENTRY_MODE && direction === 'down') {
        const currentLoadCount = Math.min((CURRENT_PAGE + 1) * PAGE_SIZE, sheet.data.length);
        if (SELECTED.row >= currentLoadCount) {
            // ìƒˆ í–‰ ì¶”ê°€
            saveState('ìƒˆ í–‰ ì¶”ê°€');
            const workDate = document.getElementById('workDate').value;
            const koreanDate = getKoreanDate(workDate);
            const newRow = new Array(sheet.headers.length).fill('');
            const dateColIdx = sheet.headers.findIndex(h => h.includes('ë‚ ì§œ') || h.includes('ë‚  ì§œ') || h.includes('ë‚   ì§œ') || h === 'ì¼ì');
            if (dateColIdx >= 0) newRow[dateColIdx] = koreanDate; else newRow[0] = koreanDate;
            sheet.data.push(newRow);
            renderSpreadsheet();
            renderSheetTabs();
            const newLoadCount = Math.min((CURRENT_PAGE + 1) * PAGE_SIZE, sheet.data.length);
            nextRow = newLoadCount;
            // ë‚ ì§œ ì—´ì˜ í™”ë©´ ìœ„ì¹˜ ì°¾ê¸°
            const colOrder = COL_ORDER[SHEET];
            let dateDisplayCol = visibleCols.indexOf(dateColIdx);
            if (dateDisplayCol === -1) dateDisplayCol = 0;
            const firstEmptyCol = dateDisplayCol === 0 ? 1 : 0;
            nextCol = firstEmptyCol;
            setTimeout(() => { selectCell(nextRow, nextCol); startEdit(nextRow, nextCol); }, 50);
            return;
        }
    }
    
    switch (direction) {
        case 'down': if (nextRow < maxRow) nextRow++; break;
        case 'up': if (nextRow > 0) nextRow--; break;
        case 'right': if (nextCol < maxCol) nextCol++; break;
        case 'left': if (nextCol > 0) nextCol--; break;
    }
    updateSingleCell(SELECTED.row, SELECTED.col);
    startEdit(nextRow, nextCol);
}

function finishEditOnly() {
    if (!EDITING || !SELECTED) return;
    const input = document.getElementById('cellInput');
    if (input) {
        const oldValue = getCellValue(SELECTED.row, SELECTED.realCol, SELECTED.realIdx);
        const newValue = input.value;
        if (oldValue !== newValue) {
            saveState('ì…€ í¸ì§‘');
            setCellValue(SELECTED.row, SELECTED.realCol, newValue, SELECTED.realIdx);
        }
    }
    EDITING = false;
    updateSingleCell(SELECTED.row, SELECTED.col);
}

function updateSingleCell(row, col) {
    const td = document.querySelector(`td.cell[data-row="${row}"][data-col="${col}"]`);
    if (td) { 
        td.classList.remove('editing'); 
        const realIdx = td.dataset.realidx !== undefined ? +td.dataset.realidx : null;
        const realCol = td.dataset.realcol !== undefined ? +td.dataset.realcol : col;
        td.innerHTML = `<span>${escHtml(getCellValue(row, realCol, realIdx))}</span>`; 
    }
}

function finishEdit() {
    if (!EDITING || !SELECTED) return;
    const input = document.getElementById('cellInput');
    if (input) setCellValue(SELECTED.row, SELECTED.col, input.value);
    EDITING = false;
    renderSpreadsheet();
    selectCell(SELECTED.row, SELECTED.col);
}

function cancelEdit() { EDITING = false; renderSpreadsheet(); if (SELECTED) selectCell(SELECTED.row, SELECTED.col); }

function applyFormulaInput() {
    if (!SELECTED) return;
    setCellValue(SELECTED.row, SELECTED.realCol, document.getElementById('formulaInput').value, SELECTED.realIdx);
    updateSingleCell(SELECTED.row, SELECTED.col);
}

function escAttr(str) { if (str === null || str === undefined) return ''; return String(str).replace(/"/g, '&quot;'); }

function handleKeydown(e) {
    // Ctrl+Z: ì‹¤í–‰ ì·¨ì†Œ
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        if (EDITING) finishEditOnly();
        undo();
        return;
    }
    // Ctrl+Y: ë‹¤ì‹œ ì‹¤í–‰
    if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
        e.preventDefault();
        if (EDITING) finishEditOnly();
        redo();
        return;
    }
    
    // ESCë¡œ ì‹ ê·œ ì…ë ¥ ëª¨ë“œ ì¢…ë£Œ
    if (e.key === 'Escape' && NEW_ENTRY_MODE && !EDITING) {
        finishNewEntryMode();
        e.preventDefault();
        return;
    }
    
    // ESCë¡œ ë³µì‚¬ ëª¨ë“œ ì¢…ë£Œ
    if (e.key === 'Escape' && COPY_MODE) {
        toggleCopyMode();
        e.preventDefault();
        return;
    }
    
    if (EDITING) return;
    if (!SELECTED) return;
    const { row, col, realIdx, realCol } = SELECTED;
    const sheet = WB[SHEET];
    if (!sheet) return;
    const totalRows = sheet.data.length;
    const loadCount = Math.min((CURRENT_PAGE + 1) * PAGE_SIZE, totalRows);
    const maxRow = loadCount + 5;
    const hiddenCols = HIDDEN_COLS[SHEET] || new Set();
    const visibleCols = (COL_ORDER[SHEET] || sheet.headers.map((_, i) => i)).filter(c => !hiddenCols.has(c));
    const maxCol = visibleCols.length - 1;
    switch (e.key) {
        case 'ArrowUp': if (row > 0) selectCell(row - 1, col); e.preventDefault(); break;
        case 'ArrowDown': if (row < maxRow) selectCell(row + 1, col); e.preventDefault(); break;
        case 'ArrowLeft': if (col > 0) selectCell(row, col - 1); e.preventDefault(); break;
        case 'ArrowRight': if (col < maxCol) selectCell(row, col + 1); e.preventDefault(); break;
        case 'Enter': 
            if (!COPY_MODE) startEdit(row, col); 
            e.preventDefault(); 
            break;
        case 'Delete': case 'Backspace': 
            if (!COPY_MODE) {
                saveState('ì…€ ì‚­ì œ');
                setCellValue(row, realCol, '', realIdx); 
                updateSingleCell(row, col); 
            }
            e.preventDefault(); 
            break;
        case 'Tab': if (e.shiftKey) { if (col > 0) selectCell(row, col - 1); } else { if (col < maxCol) selectCell(row, col + 1); } e.preventDefault(); break;
        default:
            if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !COPY_MODE) {
                startEdit(row, col);
                setTimeout(() => { const input = document.getElementById('cellInput'); if (input) { input.value = e.key; input.setSelectionRange(1, 1); } }, 0);
            }
    }
}

function addNewEntry() {
    const sheet = WB[SHEET];
    if (!sheet) return;
    const workDate = document.getElementById('workDate').value;
    if (!workDate) { toast('ì‘ì—…ì¼ì„ ì„ íƒí•˜ì„¸ìš”'); return; }
    
    saveState('ì‹ ê·œ ì…ë ¥');
    
    // ë¹ˆ í–‰ ë¨¼ì € ì¶”ê°€
    const emptyRow = new Array(sheet.headers.length).fill('');
    sheet.data.push(emptyRow);
    
    // ë‚ ì§œê°€ ì…ë ¥ëœ í–‰ ì¶”ê°€
    const koreanDate = getKoreanDate(workDate);
    const newRow = new Array(sheet.headers.length).fill('');
    const dateColIdx = sheet.headers.findIndex(h => h.includes('ë‚ ì§œ') || h.includes('ë‚  ì§œ') || h.includes('ë‚   ì§œ') || h === 'ì¼ì');
    if (dateColIdx >= 0) newRow[dateColIdx] = koreanDate; else newRow[0] = koreanDate;
    sheet.data.push(newRow);
    
    CURRENT_PAGE = 0; // ìµœì‹  í˜ì´ì§€ë¡œ ë¦¬ì…‹
    
    // ì‹ ê·œ ì…ë ¥ ëª¨ë“œ ON
    NEW_ENTRY_MODE = true;
    const finishBtn = document.getElementById('finishEntryBtn');
    if (finishBtn) finishBtn.style.display = 'inline-flex';
    document.body.style.borderTop = '3px solid #4CAF50';
    
    renderSpreadsheet();
    renderSheetTabs();
    // ìƒˆë¡œ ì¶”ê°€ëœ í–‰ì€ í™”ë©´ì—ì„œ ë§ˆì§€ë§‰ ë°ì´í„° í–‰
    const totalRows = sheet.data.length;
    const loadCount = Math.min(PAGE_SIZE, totalRows);
    const newDisplayRow = loadCount; // ìƒˆ í•­ëª©ì˜ í™”ë©´ í–‰ ë²ˆí˜¸
    const hiddenCols = HIDDEN_COLS[SHEET] || new Set();
    const visibleCols = (COL_ORDER[SHEET] || sheet.headers.map((_, i) => i)).filter(c => !hiddenCols.has(c));
    let dateDisplayCol = visibleCols.indexOf(dateColIdx);
    if (dateDisplayCol === -1) dateDisplayCol = 0;
    const firstEmptyCol = dateDisplayCol === 0 ? 1 : 0;
    setTimeout(() => { selectCell(newDisplayRow, firstEmptyCol); startEdit(newDisplayRow, firstEmptyCol); }, 100);
    toast('ì‹ ê·œ ì…ë ¥ ëª¨ë“œ (ESC: ì¢…ë£Œ, ë‹¤ë¥¸ ì‹œíŠ¸ ì´ë™: ì¢…ë£Œ)');
}

function finishNewEntryMode() {
    if (!NEW_ENTRY_MODE) return;
    NEW_ENTRY_MODE = false;
    const finishBtn = document.getElementById('finishEntryBtn');
    if (finishBtn) finishBtn.style.display = 'none';
    document.body.style.borderTop = 'none';
    if (EDITING) finishEditOnly();
    toast('ì…ë ¥ ì™„ë£Œ');
}

function insertRow() { if (!SELECTED) { toast('ì…€ì„ ì„ íƒí•˜ì„¸ìš”'); return; } insertRowBelow(); }

function insertRowAbove() {
    if (!SELECTED) return;
    if (SELECTED.row === 0) { toast('í—¤ë” ìœ„ì—ëŠ” í–‰ì„ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤'); return; }
    const sheet = WB[SHEET];
    const realIdx = SELECTED.realIdx;
    if (realIdx !== null && realIdx !== undefined) {
        saveState('í–‰ ì‚½ì…');
        sheet.data.splice(realIdx + 1, 0, new Array(sheet.headers.length).fill(''));
    }
    renderSpreadsheet(); renderSheetTabs(); toast('í–‰ ì¶”ê°€ë¨');
}

function insertRowBelow() {
    if (!SELECTED) return;
    const sheet = WB[SHEET];
    saveState('í–‰ ì‚½ì…');
    if (SELECTED.row === 0) {
        sheet.data.push(new Array(sheet.headers.length).fill(''));
    } else {
        const realIdx = SELECTED.realIdx;
        if (realIdx !== null && realIdx !== undefined) {
            sheet.data.splice(realIdx, 0, new Array(sheet.headers.length).fill(''));
        }
    }
    renderSpreadsheet(); renderSheetTabs(); toast('í–‰ ì¶”ê°€ë¨');
}

function insertCol() { if (!SELECTED) { toast('ì…€ì„ ì„ íƒí•˜ì„¸ìš”'); return; } insertColRight(); }

function insertColLeft() {
    if (!SELECTED) return;
    const colName = prompt('ìƒˆ ì—´ ì´ë¦„:', 'ìƒˆì—´');
    if (!colName) return;
    const sheet = WB[SHEET];
    const realCol = SELECTED.realCol !== undefined ? SELECTED.realCol : SELECTED.col;
    saveState('ì—´ ì‚½ì…');
    sheet.headers.splice(realCol, 0, colName);
    sheet.data.forEach(row => row.splice(realCol, 0, ''));
    // ì—´ ìˆœì„œ ì—…ë°ì´íŠ¸
    COL_ORDER[SHEET] = sheet.headers.map((_, i) => i);
    renderSpreadsheet(); toast('ì—´ ì¶”ê°€ë¨');
}

function insertColRight() {
    if (!SELECTED) return;
    const colName = prompt('ìƒˆ ì—´ ì´ë¦„:', 'ìƒˆì—´');
    if (!colName) return;
    const sheet = WB[SHEET];
    const realCol = SELECTED.realCol !== undefined ? SELECTED.realCol : SELECTED.col;
    saveState('ì—´ ì‚½ì…');
    sheet.headers.splice(realCol + 1, 0, colName);
    sheet.data.forEach(row => row.splice(realCol + 1, 0, ''));
    // ì—´ ìˆœì„œ ì—…ë°ì´íŠ¸
    COL_ORDER[SHEET] = sheet.headers.map((_, i) => i);
    renderSpreadsheet(); toast('ì—´ ì¶”ê°€ë¨');
}

function deleteSelected() { if (!SELECTED) { toast('ì…€ì„ ì„ íƒí•˜ì„¸ìš”'); return; } deleteRow(); }

function deleteRow() {
    if (!SELECTED) return;
    if (SELECTED.row === 0) { toast('í—¤ë” í–‰ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤'); return; }
    
    const sheet = WB[SHEET];
    const range = getSelectedRange();
    
    // ë²”ìœ„ ì„ íƒëœ ê²½ìš°
    if (range && range.type === 'rows') {
        const count = range.endRow - range.startRow + 1;
        if (!confirm(`${range.startRow + 2}~${range.endRow + 2}ë²ˆ í–‰ (${count}ê°œ)ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
        
        saveState('ë‹¤ì¤‘ í–‰ ì‚­ì œ');
        
        // ë’¤ì—ì„œë¶€í„° ì‚­ì œ (ì¸ë±ìŠ¤ ê¼¬ì„ ë°©ì§€)
        const startRealIdx = document.querySelector(`td.row-header[data-row="${range.startRow}"]`)?.dataset.realidx;
        const endRealIdx = document.querySelector(`td.row-header[data-row="${range.endRow}"]`)?.dataset.realidx;
        
        if (startRealIdx !== undefined && endRealIdx !== undefined) {
            const start = Math.min(+startRealIdx, +endRealIdx);
            const end = Math.max(+startRealIdx, +endRealIdx);
            sheet.data.splice(start, end - start + 1);
        }
        
        SELECTED = null;
        SELECTION_START = null;
        SELECTION_END = null;
        renderSpreadsheet(); 
        renderSheetTabs(); 
        toast(`${count}ê°œ í–‰ ì‚­ì œë¨`);
        return;
    }
    
    // ë‹¨ì¼ í–‰ ì‚­ì œ
    const realIdx = SELECTED.realIdx;
    if (realIdx !== null && realIdx !== undefined && realIdx >= 0 && realIdx < sheet.data.length) {
        const rowNum = realIdx + 2;
        if (!confirm(`${rowNum}ë²ˆ í–‰ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
        saveState('í–‰ ì‚­ì œ');
        sheet.data.splice(realIdx, 1);
        SELECTED = null;
        SELECTION_START = null;
        SELECTION_END = null;
        renderSpreadsheet(); renderSheetTabs(); toast('í–‰ ì‚­ì œë¨');
    }
}

function deleteCol() {
    if (!SELECTED) return;
    const sheet = WB[SHEET];
    if (sheet.headers.length <= 1) { toast('ë§ˆì§€ë§‰ ì—´ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤'); return; }
    const realCol = SELECTED.realCol !== undefined ? SELECTED.realCol : SELECTED.col;
    if (!confirm(`'${sheet.headers[realCol]}' ì—´ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
    saveState('ì—´ ì‚­ì œ');
    sheet.headers.splice(realCol, 1);
    sheet.data.forEach(row => row.splice(realCol, 1));
    // ì—´ ìˆœì„œ ì—…ë°ì´íŠ¸
    COL_ORDER[SHEET] = sheet.headers.map((_, i) => i);
    HIDDEN_COLS[SHEET] = new Set();
    renderSpreadsheet(); toast('ì—´ ì‚­ì œë¨');
}

function toggleCopyMode() {
    COPY_MODE = !COPY_MODE;
    const btn = document.getElementById('copyModeBtn');
    
    if (COPY_MODE) {
        btn.classList.add('copy-mode-active');
        document.body.classList.add('copy-mode');
        toast('ë³µì‚¬ ëª¨ë“œ ON - ì…€ í´ë¦­ ì‹œ ìë™ ë³µì‚¬');
    } else {
        btn.classList.remove('copy-mode-active');
        document.body.classList.remove('copy-mode');
        toast('ë³µì‚¬ ëª¨ë“œ OFF');
    }
    updateStatus();
}

function copyCell() { 
    if (!SELECTED) return; 
    CLIPBOARD = getCellValue(SELECTED.row, SELECTED.realCol || SELECTED.col, SELECTED.realIdx);
    toast('ë³µì‚¬ë¨'); 
}

function pasteCell() {
    if (!SELECTED || CLIPBOARD === null) return;
    saveState('ë¶™ì—¬ë„£ê¸°');
    setCellValue(SELECTED.row, SELECTED.realCol || SELECTED.col, CLIPBOARD, SELECTED.realIdx);
    updateSingleCell(SELECTED.row, SELECTED.col); 
    toast('ë¶™ì—¬ë„£ê¸°ë¨');
}

function showCellContextMenu(e, row, col) {
    selectCell(row, col);
    document.getElementById('colContextMenu')?.classList.remove('show');
    document.getElementById('rowContextMenu')?.classList.remove('show');
    const menu = document.getElementById('contextMenu');
    menu.style.left = e.pageX + 'px';
    menu.style.top = e.pageY + 'px';
    menu.classList.add('show');
}

function showColContextMenu(e, col) {
    selectCell(0, col);
    document.getElementById('contextMenu')?.classList.remove('show');
    document.getElementById('rowContextMenu')?.classList.remove('show');
    const menu = document.getElementById('colContextMenu');
    if (!menu) return;
    menu.style.left = e.pageX + 'px';
    menu.style.top = e.pageY + 'px';
    menu.classList.add('show');
}

function showRowContextMenu(e, row) {
    selectRow(row);
    document.getElementById('contextMenu')?.classList.remove('show');
    document.getElementById('colContextMenu')?.classList.remove('show');
    const menu = document.getElementById('rowContextMenu');
    if (!menu) return;
    menu.style.left = e.pageX + 'px';
    menu.style.top = e.pageY + 'px';
    menu.classList.add('show');
}

function hideSelectedCol() {
    if (!SELECTED) return;
    const realCol = SELECTED.realCol;
    if (realCol === undefined) return;
    
    if (!HIDDEN_COLS[SHEET]) {
        HIDDEN_COLS[SHEET] = new Set();
    }
    
    const sheet = WB[SHEET];
    if (HIDDEN_COLS[SHEET].size >= sheet.headers.length - 1) {
        toast('ìµœì†Œ 1ê°œ ì—´ì€ í‘œì‹œí•´ì•¼ í•©ë‹ˆë‹¤');
        return;
    }
    
    HIDDEN_COLS[SHEET].add(realCol);
    renderSpreadsheet();
    toast(`'${sheet.headers[realCol]}' ì—´ ìˆ¨ê¹€`);
}

let ROW_CLIPBOARD = null;

function copyRow() {
    if (!SELECTED || SELECTED.row === 0) {
        toast('ë³µì‚¬í•  í–‰ì„ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    const sheet = WB[SHEET];
    const realIdx = SELECTED.realIdx;
    if (realIdx !== null && realIdx !== undefined && sheet.data[realIdx]) {
        ROW_CLIPBOARD = [...sheet.data[realIdx]];
        toast('í–‰ ë³µì‚¬ë¨');
    }
}

function pasteRow() {
    if (!SELECTED || !ROW_CLIPBOARD) {
        toast('ë¶™ì—¬ë„£ì„ í–‰ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    if (SELECTED.row === 0) {
        toast('í—¤ë” í–‰ì—ëŠ” ë¶™ì—¬ë„£ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    const sheet = WB[SHEET];
    const realIdx = SELECTED.realIdx;
    if (realIdx !== null && realIdx !== undefined) {
        saveState('í–‰ ë¶™ì—¬ë„£ê¸°');
        sheet.data[realIdx] = [...ROW_CLIPBOARD];
        renderSpreadsheet();
        toast('í–‰ ë¶™ì—¬ë„£ê¸° ì™„ë£Œ');
    }
}

function updateStatus() {
    const sheet = WB[SHEET];
    if (!sheet) return;
    
    const totalRows = sheet.data.length;
    const totalPages = Math.ceil(totalRows / PAGE_SIZE) || 1;
    const modeText = NEW_ENTRY_MODE ? ' [ì‹ ê·œ ì…ë ¥ ëª¨ë“œ]' : (COPY_MODE ? ' [ë³µì‚¬ ëª¨ë“œ]' : '');
    const hiddenCount = HIDDEN_COLS[SHEET] ? HIDDEN_COLS[SHEET].size : 0;
    const hiddenText = hiddenCount > 0 ? ` (${hiddenCount}ê°œ ìˆ¨ê¹€)` : '';
    
    const statusLeft = document.getElementById('statusLeft');
    const statusRight = document.getElementById('statusRight');
    if (statusLeft) statusLeft.textContent = `í˜„ì¬ ì‹œíŠ¸: ${SHEET}${modeText}`;
    if (statusRight) statusRight.textContent = `ì „ì²´ ${totalRows}ê±´ | ì—´: ${sheet.headers.length}${hiddenText}`;
    
    // í˜ì´ì§€ ë„¤ë¹„ê²Œì´í„° ì—…ë°ì´íŠ¸
    updatePageNavigator();
}

function updatePageNavigator() {
    const sheet = WB[SHEET];
    if (!sheet) return;
    
    const totalRows = sheet.data.length;
    const totalPages = Math.ceil(totalRows / PAGE_SIZE) || 1;
    const container = document.getElementById('pageNavNumbers');
    const navigator = document.getElementById('pageNavigator');
    
    if (totalPages <= 1) {
        navigator.style.display = 'none';
        return;
    }
    
    navigator.style.display = 'flex';
    
    // ìµœëŒ€ 15ê°œ í˜ì´ì§€ ë²„íŠ¼
    const maxButtons = 15;
    const displayPages = Math.min(totalPages, maxButtons);
    
    // í˜„ì¬ í˜ì´ì§€ë¥¼ 1ë¶€í„° ì‹œì‘í•˜ëŠ” ë²ˆí˜¸ë¡œ ë³€í™˜ (1 = ìµœìƒë‹¨)
    const currentPageNum = totalPages - CURRENT_PAGE;
    
    let html = '';
    for (let i = 1; i <= displayPages; i++) {
        const pageIndex = totalPages - i; // 1ë²ˆ = ìµœìƒë‹¨(ê³¼ê±°), í° ë²ˆí˜¸ = ìµœí•˜ë‹¨(ìµœì‹ )
        const isActive = pageIndex === CURRENT_PAGE ? 'active' : '';
        html += `<button class="page-num-btn ${isActive}" onclick="goToPage(${pageIndex})">${i}</button>`;
    }
    
    if (totalPages > maxButtons) {
        html += `<button class="page-num-btn" onclick="showMorePages()" title="ë”ë³´ê¸°">...</button>`;
    }
    
    container.innerHTML = html;
}

function goToPage(pageIndex) {
    const sheet = WB[SHEET];
    if (!sheet) return;
    const totalPages = Math.ceil(sheet.data.length / PAGE_SIZE) || 1;
    
    if (pageIndex < 0) pageIndex = 0;
    if (pageIndex >= totalPages) pageIndex = totalPages - 1;
    
    CURRENT_PAGE = pageIndex;
    renderSpreadsheet();
}

function goToTop() {
    // ìµœìƒë‹¨ = 1í˜ì´ì§€ = ê°€ì¥ ê³¼ê±° ë°ì´í„°
    const sheet = WB[SHEET];
    if (!sheet) return;
    const totalPages = Math.ceil(sheet.data.length / PAGE_SIZE) || 1;
    CURRENT_PAGE = totalPages - 1;
    renderSpreadsheet();
    document.getElementById('spreadsheetContainer').scrollTop = 0;
}

function goToBottom() {
    // ìµœí•˜ë‹¨ = ë§ˆì§€ë§‰ í˜ì´ì§€ = ê°€ì¥ ìµœì‹  ë°ì´í„°
    CURRENT_PAGE = 0;
    renderSpreadsheet();
    const container = document.getElementById('spreadsheetContainer');
    container.scrollTop = container.scrollHeight;
}

function showMorePages() {
    const sheet = WB[SHEET];
    if (!sheet) return;
    const totalPages = Math.ceil(sheet.data.length / PAGE_SIZE) || 1;
    const currentPageNum = totalPages - CURRENT_PAGE;
    
    const pageNum = prompt(`ì´ë™í•  í˜ì´ì§€ ë²ˆí˜¸ ì…ë ¥ (1~${totalPages}):\n1 = ìµœìƒë‹¨, ${totalPages} = ìµœí•˜ë‹¨`, currentPageNum);
    if (pageNum) {
        const num = parseInt(pageNum, 10);
        if (!isNaN(num) && num >= 1 && num <= totalPages) {
            goToPage(totalPages - num);
        } else {
            toast('ì˜ëª»ëœ í˜ì´ì§€ ë²ˆí˜¸ì…ë‹ˆë‹¤');
        }
    }
}

function showLoading(text) { const lt = document.getElementById('loadingText'); const ld = document.getElementById('loading'); if (lt) lt.textContent = text; if (ld) ld.classList.add('show'); }
function hideLoading() { const ld = document.getElementById('loading'); if (ld) ld.classList.remove('show'); }
function toast(msg) { const t = document.getElementById('toast'); if (!t) return; t.textContent = msg; t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 2000); }

// ========== íœ´ì§€í†µ ì‹œìŠ¤í…œ ==========

// íœ´ì§€í†µìœ¼ë¡œ ì´ë™
function moveToTrash(name) {
    const sheet = WB[name];
    if (!sheet) return;

    // íœ´ì§€í†µì— ì €ì¥
    const trashItem = {
        name: name,
        data: JSON.parse(JSON.stringify(sheet.data)),
        headers: sheet.headers ? [...sheet.headers] : [],
        colOrder: COL_ORDER[name] ? [...COL_ORDER[name]] : null,
        hiddenCols: HIDDEN_COLS[name] ? [...HIDDEN_COLS[name]] : null,
        colWidths: COL_WIDTHS[name] ? {...COL_WIDTHS[name]} : null,
        rowHeights: ROW_HEIGHTS[name] ? {...ROW_HEIGHTS[name]} : null,
        folderId: sheetToFolder[name] || null,
        isFavorite: favoriteSheets?.has(name) || false,
        deletedAt: Date.now()
    };

    trashBin.unshift(trashItem);

    // ìµœëŒ€ ê°œìˆ˜ ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ í•­ëª© ì‚­ì œ
    if (trashBin.length > MAX_TRASH_ITEMS) {
        trashBin = trashBin.slice(0, MAX_TRASH_ITEMS);
    }

    // ë§Œë£Œëœ í•­ëª© ì •ë¦¬
    cleanExpiredTrash();

    // íœ´ì§€í†µ ì €ì¥ ë° UI ì—…ë°ì´íŠ¸
    saveTrashToStorage();
    updateTrashCount();
}

// íœ´ì§€í†µì—ì„œ ë³µì›
function restoreFromTrash(index) {
    if (index < 0 || index >= trashBin.length) return;

    const item = trashBin[index];

    // ê°™ì€ ì´ë¦„ì˜ ì‹œíŠ¸ê°€ ìˆìœ¼ë©´ ë²ˆí˜¸ ë¶™ì´ê¸°
    let newName = item.name;
    let counter = 1;
    while (WB[newName]) {
        newName = `${item.name}(ë³µì›${counter})`;
        counter++;
    }

    // ì‹œíŠ¸ ë³µì›
    WB[newName] = {
        data: item.data,
        headers: item.headers || []
    };
    if (item.colOrder) COL_ORDER[newName] = item.colOrder;
    if (item.hiddenCols) HIDDEN_COLS[newName] = item.hiddenCols;
    if (item.colWidths) COL_WIDTHS[newName] = item.colWidths;
    if (item.rowHeights) ROW_HEIGHTS[newName] = item.rowHeights;
    if (item.folderId) sheetToFolder[newName] = item.folderId;
    if (item.isFavorite && favoriteSheets) favoriteSheets.add(newName);

    // íœ´ì§€í†µì—ì„œ ì œê±°
    trashBin.splice(index, 1);
    saveTrashToStorage();
    updateTrashCount();
    saveFolderData();

    // UI ì—…ë°ì´íŠ¸
    renderMainScreen();
    renderTrashList();

    toast(`"${newName}" ë³µì› ì™„ë£Œ!`);
    hasUnsavedChanges = true;
}

// íœ´ì§€í†µì—ì„œ ì˜êµ¬ ì‚­ì œ
function deleteFromTrash(index) {
    if (index < 0 || index >= trashBin.length) return;

    const item = trashBin[index];
    if (confirm(`"${item.name}"ì„(ë¥¼) ì˜êµ¬ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nâš ï¸ ë³µì›í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`)) {
        trashBin.splice(index, 1);
        saveTrashToStorage();
        updateTrashCount();
        renderTrashList();
        toast('ì˜êµ¬ ì‚­ì œ ì™„ë£Œ');
    }
}

// íœ´ì§€í†µ ë¹„ìš°ê¸°
function emptyTrash() {
    if (trashBin.length === 0) {
        toast('íœ´ì§€í†µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤');
        return;
    }
    if (confirm(`íœ´ì§€í†µì˜ ${trashBin.length}ê°œ í•­ëª©ì„ ëª¨ë‘ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nâš ï¸ ë³µì›í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`)) {
        trashBin = [];
        saveTrashToStorage();
        updateTrashCount();
        renderTrashList();
        toast('íœ´ì§€í†µ ë¹„ìš°ê¸° ì™„ë£Œ');
    }
}

// ë§Œë£Œëœ í•­ëª© ì •ë¦¬
function cleanExpiredTrash() {
    const now = Date.now();
    const expireMs = TRASH_EXPIRE_DAYS * 24 * 60 * 60 * 1000;
    trashBin = trashBin.filter(item => (now - item.deletedAt) < expireMs);
}

// íœ´ì§€í†µ ê°œìˆ˜ ì—…ë°ì´íŠ¸
function updateTrashCount() {
    const countEl = document.getElementById('trashCount');
    if (countEl) {
        if (trashBin.length > 0) {
            countEl.textContent = trashBin.length;
            countEl.style.display = 'inline';
        } else {
            countEl.style.display = 'none';
        }
    }
}

// íœ´ì§€í†µ ëª¨ë‹¬ ì—´ê¸°
function openTrashModal() {
    cleanExpiredTrash();
    renderTrashList();
    document.getElementById('trashModal').classList.add('show');
}

// íœ´ì§€í†µ ëª¨ë‹¬ ë‹«ê¸°
function closeTrashModal() {
    document.getElementById('trashModal').classList.remove('show');
}

// íœ´ì§€í†µ ëª©ë¡ ë Œë”ë§
function renderTrashList() {
    const list = document.getElementById('trashList');
    if (!list) return;

    if (trashBin.length === 0) {
        list.innerHTML = '<div class="trash-empty-state">ğŸ—‘ï¸ íœ´ì§€í†µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</div>';
        return;
    }

    const now = Date.now();
    list.innerHTML = trashBin.map((item, idx) => {
        const deletedAgo = getTimeAgo(item.deletedAt);
        const daysLeft = Math.ceil((TRASH_EXPIRE_DAYS * 24 * 60 * 60 * 1000 - (now - item.deletedAt)) / (24 * 60 * 60 * 1000));
        const dataCount = item.data?.length || 0;

        return `
            <div class="trash-item">
                <div class="trash-item-info">
                    <div class="trash-item-name">ğŸ“„ ${escHtml(item.name)}</div>
                    <div class="trash-item-meta">${dataCount}ê±´ Â· ì‚­ì œ: ${deletedAgo} Â· ${daysLeft}ì¼ í›„ ìë™ì‚­ì œ</div>
                </div>
                <div class="trash-item-actions">
                    <button class="trash-restore-btn" onclick="restoreFromTrash(${idx})">â†©ï¸ ë³µì›</button>
                    <button class="trash-delete-btn" onclick="deleteFromTrash(${idx})">âœ•</button>
                </div>
            </div>
        `;
    }).join('');
}

// ì‹œê°„ ê²½ê³¼ í‘œì‹œ
function getTimeAgo(timestamp) {
    const diff = Date.now() - timestamp;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return 'ë°©ê¸ˆ ì „';
    if (minutes < 60) return `${minutes}ë¶„ ì „`;
    if (hours < 24) return `${hours}ì‹œê°„ ì „`;
    return `${days}ì¼ ì „`;
}

// ë˜ëŒë¦¬ê¸° í† ìŠ¤íŠ¸ í‘œì‹œ
function showUndoToast(name, dataCount) {
    const toastEl = document.getElementById('toast');
    toastEl.innerHTML = `
        <span>"${escHtml(name)}" ì‚­ì œë¨ (${dataCount}ê±´)</span>
        <button class="undo-btn" onclick="undoLastDelete()">â†©ï¸ ë˜ëŒë¦¬ê¸°</button>
    `;
    toastEl.classList.add('show', 'undo-toast');
    setTimeout(() => {
        toastEl.classList.remove('show', 'undo-toast');
        toastEl.innerHTML = '';
    }, 5000);
}

// ë§ˆì§€ë§‰ ì‚­ì œ ë˜ëŒë¦¬ê¸°
function undoLastDelete() {
    if (trashBin.length === 0) return;
    restoreFromTrash(0);
    const toastEl = document.getElementById('toast');
    toastEl.classList.remove('show', 'undo-toast');
}

// íœ´ì§€í†µ ë¡œì»¬ ì €ì¥
function saveTrashToStorage() {
    try {
        localStorage.setItem('excelmaster_trash', JSON.stringify(trashBin));
    } catch (e) {
        console.warn('íœ´ì§€í†µ ì €ì¥ ì‹¤íŒ¨:', e);
    }
}

// íœ´ì§€í†µ ë¡œì»¬ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°
function loadTrashFromStorage() {
    try {
        const saved = localStorage.getItem('excelmaster_trash');
        if (saved) {
            trashBin = JSON.parse(saved);
            cleanExpiredTrash();
            updateTrashCount();
        }
    } catch (e) {
        console.warn('íœ´ì§€í†µ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
        trashBin = [];
    }
}

// ========== ìë™ ì €ì¥ ì‹œìŠ¤í…œ ==========

// ìë™ ì €ì¥ ì‹œì‘
function startAutoSave() {
    if (autoSaveTimer) clearInterval(autoSaveTimer);

    if (!autoSaveEnabled) {
        updateAutoSaveStatus('OFF');
        return;
    }

    autoSaveTimer = setInterval(async () => {
        if (hasUnsavedChanges && currentUser) {
            await performAutoSave();
        }
    }, autoSaveInterval * 60 * 1000);

    updateAutoSaveStatus('ON');
}

// ìë™ ì €ì¥ ì‹¤í–‰
async function performAutoSave() {
    try {
        updateAutoSaveStatus('ì €ì¥ ì¤‘...');

        // í˜„ì¬ íƒ­ì— ë”°ë¼ ì €ì¥
        switch (currentMainTab) {
            case 'sheets':
                await saveAllToFirestore();
                break;
            case 'files':
                await saveAllToFirestore();
                break;
            case 'rawfiles':
                await saveRawFilesToFirestore();
                break;
        }

        lastAutoSave = Date.now();
        hasUnsavedChanges = false;
        updateAutoSaveStatus('ì €ì¥ë¨ âœ“');

        setTimeout(() => {
            if (autoSaveEnabled) updateAutoSaveStatus('ON');
        }, 2000);
    } catch (e) {
        console.error('ìë™ ì €ì¥ ì‹¤íŒ¨:', e);
        updateAutoSaveStatus('ì‹¤íŒ¨ âš ï¸');
        setTimeout(() => {
            if (autoSaveEnabled) updateAutoSaveStatus('ON');
        }, 3000);
    }
}

// ìë™ ì €ì¥ ìƒíƒœ ì—…ë°ì´íŠ¸
function updateAutoSaveStatus(status) {
    const textEl = document.getElementById('autoSaveText');
    const statusEl = document.getElementById('autoSaveStatus');

    if (textEl) {
        if (status === 'ON') {
            textEl.textContent = `ìë™ì €ì¥ ${autoSaveInterval}ë¶„`;
            statusEl?.classList.remove('saving', 'error', 'disabled');
        } else if (status === 'OFF') {
            textEl.textContent = 'ìë™ì €ì¥ OFF';
            statusEl?.classList.add('disabled');
            statusEl?.classList.remove('saving', 'error');
        } else if (status === 'ì €ì¥ ì¤‘...') {
            textEl.textContent = 'ì €ì¥ ì¤‘...';
            statusEl?.classList.add('saving');
            statusEl?.classList.remove('error', 'disabled');
        } else if (status === 'ì €ì¥ë¨ âœ“') {
            textEl.textContent = 'ì €ì¥ë¨ âœ“';
            statusEl?.classList.remove('saving', 'error', 'disabled');
        } else if (status === 'ì‹¤íŒ¨ âš ï¸') {
            textEl.textContent = 'ì €ì¥ ì‹¤íŒ¨';
            statusEl?.classList.add('error');
            statusEl?.classList.remove('saving', 'disabled');
        }
    }
}

// ìë™ ì €ì¥ í† ê¸€
function toggleAutoSave(enabled) {
    autoSaveEnabled = enabled;
    saveAutoSaveSettings();
    startAutoSave();
    toast(enabled ? 'ìë™ ì €ì¥ í™œì„±í™”' : 'ìë™ ì €ì¥ ë¹„í™œì„±í™”');
}

// ìë™ ì €ì¥ ê°„ê²© ì„¤ì •
function setAutoSaveInterval(minutes) {
    autoSaveInterval = parseInt(minutes);
    saveAutoSaveSettings();
    startAutoSave();
    toast(`ìë™ ì €ì¥ ê°„ê²©: ${minutes}ë¶„`);
}

// ìë™ ì €ì¥ ì„¤ì • ì €ì¥
function saveAutoSaveSettings() {
    try {
        localStorage.setItem('excelmaster_autosave', JSON.stringify({
            enabled: autoSaveEnabled,
            interval: autoSaveInterval
        }));
    } catch (e) {
        console.warn('ìë™ ì €ì¥ ì„¤ì • ì €ì¥ ì‹¤íŒ¨:', e);
    }
}

// ìë™ ì €ì¥ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
function loadAutoSaveSettings() {
    try {
        const saved = localStorage.getItem('excelmaster_autosave');
        if (saved) {
            const settings = JSON.parse(saved);
            autoSaveEnabled = settings.enabled !== false;
            autoSaveInterval = settings.interval || 5;

            // UI ì—…ë°ì´íŠ¸
            const toggle = document.getElementById('autoSaveToggle');
            const select = document.getElementById('autoSaveIntervalSelect');
            if (toggle) toggle.checked = autoSaveEnabled;
            if (select) select.value = autoSaveInterval;
        }
    } catch (e) {
        console.warn('ìë™ ì €ì¥ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
    }
}

// ìë™ ì €ì¥ ëª¨ë‹¬ ì—´ê¸°
function openAutoSaveModal() {
    const lastInfo = document.getElementById('autoSaveLastInfo');
    if (lastInfo) {
        lastInfo.textContent = lastAutoSave
            ? `ë§ˆì§€ë§‰ ìë™ì €ì¥: ${getTimeAgo(lastAutoSave)}`
            : 'ë§ˆì§€ë§‰ ìë™ì €ì¥: -';
    }
    document.getElementById('autoSaveModal').classList.add('show');
}

// ìë™ ì €ì¥ ëª¨ë‹¬ ë‹«ê¸°
function closeAutoSaveModal() {
    document.getElementById('autoSaveModal').classList.remove('show');
}

// ë³€ê²½ì‚¬í•­ ê°ì§€ (ë°ì´í„° ë³€ê²½ ì‹œ í˜¸ì¶œ)
function markAsChanged() {
    hasUnsavedChanges = true;
}

// ========== íŒŒì¼ ê·¸ë£¹ ì‹œìŠ¤í…œ ==========

// íŒŒì¼ ê·¸ë£¹ì— ì‹œíŠ¸ ë“±ë¡
function registerFileGroup(fileName, sheetNames) {
    const fileId = 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

    // ê¸°ì¡´ì— ê°™ì€ íŒŒì¼ëª…ì´ ìˆìœ¼ë©´ í•´ë‹¹ ê·¸ë£¹ì— ì¶”ê°€
    const existingFileId = Object.keys(fileGroups).find(id => fileGroups[id].name === fileName);

    if (existingFileId) {
        // ê¸°ì¡´ ê·¸ë£¹ì— ì‹œíŠ¸ ì¶”ê°€
        sheetNames.forEach(sheetName => {
            if (!fileGroups[existingFileId].sheets.includes(sheetName)) {
                fileGroups[existingFileId].sheets.push(sheetName);
            }
            sheetToFileGroup[sheetName] = existingFileId;
        });
    } else {
        // ìƒˆ íŒŒì¼ ê·¸ë£¹ ìƒì„±
        fileGroups[fileId] = {
            name: fileName,
            uploadedAt: Date.now(),
            sheets: [...sheetNames]
        };
        sheetNames.forEach(sheetName => {
            sheetToFileGroup[sheetName] = fileId;
        });
    }

    saveFileGroupsToStorage();
}

// íŒŒì¼ ê·¸ë£¹ì—ì„œ ì‹œíŠ¸ ì œê±°
function removeSheetFromFileGroup(sheetName) {
    const fileId = sheetToFileGroup[sheetName];
    if (!fileId || !fileGroups[fileId]) return;

    // ì‹œíŠ¸ ëª©ë¡ì—ì„œ ì œê±°
    const idx = fileGroups[fileId].sheets.indexOf(sheetName);
    if (idx > -1) {
        fileGroups[fileId].sheets.splice(idx, 1);
    }

    // ì‹œíŠ¸-íŒŒì¼ ë§¤í•‘ ì œê±°
    delete sheetToFileGroup[sheetName];

    // íŒŒì¼ ê·¸ë£¹ì— ì‹œíŠ¸ê°€ ì—†ìœ¼ë©´ ê·¸ë£¹ ì‚­ì œ
    if (fileGroups[fileId].sheets.length === 0) {
        delete fileGroups[fileId];
        collapsedFileGroups.delete(fileId);
    }

    saveFileGroupsToStorage();
}

// íŒŒì¼ ê·¸ë£¹ ì „ì²´ ì‚­ì œ
function deleteFileGroup(fileId) {
    const group = fileGroups[fileId];
    if (!group || !group.sheets) return;

    const sheetCount = group.sheets.length;
    if (!confirm(`"${group.name}" íŒŒì¼ì˜ ${sheetCount}ê°œ ì‹œíŠ¸ë¥¼ ëª¨ë‘ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
        return;
    }

    // íœ´ì§€í†µì— ì €ì¥ í›„ ì‚­ì œ
    group.sheets.forEach(sheetName => {
        if (WB[sheetName]) {
            moveToTrash(sheetName);
            delete WB[sheetName];
            delete COL_ORDER[sheetName];
            delete HIDDEN_COLS[sheetName];
            delete COL_WIDTHS[sheetName];
            delete ROW_HEIGHTS[sheetName];
            delete sheetToFolder[sheetName];
            if (favoriteSheets) favoriteSheets.delete(sheetName);
        }
        delete sheetToFileGroup[sheetName];
    });

    delete fileGroups[fileId];
    collapsedFileGroups.delete(fileId);

    saveFileGroupsToStorage();
    saveFolderData();
    renderMainScreen();
    toast(`"${group.name}" ì‚­ì œë¨ (${sheetCount}ê°œ ì‹œíŠ¸ â†’ íœ´ì§€í†µ)`);
    hasUnsavedChanges = true;
}

// íŒŒì¼ ê·¸ë£¹ ì „ì²´ ë‹¤ìš´ë¡œë“œ
async function downloadFileGroup(fileId) {
    const group = fileGroups[fileId];
    if (!group || !group.sheets) return;

    const wb = XLSX.utils.book_new();
    let sheetCount = 0;

    group.sheets.forEach(sheetName => {
        const sheet = WB[sheetName];
        if (!sheet || !sheet.data || sheet.data.length === 0) return;

        const wsData = [sheet.headers, ...sheet.data];
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        // ì‹œíŠ¸ ì´ë¦„ì—ì„œ ê¸ˆì§€ ë¬¸ì ì œê±°
        const safeName = sheetName.replace(/[:\\\/?*\[\]]/g, '_').substring(0, 31);
        XLSX.utils.book_append_sheet(wb, ws, safeName);
        sheetCount++;
    });

    if (sheetCount === 0) {
        toast('ë‹¤ìš´ë¡œë“œí•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
    }

    const fileName = group.name.replace(/\.[^/.]+$/, '') + '_export.xlsx';
    XLSX.writeFile(wb, fileName);
    toast(`${sheetCount}ê°œ ì‹œíŠ¸ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
}

// íŒŒì¼ ê·¸ë£¹ëª… ë³€ê²½
function renameFileGroup(fileId) {
    const group = fileGroups[fileId];
    if (!group) return;

    const newName = prompt('ìƒˆ íŒŒì¼ëª…ì„ ì…ë ¥í•˜ì„¸ìš”:', group.name);
    if (newName && newName.trim() && newName !== group.name) {
        group.name = newName.trim();
        saveFileGroupsToStorage();
        renderMainScreen();
        toast('íŒŒì¼ëª… ë³€ê²½ ì™„ë£Œ');
    }
}

// íŒŒì¼ ê·¸ë£¹ ì ‘ê¸°/í¼ì¹˜ê¸°
function toggleFileGroupCollapse(fileId) {
    if (collapsedFileGroups.has(fileId)) {
        collapsedFileGroups.delete(fileId);
    } else {
        collapsedFileGroups.add(fileId);
    }
    saveFileGroupsToStorage();
    renderMainScreen();
}

// ë·° ëª¨ë“œ ë³€ê²½ (ê·¸ë£¹/í”Œë«)
function toggleFileGroupViewMode() {
    fileGroupViewMode = fileGroupViewMode === 'grouped' ? 'flat' : 'grouped';
    saveFileGroupsToStorage();
    renderMainScreen();
}

// íŒŒì¼ ê·¸ë£¹ ì €ì¥
function saveFileGroupsToStorage() {
    try {
        localStorage.setItem('excelmaster_fileGroups', JSON.stringify(fileGroups));
        localStorage.setItem('excelmaster_sheetToFileGroup', JSON.stringify(sheetToFileGroup));
        localStorage.setItem('excelmaster_collapsedFileGroups', JSON.stringify([...collapsedFileGroups]));
        localStorage.setItem('excelmaster_fileGroupViewMode', fileGroupViewMode);
    } catch (e) {
        console.warn('íŒŒì¼ ê·¸ë£¹ ì €ì¥ ì‹¤íŒ¨:', e);
    }
}

// íŒŒì¼ ê·¸ë£¹ ë¶ˆëŸ¬ì˜¤ê¸°
function loadFileGroupsFromStorage() {
    try {
        const savedGroups = localStorage.getItem('excelmaster_fileGroups');
        const savedMapping = localStorage.getItem('excelmaster_sheetToFileGroup');
        const savedCollapsed = localStorage.getItem('excelmaster_collapsedFileGroups');
        const savedViewMode = localStorage.getItem('excelmaster_fileGroupViewMode');

        if (savedGroups) fileGroups = JSON.parse(savedGroups);
        if (savedMapping) sheetToFileGroup = JSON.parse(savedMapping);
        if (savedCollapsed) collapsedFileGroups = new Set(JSON.parse(savedCollapsed));
        if (savedViewMode) fileGroupViewMode = savedViewMode;
    } catch (e) {
        console.warn('íŒŒì¼ ê·¸ë£¹ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
        fileGroups = {};
        sheetToFileGroup = {};
        collapsedFileGroups = new Set();
    }
}

// ë¯¸ë“±ë¡ ì‹œíŠ¸ë“¤ì„ "ê¸°íƒ€" ê·¸ë£¹ìœ¼ë¡œ
function getUngroupedSheets() {
    return Object.keys(WB).filter(name => {
        if (!WB[name] || !WB[name].data || WB[name].data.length === 0) return false;
        return !sheetToFileGroup[name];
    });
}

// ìƒíƒœ ì €ì¥ (ì‹¤í–‰ ì·¨ì†Œìš©)
function saveState(action) {
    // ì‹œíŠ¸ ì¡´ì¬ í™•ì¸
    if (!WB[SHEET] || !WB[SHEET].data) return;

    try {
        const state = {
            action: action,
            sheet: SHEET,
            data: JSON.parse(JSON.stringify(WB[SHEET].data)),
            headers: JSON.parse(JSON.stringify(WB[SHEET].headers || [])),
            colWidths: COL_WIDTHS[SHEET] ? JSON.parse(JSON.stringify(COL_WIDTHS[SHEET])) : null,
            rowHeights: ROW_HEIGHTS[SHEET] ? JSON.parse(JSON.stringify(ROW_HEIGHTS[SHEET])) : null,
            colOrder: COL_ORDER[SHEET] ? [...COL_ORDER[SHEET]] : null
        };
        UNDO_STACK.push(state);
        if (UNDO_STACK.length > MAX_UNDO) {
            UNDO_STACK.shift();
        }
        REDO_STACK = []; // ìƒˆ ì‘ì—… ì‹œ ë‹¤ì‹œ ì‹¤í–‰ ìŠ¤íƒ ì´ˆê¸°í™”
    } catch (e) {
        console.error('ìƒíƒœ ì €ì¥ ì‹¤íŒ¨:', e);
    }
    
    // ë¡œì»¬ ì €ì¥ì†Œì— ìë™ ì €ì¥ (ë””ë°”ìš´ìŠ¤)
    debouncedSaveToLocalStorage();
}

// ë¡œì»¬ ì €ì¥ì†Œ ì €ì¥ ë””ë°”ìš´ìŠ¤
let localSaveTimeout = null;
function debouncedSaveToLocalStorage() {
    if (localSaveTimeout) clearTimeout(localSaveTimeout);
    localSaveTimeout = setTimeout(() => {
        saveToLocalStorage();
    }, 1000); // 1ì´ˆ í›„ ì €ì¥
}

// ë¡œì»¬ ì €ì¥ì†Œì— ë°ì´í„° ì €ì¥
function saveToLocalStorage() {
    try {
        
        // ì‹œíŠ¸ ë°ì´í„° ì €ì¥
        const dataStr = JSON.stringify(WB);
        localStorage.setItem('excelmaster_data', dataStr);
        
        // ì‹œíŠ¸ í´ë” ë°ì´í„° ì €ì¥
        localStorage.setItem('excelmaster_folders', JSON.stringify(sheetFolders));
        localStorage.setItem('excelmaster_sheetToFolder', JSON.stringify(sheetToFolder));
        
        // íŒŒì¼ í´ë” ë°ì´í„° ì €ì¥
        localStorage.setItem('excelmaster_fileFolders', JSON.stringify(fileFolders));
        localStorage.setItem('excelmaster_fileToFolder', JSON.stringify(fileToFolder));
        
        // ì»¬ëŸ¼ ìˆœì„œ ë° ìˆ¨ê¹€ ì»¬ëŸ¼ ì €ì¥
        localStorage.setItem('excelmaster_colOrder', JSON.stringify(COL_ORDER));
        // HIDDEN_COLSëŠ” Setì´ë¯€ë¡œ ë°°ì—´ë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥
        const hiddenColsObj = {};
        for (const [sheet, cols] of Object.entries(HIDDEN_COLS)) {
            hiddenColsObj[sheet] = Array.from(cols);
        }
        localStorage.setItem('excelmaster_hiddenCols', JSON.stringify(hiddenColsObj));
        
    } catch (e) {
        console.error('ë¡œì»¬ ì €ì¥ì†Œ ì €ì¥ ì˜¤ë¥˜:', e);
        // ìš©ëŸ‰ ì´ˆê³¼ ì‹œ ì´ì „ ë°ì´í„° ì‚­ì œ ì‹œë„
        if (e.name === 'QuotaExceededError') {
            console.warn('ë¡œì»¬ ì €ì¥ì†Œ ìš©ëŸ‰ ì´ˆê³¼ - ìºì‹œ ì •ë¦¬ ì‹œë„');
            try {
                localStorage.removeItem('excelmaster_data');
            } catch (e2) {
                console.error('ìºì‹œ ì •ë¦¬ ì‹¤íŒ¨:', e2);
            }
        }
    }
}

// ì‹¤í–‰ ì·¨ì†Œ
function undo() {
    if (UNDO_STACK.length === 0) {
        toast('ì·¨ì†Œí•  ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    const state = UNDO_STACK.pop();

    // ì‹œíŠ¸ ì¡´ì¬ í™•ì¸
    if (!WB[state.sheet] || !WB[state.sheet].data) {
        toast('í•´ë‹¹ ì‹œíŠ¸ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        return;
    }

    // í˜„ì¬ ìƒíƒœë¥¼ ë‹¤ì‹œ ì‹¤í–‰ ìŠ¤íƒì— ì €ì¥
    REDO_STACK.push({
        action: state.action,
        sheet: state.sheet,
        data: JSON.parse(JSON.stringify(WB[state.sheet].data)),
        headers: JSON.parse(JSON.stringify(WB[state.sheet].headers || [])),
        colWidths: COL_WIDTHS[state.sheet] ? JSON.parse(JSON.stringify(COL_WIDTHS[state.sheet])) : null,
        rowHeights: ROW_HEIGHTS[state.sheet] ? JSON.parse(JSON.stringify(ROW_HEIGHTS[state.sheet])) : null,
        colOrder: COL_ORDER[state.sheet] ? [...COL_ORDER[state.sheet]] : null
    });

    // ì´ì „ ìƒíƒœë¡œ ë³µì›
    WB[state.sheet].data = state.data;
    WB[state.sheet].headers = state.headers;
    
    // ì—´ ë„ˆë¹„ ë³µì›
    if (state.colWidths) {
        COL_WIDTHS[state.sheet] = state.colWidths;
    } else {
        delete COL_WIDTHS[state.sheet];
    }
    
    // í–‰ ë†’ì´ ë³µì›
    if (state.rowHeights) {
        ROW_HEIGHTS[state.sheet] = state.rowHeights;
    } else {
        delete ROW_HEIGHTS[state.sheet];
    }
    
    // ì—´ ìˆœì„œ ë³µì›
    if (state.colOrder) {
        COL_ORDER[state.sheet] = state.colOrder;
    }
    
    if (SHEET !== state.sheet) {
        SHEET = state.sheet;
        document.getElementById('currentSheetName').textContent = SHEET;
    }
    
    renderSpreadsheet();
    renderSheetTabs();
    toast(`ì‹¤í–‰ ì·¨ì†Œ: ${state.action}`);
}

// ë‹¤ì‹œ ì‹¤í–‰
function redo() {
    if (REDO_STACK.length === 0) {
        toast('ë‹¤ì‹œ ì‹¤í–‰í•  ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    const state = REDO_STACK.pop();
    
    // í˜„ì¬ ìƒíƒœë¥¼ ì‹¤í–‰ ì·¨ì†Œ ìŠ¤íƒì— ì €ì¥
    UNDO_STACK.push({
        action: state.action,
        sheet: state.sheet,
        data: JSON.parse(JSON.stringify(WB[state.sheet].data)),
        headers: JSON.parse(JSON.stringify(WB[state.sheet].headers)),
        colWidths: COL_WIDTHS[state.sheet] ? JSON.parse(JSON.stringify(COL_WIDTHS[state.sheet])) : null,
        rowHeights: ROW_HEIGHTS[state.sheet] ? JSON.parse(JSON.stringify(ROW_HEIGHTS[state.sheet])) : null,
        colOrder: COL_ORDER[state.sheet] ? [...COL_ORDER[state.sheet]] : null
    });
    
    // ë‹¤ì‹œ ì‹¤í–‰ ìƒíƒœë¡œ ë³µì›
    WB[state.sheet].data = state.data;
    WB[state.sheet].headers = state.headers;
    
    // ì—´ ë„ˆë¹„ ë³µì›
    if (state.colWidths) {
        COL_WIDTHS[state.sheet] = state.colWidths;
    } else {
        delete COL_WIDTHS[state.sheet];
    }
    
    // í–‰ ë†’ì´ ë³µì›
    if (state.rowHeights) {
        ROW_HEIGHTS[state.sheet] = state.rowHeights;
    } else {
        delete ROW_HEIGHTS[state.sheet];
    }
    
    // ì—´ ìˆœì„œ ë³µì›
    if (state.colOrder) {
        COL_ORDER[state.sheet] = state.colOrder;
    }
    
    if (SHEET !== state.sheet) {
        SHEET = state.sheet;
        document.getElementById('currentSheetName').textContent = SHEET;
    }
    
    renderSpreadsheet();
    renderSheetTabs();
    toast(`ë‹¤ì‹œ ì‹¤í–‰: ${state.action}`);
}

// ==================== ì—…ë¡œë“œ ë¦¬ë·° ê¸°ëŠ¥ ====================

// ëª¨ë‹¬ ë“œë˜ê·¸ ë³€ìˆ˜
let isDraggingModal = false;
let modalDragOffsetX = 0;
let modalDragOffsetY = 0;

function showUploadReviewModal(addedSheets) {
    const modal = document.getElementById('uploadReviewModal');
    const modalContent = modal.querySelector('.modal-content');
    
    // ëª¨ë‹¬ ìœ„ì¹˜ ì´ˆê¸°í™” (ì¤‘ì•™)
    modalContent.style.left = '50%';
    modalContent.style.top = '50%';
    modalContent.style.transform = 'translate(-50%, -50%)';
    
    // ìš”ì•½ ì—…ë°ì´íŠ¸
    document.getElementById('summarySheets').textContent = PENDING_NEW_SHEETS.length;
    document.getElementById('summaryAdditions').textContent = PENDING_ADDITIONS.length;
    document.getElementById('summaryChanges').textContent = PENDING_CHANGES.length;
    document.getElementById('summaryErrors').textContent = PENDING_ERRORS.length;
    
    // íƒ­ ë°°ì§€ ì—…ë°ì´íŠ¸
    document.getElementById('tabSheets').textContent = PENDING_NEW_SHEETS.length;
    document.getElementById('tabAdditions').textContent = PENDING_ADDITIONS.length;
    document.getElementById('tabChanges').textContent = PENDING_CHANGES.length;
    document.getElementById('tabErrors').textContent = PENDING_ERRORS.length;
    
    // ê¸°ë³¸ íƒ­ìœ¼ë¡œ ì „í™˜
    if (PENDING_ADDITIONS.length > 0) {
        currentReviewTab = 'additions';
    } else if (PENDING_CHANGES.length > 0) {
        currentReviewTab = 'changes';
    } else if (PENDING_NEW_SHEETS.length > 0) {
        currentReviewTab = 'sheets';
    } else {
        currentReviewTab = 'errors';
    }
    
    switchReviewTab(currentReviewTab);
    modal.classList.add('show');
    
    // ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì„¤ì •
    initModalDrag();
}

function initModalDrag() {
    const modal = document.getElementById('uploadReviewModal');
    const modalContent = modal.querySelector('.modal-content');
    const modalHeader = modal.querySelector('.modal-header');
    
    modalHeader.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('modal-close')) return;
        
        isDraggingModal = true;
        
        // transform ì œê±°í•˜ê³  ì‹¤ì œ ìœ„ì¹˜ë¡œ ë³€í™˜
        const rect = modalContent.getBoundingClientRect();
        modalContent.style.transform = 'none';
        modalContent.style.left = rect.left + 'px';
        modalContent.style.top = rect.top + 'px';
        
        modalDragOffsetX = e.clientX - rect.left;
        modalDragOffsetY = e.clientY - rect.top;
        
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDraggingModal) return;
        
        const modalContent = document.querySelector('#uploadReviewModal .modal-content');
        let newX = e.clientX - modalDragOffsetX;
        let newY = e.clientY - modalDragOffsetY;
        
        // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡ ì œí•œ
        newX = Math.max(0, Math.min(newX, window.innerWidth - modalContent.offsetWidth));
        newY = Math.max(0, Math.min(newY, window.innerHeight - 50));
        
        modalContent.style.left = newX + 'px';
        modalContent.style.top = newY + 'px';
    });
    
    document.addEventListener('mouseup', () => {
        isDraggingModal = false;
    });
}

function closeUploadReview() {
    document.getElementById('uploadReviewModal').classList.remove('show');
}

function switchReviewTab(tabName) {
    currentReviewTab = tabName;
    
    // íƒ­ ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ë³€ê²½
    document.querySelectorAll('.review-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === tabName);
    });
    
    // ë¦¬ìŠ¤íŠ¸ ë Œë”ë§
    renderReviewList();
    updateSelectedCount();
}

function renderReviewList() {
    const listContainer = document.getElementById('reviewList');
    let items = [];
    
    switch (currentReviewTab) {
        case 'additions':
            items = PENDING_ADDITIONS.map((item, idx) => ({
                ...item,
                type: 'addition',
                idx: idx,
                selected: item.selected !== false
            }));
            break;
        case 'changes':
            items = PENDING_CHANGES.map((item, idx) => ({
                ...item,
                type: 'change',
                idx: idx,
                selected: item.selected !== false
            }));
            break;
        case 'errors':
            items = PENDING_ERRORS.map((item, idx) => ({
                ...item,
                type: 'error',
                idx: idx,
                selected: false
            }));
            break;
        case 'sheets':
            items = PENDING_NEW_SHEETS.map((item, idx) => ({
                ...item,
                type: 'sheet',
                idx: idx,
                selected: item.selected !== false
            }));
            break;
    }
    
    if (items.length === 0) {
        listContainer.innerHTML = '<li style="padding:30px;text-align:center;color:var(--retro-warm-gray);">í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤</li>';
        return;
    }
    
    let html = '';
    const maxDisplay = Math.min(items.length, 200); // ìµœëŒ€ 200ê°œê¹Œì§€ í‘œì‹œ
    
    for (let i = 0; i < maxDisplay; i++) {
        const item = items[i];
        html += renderReviewItem(item);
    }
    
    if (items.length > maxDisplay) {
        html += `<li style="padding:15px;text-align:center;color:var(--retro-warm-gray);background:var(--retro-cream);">
            ì™¸ ${items.length - maxDisplay}ê±´ ë” ìˆìŒ
        </li>`;
    }
    
    listContainer.innerHTML = html;
    
    // ì „ì²´ ì„ íƒ ì²´í¬ë°•ìŠ¤ ìƒíƒœ ì—…ë°ì´íŠ¸
    const allSelected = items.length > 0 && items.every(item => item.selected);
    document.getElementById('selectAllReview').checked = allSelected;
}

function renderReviewItem(item) {
    const checked = item.selected ? 'checked' : '';
    const errorClass = item.type === 'error' ? ' error' : '';
    
    let preview = '';
    let diffHtml = '';
    
    switch (item.type) {
        case 'addition':
            preview = item.row.slice(0, 5).join(' | ');
            break;
        case 'change':
            preview = item.newRow.slice(0, 4).join(' | ');
            diffHtml = '<div class="review-item-diff">';
            for (const diff of item.diffs.slice(0, 3)) {
                diffHtml += `<div><span class="diff-field">${escHtml(diff.field)}:</span> 
                    <span class="diff-old">${escHtml(diff.oldVal || '(ë¹ˆê°’)')}</span> â†’ 
                    <span class="diff-new">${escHtml(diff.newVal || '(ë¹ˆê°’)')}</span></div>`;
            }
            if (item.diffs.length > 3) {
                diffHtml += `<div style="color:var(--retro-warm-gray);">ì™¸ ${item.diffs.length - 3}ê°œ ë³€ê²½...</div>`;
            }
            diffHtml += '</div>';
            break;
        case 'error':
            preview = item.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
            break;
        case 'sheet':
            preview = `í—¤ë”: ${item.headers.slice(0, 5).join(', ')}${item.headers.length > 5 ? '...' : ''}<br>ë°ì´í„°: ${item.data.length}ê±´`;
            // ë§¤ì¹­ ì„ íƒì´ í•„ìš”í•œ ê²½ìš°
            if (item.needSelection && item.matchingSheets && item.matchingSheets.length > 1) {
                preview += `<div style="margin-top:8px;padding:8px;background:var(--retro-mint);border-radius:4px;">
                    <div style="font-size:11px;color:var(--retro-coral);margin-bottom:5px;">âš ï¸ ê°™ì€ í—¤ë”ì˜ ì‹œíŠ¸ê°€ ì—¬ëŸ¬ ê°œ ìˆìŠµë‹ˆë‹¤. ëŒ€ìƒ ì‹œíŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”:</div>
                    <select onchange="selectTargetSheet(${item.idx}, this.value)" style="width:100%;padding:5px;border:2px solid var(--retro-border);border-radius:4px;">
                        <option value="">ìƒˆ ì‹œíŠ¸ë¡œ ì¶”ê°€</option>
                        ${item.matchingSheets.map(s => `<option value="${escHtml(s)}">${escHtml(s)}</option>`).join('')}
                    </select>
                </div>`;
            } else if (item.sourceSheet) {
                preview += `<div style="font-size:11px;color:var(--retro-warm-gray);margin-top:5px;">ì›ë³¸: ${escHtml(item.sourceSheet)}</div>`;
            }
            break;
    }
    
    return `
        <li class="review-item${errorClass}">
            <input type="checkbox" ${checked} onchange="toggleReviewItem('${item.type}', ${item.idx})" 
                   ${item.type === 'error' ? 'disabled' : ''}>
            <div class="review-item-content">
                <div class="review-item-header">
                    <span class="review-item-sheet">${escHtml(item.sheet || item.name)}</span>
                    ${item.rowIdx !== undefined ? `<span style="font-size:11px;color:var(--retro-warm-gray);">í–‰ ${item.rowIdx + 2}</span>` : ''}
                </div>
                <div class="review-item-preview">${preview}</div>
                ${diffHtml}
            </div>
        </li>
    `;
}

function toggleReviewItem(type, idx) {
    let items;
    switch (type) {
        case 'addition': items = PENDING_ADDITIONS; break;
        case 'change': items = PENDING_CHANGES; break;
        case 'sheet': items = PENDING_NEW_SHEETS; break;
        default: return;
    }
    
    if (items[idx]) {
        items[idx].selected = !items[idx].selected;
    }
    
    updateSelectedCount();
    
    // ì „ì²´ ì„ íƒ ì²´í¬ë°•ìŠ¤ ìƒíƒœ ì—…ë°ì´íŠ¸
    const allSelected = items.every(item => item.selected !== false);
    document.getElementById('selectAllReview').checked = allSelected;
}

// ëŒ€ìƒ ì‹œíŠ¸ ì„ íƒ (ì—¬ëŸ¬ ë§¤ì¹­ ì‹œ)
function selectTargetSheet(idx, targetSheet) {
    const item = PENDING_NEW_SHEETS[idx];
    if (!item) return;
    
    if (targetSheet) {
        // ê¸°ì¡´ ì‹œíŠ¸ì— ë³‘í•©
        item.targetSheet = targetSheet;
        item.mergeToExisting = true;
        toast(`"${item.name}" â†’ "${targetSheet}"ì— ë³‘í•© ì˜ˆì •`);
    } else {
        // ìƒˆ ì‹œíŠ¸ë¡œ ì¶”ê°€
        delete item.targetSheet;
        delete item.mergeToExisting;
        toast(`"${item.name}" ìƒˆ ì‹œíŠ¸ë¡œ ì¶”ê°€ ì˜ˆì •`);
    }
}

function toggleSelectAllReview() {
    const checked = document.getElementById('selectAllReview').checked;
    let items;
    
    switch (currentReviewTab) {
        case 'additions': items = PENDING_ADDITIONS; break;
        case 'changes': items = PENDING_CHANGES; break;
        case 'sheets': items = PENDING_NEW_SHEETS; break;
        default: return;
    }
    
    items.forEach(item => item.selected = checked);
    renderReviewList();
    updateSelectedCount();
}

function updateSelectedCount() {
    let total = 0;
    let selected = 0;
    
    switch (currentReviewTab) {
        case 'additions':
            total = PENDING_ADDITIONS.length;
            selected = PENDING_ADDITIONS.filter(i => i.selected !== false).length;
            break;
        case 'changes':
            total = PENDING_CHANGES.length;
            selected = PENDING_CHANGES.filter(i => i.selected !== false).length;
            break;
        case 'sheets':
            total = PENDING_NEW_SHEETS.length;
            selected = PENDING_NEW_SHEETS.filter(i => i.selected !== false).length;
            break;
        case 'errors':
            total = PENDING_ERRORS.length;
            selected = 0;
            break;
    }
    
    const countEl = document.getElementById('selectedCount');
    if (countEl) countEl.textContent = `${selected}/${total}ê°œ ì„ íƒë¨`;
}

function applySelectedReview() {
    let appliedCount = 0;
    let mergedCount = 0;
    
    // ì„ íƒëœ ìƒˆ ì‹œíŠ¸ ì ìš©
    PENDING_NEW_SHEETS.filter(item => item.selected !== false).forEach(item => {
        if (item.mergeToExisting && item.targetSheet && WB[item.targetSheet]) {
            // ê¸°ì¡´ ì‹œíŠ¸ì— ë³‘í•©
            const targetSheet = WB[item.targetSheet];
            const existingSet = new Set(targetSheet.data.map(r => JSON.stringify(r)));
            
            let addedRows = 0;
            for (const row of item.data) {
                if (!existingSet.has(JSON.stringify(row))) {
                    targetSheet.data.push(row);
                    addedRows++;
                }
            }
            mergedCount++;
            appliedCount += addedRows;
        } else {
            // ìƒˆ ì‹œíŠ¸ë¡œ ì¶”ê°€
            WB[item.name] = { headers: item.headers, data: item.data };
            COL_ORDER[item.name] = item.headers.map((_, i) => i);
            HIDDEN_COLS[item.name] = new Set();
            appliedCount++;
        }
    });
    
    // ì„ íƒëœ ì¶”ê°€ ê±´ ì ìš©
    PENDING_ADDITIONS.filter(item => item.selected !== false).forEach(item => {
        if (WB[item.sheet]) {
            WB[item.sheet].data.push(item.row);
            appliedCount++;
        }
    });
    
    // ì„ íƒëœ ë³€ê²½ ê±´ ì ìš©
    PENDING_CHANGES.filter(item => item.selected !== false).forEach(item => {
        if (WB[item.sheet] && WB[item.sheet].data[item.rowIdx]) {
            WB[item.sheet].data[item.rowIdx] = item.newRow;
            appliedCount++;
        }
    });
    
    // PENDING ë°°ì—´ ì´ˆê¸°í™”
    clearPendingData();
    
    closeUploadReview();
    renderMainScreen();
    renderSheetTabs();
    renderSpreadsheet();
    
    let msg = `${appliedCount}ê±´ ì ìš© ì™„ë£Œ`;
    if (mergedCount > 0) {
        msg += ` (${mergedCount}ê°œ ì‹œíŠ¸ ë³‘í•©)`;
    }
    toast(msg);
}

function applyAllReview() {
    let appliedCount = 0;
    let mergedCount = 0;
    
    // ëª¨ë“  ìƒˆ ì‹œíŠ¸ ì ìš©
    PENDING_NEW_SHEETS.forEach(item => {
        if (item.mergeToExisting && item.targetSheet && WB[item.targetSheet]) {
            // ê¸°ì¡´ ì‹œíŠ¸ì— ë³‘í•©
            const targetSheet = WB[item.targetSheet];
            const existingSet = new Set(targetSheet.data.map(r => JSON.stringify(r)));
            
            let addedRows = 0;
            for (const row of item.data) {
                if (!existingSet.has(JSON.stringify(row))) {
                    targetSheet.data.push(row);
                    addedRows++;
                }
            }
            mergedCount++;
            appliedCount += addedRows;
        } else {
            // ìƒˆ ì‹œíŠ¸ë¡œ ì¶”ê°€
            WB[item.name] = { headers: item.headers, data: item.data };
            COL_ORDER[item.name] = item.headers.map((_, i) => i);
            HIDDEN_COLS[item.name] = new Set();
            appliedCount++;
        }
    });
    
    // ëª¨ë“  ì¶”ê°€ ê±´ ì ìš©
    PENDING_ADDITIONS.forEach(item => {
        if (WB[item.sheet]) {
            WB[item.sheet].data.push(item.row);
            appliedCount++;
        }
    });
    
    // ëª¨ë“  ë³€ê²½ ê±´ ì ìš©
    PENDING_CHANGES.forEach(item => {
        if (WB[item.sheet] && WB[item.sheet].data[item.rowIdx]) {
            WB[item.sheet].data[item.rowIdx] = item.newRow;
            appliedCount++;
        }
    });
    
    // PENDING ë°°ì—´ ì´ˆê¸°í™”
    clearPendingData();
    
    closeUploadReview();
    renderMainScreen();
    renderSheetTabs();
    renderSpreadsheet();
    
    let msg = `ì „ì²´ ${appliedCount}ê±´ ì ìš© ì™„ë£Œ`;
    if (mergedCount > 0) {
        msg += ` (${mergedCount}ê°œ ì‹œíŠ¸ ë³‘í•©)`;
    }
    toast(msg);
}

function discardAllReview() {
    if (!confirm('ëª¨ë“  ë³€ê²½ ì‚¬í•­ì„ ë¬´ì‹œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
    
    clearPendingData();
    closeUploadReview();
    toast('ëª¨ë“  ë³€ê²½ ì‚¬í•­ì´ ë¬´ì‹œë˜ì—ˆìŠµë‹ˆë‹¤');
}

function clearPendingData() {
    PENDING_ADDITIONS = [];
    PENDING_CHANGES = [];
    PENDING_NEW_SHEETS = [];
    PENDING_ERRORS = [];
}

// ==================== ë¡œê·¸ì¸/ë¡œê·¸ì•„ì›ƒ ====================

// Google ë¡œê·¸ì¸
function googleLogin() {
    // ë¡œì»¬ íŒŒì¼ì¸ ê²½ìš° ë¡œê·¸ì¸ ë¶ˆê°€
    if (window.location.protocol === 'file:') {
        toast('ë¡œì»¬ íŒŒì¼ì—ì„œëŠ” Google ë¡œê·¸ì¸ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.\nì›¹ì„œë²„ì—ì„œ ì‹¤í–‰í•˜ê±°ë‚˜ ì˜¤í”„ë¼ì¸ ëª¨ë“œë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
        setTimeout(() => {
            if (confirm('ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì§„ì…í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(íŒŒì¼ ì—´ê¸°/ì €ì¥ì€ ê°€ëŠ¥, ì„œë²„ ì—°ë™ ë¶ˆê°€)')) {
                enterOfflineMode();
            }
        }, 500);
        return;
    }
    
    if (!auth) {
        toast('Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.');
        return;
    }
    
    const provider = new firebase.auth.GoogleAuthProvider();
    auth.signInWithPopup(provider)
        .then((result) => {
            // ë¡œê·¸ì¸ ì„±ê³µ
            console.log('ë¡œê·¸ì¸ ì„±ê³µ:', result.user.email);
        })
        .catch((error) => {
            console.error('ë¡œê·¸ì¸ ì˜¤ë¥˜:', error);
            // ë¡œì»¬ í™˜ê²½ ì˜¤ë¥˜ì¸ ê²½ìš° ì˜¤í”„ë¼ì¸ ëª¨ë“œ ì œì•ˆ
            if (error.code === 'auth/operation-not-supported-in-this-environment') {
                toast('í˜„ì¬ í™˜ê²½ì—ì„œ Google ë¡œê·¸ì¸ì´ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                setTimeout(() => {
                    if (confirm('ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì§„ì…í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(íŒŒì¼ ì—´ê¸°/ì €ì¥ì€ ê°€ëŠ¥, ì„œë²„ ì—°ë™ ë¶ˆê°€)')) {
                        enterOfflineMode();
                    }
                }, 500);
            } else {
                toast('ë¡œê·¸ì¸ ì‹¤íŒ¨: ' + error.message);
            }
        });
}

// ë¡œê·¸ì•„ì›ƒ
function logout() {
    if (!confirm('ë¡œê·¸ì•„ì›ƒ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
    
    if (!auth) {
        // ì˜¤í”„ë¼ì¸ ëª¨ë“œì—ì„œëŠ” ê·¸ëƒ¥ ë¡œê·¸ì¸ í™”ë©´ìœ¼ë¡œ ì´ë™
        document.getElementById('mainScreen').style.display = 'none';
        document.getElementById('detailScreen').style.display = 'none';
        document.getElementById('loginScreen').style.display = 'flex';
        updateLoginScreen();
        return;
    }
    
    auth.signOut()
        .then(() => {
            console.log('ë¡œê·¸ì•„ì›ƒ ì„±ê³µ');
            isAppEntered = false; // ì§„ì… í”Œë˜ê·¸ ì´ˆê¸°í™”
        })
        .catch((error) => {
            console.error('ë¡œê·¸ì•„ì›ƒ ì˜¤ë¥˜:', error);
            toast('ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨');
        });
}

// í—ˆìš©ëœ ì´ë©”ì¼ ëª©ë¡
const ALLOWED_EMAILS = [
    'kgnsl111@gmail.com'
];

// ë¡œê·¸ì¸ ëŒ€ê¸° ìƒíƒœ
let pendingUser = null;
let isAppEntered = false; // ì¤‘ë³µ ì§„ì… ë°©ì§€

// ë¡œê·¸ì¸ ë²„íŠ¼ í´ë¦­ ì‹œ ì§„ì…
function enterApp() {
    // ì¤‘ë³µ ì§„ì… ë° ë¡œë”© ì¤‘ ë°©ì§€
    if (isAppEntered || document.getElementById('loading')?.classList.contains('show')) {
        return;
    }

    if (!pendingUser) {
        toast('ë¨¼ì € Google ë¡œê·¸ì¸ì„ í•´ì£¼ì„¸ìš”');
        return;
    }
    
    // í—ˆìš©ëœ ì´ë©”ì¼ì¸ì§€ í™•ì¸
    if (!ALLOWED_EMAILS.includes(pendingUser.email)) {
        toast('ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤');
        if (auth) auth.signOut();
        pendingUser = null;
        updateLoginScreen();
        return;
    }
    
    isAppEntered = true; // ì§„ì… í”Œë˜ê·¸ ì„¤ì •
    
    // ë¡œê·¸ì¸ ì™„ë£Œ
    currentUser = pendingUser;
    document.getElementById('loginScreen').style.display = 'none';
    document.getElementById('mainScreen').style.display = 'flex';
    
    // ì‚¬ìš©ì ì •ë³´ í‘œì‹œ
    document.getElementById('userAvatar').src = currentUser.photoURL || 'https://via.placeholder.com/28';
    document.getElementById('userName').textContent = currentUser.displayName || currentUser.email;
    
    toast(`${currentUser.displayName || currentUser.email}ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤!`);
    
    // í™”ë©´ ì´ˆê¸°í™”
    initDefaultSheets();
    initDates();
    setupEventListeners();
    
    // íŒŒì¼ ë³´ê´€í•¨ ë¡œë“œ
    loadFilesFromFirestore();
    
    // ì‹œíŠ¸ íƒ­ì´ ê¸°ë³¸ìœ¼ë¡œ ë³´ì´ë„ë¡ ì„¤ì •
    currentMainTab = 'sheets';
    const sheetsContainer = document.getElementById('sheetsContainer');
    const filesContainer = document.getElementById('fileStorageContainer');
    if (sheetsContainer) sheetsContainer.style.display = '';
    if (filesContainer) filesContainer.style.display = 'none';
    
    // ë¡œì»¬ ì €ì¥ì†Œì—ì„œ ë°ì´í„° ë³µì› ì‹œë„
    const hasLocalData = loadFromLocalStorage();

    // íœ´ì§€í†µ, ìë™ì €ì¥, íŒŒì¼ ê·¸ë£¹ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
    loadTrashFromStorage();
    loadAutoSaveSettings();
    loadFileGroupsFromStorage();
    startAutoSave();

    // ë°”ë¡œ í™”ë©´ ë Œë”ë§ (ì„œë²„ ìë™ í™•ì¸ ì•ˆ í•¨)
    renderMainScreen();

    if (hasLocalData) {
        toast('ì´ì „ ë°ì´í„° ë³µì›ë¨');
    }
}

// ì„œë²„ì— ë°ì´í„°ê°€ ìˆìœ¼ë©´ ìë™ ë¶ˆëŸ¬ì˜¤ê¸°
async function checkAndLoadFromServer() {
    if (!db || !currentUser) {
        renderMainScreen();
        return;
    }
    
    try {
        // ì„œë²„ì— ì‹œíŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸
        const sheetsSnapshot = await db.collection('sheets').limit(1).get();
        
        if (!sheetsSnapshot.empty) {
            // ì„œë²„ì— ë°ì´í„°ê°€ ìˆìœ¼ë©´ ë¶ˆëŸ¬ì˜¬ì§€ í™•ì¸
            const loadFromServer = confirm('ì„œë²„ì— ì €ì¥ëœ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤.\n\në¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?');
            
            if (loadFromServer) {
                await loadSheetsFromFirestore();
            } else {
                renderMainScreen();
            }
        } else {
            renderMainScreen();
        }
    } catch (error) {
        console.error('ì„œë²„ í™•ì¸ ì˜¤ë¥˜:', error);
        renderMainScreen();
    }
}

// ë¡œì»¬ ì €ì¥ì†Œì—ì„œ ë°ì´í„° ë³µì›
function loadFromLocalStorage() {
    try {
        const savedData = localStorage.getItem('excelmaster_data');
        const savedFolders = localStorage.getItem('excelmaster_folders');
        const savedMapping = localStorage.getItem('excelmaster_sheetToFolder');
        const savedFileFolders = localStorage.getItem('excelmaster_fileFolders');
        const savedFileMapping = localStorage.getItem('excelmaster_fileToFolder');
        const savedColOrder = localStorage.getItem('excelmaster_colOrder');
        const savedHiddenCols = localStorage.getItem('excelmaster_hiddenCols');
        
        // ì‹œíŠ¸ ë°ì´í„° ë³µì›
        if (savedData) {
            const parsed = JSON.parse(savedData);
            
            if (parsed && typeof parsed === 'object' && Object.keys(parsed).length > 0) {
                // ìœ íš¨í•œ ì‹œíŠ¸ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
                const hasValidData = Object.values(parsed).some(sheet => 
                    sheet && sheet.data && sheet.data.length > 0
                );
                
                if (hasValidData) {
                    WB = parsed;
                    
                    // ì €ì¥ëœ ì»¬ëŸ¼ ìˆœì„œ ë³µì›
                    if (savedColOrder) {
                        try {
                            COL_ORDER = JSON.parse(savedColOrder);
                        } catch (e) {
                            console.error('COL_ORDER ë³µì› ì‹¤íŒ¨:', e);
                        }
                    }
                    
                    // ì €ì¥ëœ ìˆ¨ê¹€ ì»¬ëŸ¼ ë³µì› (ë°°ì—´ì„ Setìœ¼ë¡œ ë³€í™˜)
                    if (savedHiddenCols) {
                        try {
                            const hiddenColsObj = JSON.parse(savedHiddenCols);
                            for (const [sheet, cols] of Object.entries(hiddenColsObj)) {
                                HIDDEN_COLS[sheet] = new Set(cols);
                            }
                        } catch (e) {
                            console.error('HIDDEN_COLS ë³µì› ì‹¤íŒ¨:', e);
                        }
                    }
                    
                    // ì—´ ìˆœì„œì™€ ìˆ¨ê¸´ ì—´ ì´ˆê¸°í™” (ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ëŠ” ì‹œíŠ¸ë§Œ)
                    for (const name in WB) {
                        if (!COL_ORDER[name]) {
                            COL_ORDER[name] = WB[name].headers.map((_, i) => i);
                        }
                        if (!HIDDEN_COLS[name]) {
                            HIDDEN_COLS[name] = new Set();
                        }
                    }
                    
                    // ì‹œíŠ¸ í´ë” ë°ì´í„° ë³µì›
                    if (savedFolders) {
                        sheetFolders = JSON.parse(savedFolders);
                    }
                    if (savedMapping) {
                        sheetToFolder = JSON.parse(savedMapping);
                    }
                    
                    // íŒŒì¼ í´ë” ë°ì´í„° ë³µì›
                    if (savedFileFolders) {
                        fileFolders = JSON.parse(savedFileFolders);
                    }
                    if (savedFileMapping) {
                        fileToFolder = JSON.parse(savedFileMapping);
                    }
                    
                    // ë£¨íŠ¸ í´ë”ë¡œ ì´ˆê¸°í™”
                    currentFolderId = null;
                    currentFileFolderId = null;
                    
                    // ì²« ë²ˆì§¸ ì‹œíŠ¸ ì„ íƒ
                    const sheetNames = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
                    if (sheetNames.length > 0) {
                        SHEET = sheetNames[0];
                    }
                    
                    // WB ë¡œë“œ ì™„ë£Œ í›„ ê³ ì•„ ë§¤í•‘ ì •ë¦¬
                    cleanupOrphanedMappings();
                    
                    // ì¦ê²¨ì°¾ê¸° íŒŒì¼ ë¡œë“œ
                    loadFavoriteFilesFromStorage();
                    
                    return true;
                }
            }
        }
    } catch (e) {
        console.error('ë¡œì»¬ ì €ì¥ì†Œ ë¡œë“œ ì˜¤ë¥˜:', e);
    }
    
    return false;
}

// ë¡œê·¸ì¸ í™”ë©´ ì—…ë°ì´íŠ¸
function updateLoginScreen() {
    const loginBox = document.querySelector('.login-box');
    if (pendingUser) {
        loginBox.innerHTML = `
            <div class="login-logo">E</div>
            <div class="login-title">ì—‘ì…€ë§ˆìŠ¤í„°</div>
            <div class="login-subtitle">ì‹¤ì‹œê°„ í˜‘ì—… ìŠ¤í”„ë ˆë“œì‹œíŠ¸</div>
            <div class="login-user-info">
                <img src="${pendingUser.photoURL || 'https://via.placeholder.com/56'}" class="login-user-avatar">
                <div class="login-user-name">${pendingUser.displayName || ''}</div>
                <div class="login-user-email">${pendingUser.email}</div>
            </div>
            <button class="login-enter-btn" onclick="enterApp()">
                ì…ì¥í•˜ê¸°
            </button>
            <div class="login-divider">ë˜ëŠ”</div>
            <button class="google-login-btn" onclick="switchAccount()">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
                ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸
            </button>
        `;
    } else {
        loginBox.innerHTML = `
            <div class="login-logo">E</div>
            <div class="login-title">ì—‘ì…€ë§ˆìŠ¤í„°</div>
            <div class="login-subtitle">ì‹¤ì‹œê°„ í˜‘ì—… ìŠ¤í”„ë ˆë“œì‹œíŠ¸</div>
            <button class="google-login-btn" onclick="googleLogin()">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google">
                Google ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸
            </button>
        `;
    }
}

// ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ ì „í™˜
function switchAccount() {
    if (!auth) {
        toast('Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        return;
    }
    
    auth.signOut().then(() => {
        pendingUser = null;
        updateLoginScreen();
        googleLogin();
    });
}

// ë¡œê·¸ì¸ ìƒíƒœ ê°ì§€ëŠ” DOMContentLoaded í›„ì— ì‹¤í–‰
document.addEventListener('DOMContentLoaded', () => {
    // file:// í”„ë¡œí† ì½œì¸ ê²½ìš° Firebase ì¸ì¦ ë¶ˆê°€ - ë°”ë¡œ ì˜¤í”„ë¼ì¸ ëª¨ë“œ
    if (window.location.protocol === 'file:') {
        console.warn('ë¡œì»¬ íŒŒì¼ë¡œ ì‹¤í–‰ ì¤‘ - ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì§„ì…í•©ë‹ˆë‹¤.');
        setTimeout(() => {
            enterOfflineMode();
        }, 300);
        return;
    }
    
    // Firebaseê°€ ì´ˆê¸°í™”ë˜ì—ˆëŠ”ì§€ í™•ì¸
    if (!auth) {
        console.warn('Firebase Authê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì§„ì…í•©ë‹ˆë‹¤.');
        // ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ë°”ë¡œ ì§„ì… (ë¡œê·¸ì¸ ì—†ì´ ì‚¬ìš©)
        setTimeout(() => {
            enterOfflineMode();
        }, 500);
        return;
    }
    
    auth.onAuthStateChanged((user) => {
        if (user) {
            // ë¡œê·¸ì¸ë¨ - ëŒ€ê¸° ìƒíƒœë¡œ ì €ì¥ (ìˆ˜ë™ ì…ì¥ í•„ìš”)
            pendingUser = user;
            updateLoginScreen();
        } else {
            // ë¡œê·¸ì•„ì›ƒë¨
            pendingUser = null;
            currentUser = null;
            isAppEntered = false; // ì§„ì… í”Œë˜ê·¸ ì´ˆê¸°í™”
            document.getElementById('loginScreen').style.display = 'flex';
            document.getElementById('mainScreen').style.display = 'none';
            document.getElementById('detailScreen').style.display = 'none';
            updateLoginScreen();
        }
    });
});

// ì˜¤í”„ë¼ì¸ ëª¨ë“œ ì§„ì… (Firebase ì—†ì´ ì‚¬ìš©)
function enterOfflineMode() {
    console.log('ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì‹¤í–‰');
    document.getElementById('loginScreen').style.display = 'none';
    document.getElementById('mainScreen').style.display = 'flex';

    // ì‚¬ìš©ì ì •ë³´ í‘œì‹œ (ì˜¤í”„ë¼ì¸)
    document.getElementById('userAvatar').src = 'https://via.placeholder.com/28';
    document.getElementById('userName').textContent = 'ì˜¤í”„ë¼ì¸ ëª¨ë“œ';

    // í™”ë©´ ì´ˆê¸°í™”
    initDefaultSheets();
    initDates();
    setupEventListeners();

    // ì‹œíŠ¸ íƒ­ì´ ê¸°ë³¸ìœ¼ë¡œ ë³´ì´ë„ë¡ ì„¤ì •
    currentMainTab = 'sheets';
    const sheetsContainer = document.getElementById('sheetsContainer');
    const filesContainer = document.getElementById('fileStorageContainer');
    if (sheetsContainer) sheetsContainer.style.display = '';
    if (filesContainer) filesContainer.style.display = 'none';

    // ë¡œì»¬ ì €ì¥ì†Œì—ì„œ ë°ì´í„° ë³µì› ì‹œë„
    const hasLocalData = loadFromLocalStorage();
    console.log('ì˜¤í”„ë¼ì¸ ëª¨ë“œ - ë¡œì»¬ ë°ì´í„° ìˆìŒ:', hasLocalData, 'WB ì‹œíŠ¸ ìˆ˜:', Object.keys(WB).length);

    // íœ´ì§€í†µ, ìë™ì €ì¥, íŒŒì¼ ê·¸ë£¹ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
    loadTrashFromStorage();
    loadAutoSaveSettings();
    loadFileGroupsFromStorage();

    renderMainScreen();

    if (hasLocalData) {
        toast('ì˜¤í”„ë¼ì¸ ëª¨ë“œ - ì´ì „ ë°ì´í„° ë³µì›ë¨');
    } else {
        toast('ì˜¤í”„ë¼ì¸ ëª¨ë“œ - ë¡œì»¬ íŒŒì¼ ì‘ì—…ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤');
    }
}

// ==================== Firebase ì‹¤ì‹œê°„ ì—°ë™ (ìµœì í™”) ====================

// ë°ì´í„° ì••ì¶• (100í–‰ì”© ë¬¶ì–´ì„œ ì €ì¥)
const CHUNK_ROWS = 100;

// Firestoreì— ì‹œíŠ¸ ë°ì´í„° ì €ì¥ (ìµœì í™”)
async function saveSheetToFirestore(sheetName) {
    try {
        const sheet = WB[sheetName];
        if (!sheet) return;
        
        if (!currentUser) {
            toast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
            return;
        }
        
        if (!db) {
            toast('Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (ì˜¤í”„ë¼ì¸ ëª¨ë“œ)');
            return;
        }
        
        showLoading('ì„œë²„ì— ì €ì¥ ì¤‘...');
        const startTime = Date.now();
        
        // ë°ì´í„°ë¥¼ ì²­í¬ë¡œ ë‚˜ëˆ„ê¸° (100í–‰ì”©)
        const chunks = [];
        for (let i = 0; i < sheet.data.length; i += CHUNK_ROWS) {
            chunks.push(sheet.data.slice(i, i + CHUNK_ROWS));
        }
        
        // ì‹œíŠ¸ ì •ë³´ + ëª¨ë“  ë°ì´í„°ë¥¼ í•œ ë¬¸ì„œì— ì €ì¥
        const sheetDoc = {
            name: sheetName,
            headers: sheet.headers,
            totalRows: sheet.data.length,
            totalChunks: chunks.length,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedBy: currentUser.email
        };
        
        await db.collection('sheets').doc(sheetName).set(sheetDoc);
        
        // ê¸°ì¡´ ì²­í¬ ì‚­ì œ
        const chunksRef = db.collection('sheets').doc(sheetName).collection('chunks');
        const existingChunks = await chunksRef.get();
        
        if (!existingChunks.empty) {
            const batch = db.batch();
            existingChunks.docs.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
        }
        
        // ìƒˆ ì²­í¬ ì €ì¥ (ë³‘ë ¬ ì²˜ë¦¬) - JSON ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ ì¤‘ì²© ë°°ì—´ ë¬¸ì œ í•´ê²°
        const savePromises = chunks.map((chunk, idx) => {
            updateLoadingText(`ì €ì¥ ì¤‘... ${idx + 1}/${chunks.length} ì²­í¬`);
            return chunksRef.doc(String(idx).padStart(5, '0')).set({
                chunkIndex: idx,
                rowsJson: JSON.stringify(chunk)
            });
        });
        
        await Promise.all(savePromises);
        
        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
        hideLoading();
        toast(`'${sheetName}' ì €ì¥ ì™„ë£Œ (${sheet.data.length}í–‰, ${elapsed}ì´ˆ)`);
        
    } catch (error) {
        hideLoading();
        console.error('ì €ì¥ ì˜¤ë¥˜:', error);
        toast('ì„œë²„ ì €ì¥ ì‹¤íŒ¨: ' + error.message);
    }
}

// Firestoreì—ì„œ ì‹œíŠ¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (ìµœì í™”)
async function loadSheetsFromFirestore() {
    try {
        if (!currentUser) {
            toast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
            return;
        }
        
        if (!db) {
            toast('Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (ì˜¤í”„ë¼ì¸ ëª¨ë“œ)');
            return;
        }
        
        if (!confirm('ì„œë²„ì—ì„œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?\n(í˜„ì¬ ì‘ì—… ì¤‘ì¸ ë°ì´í„°ëŠ” ìœ ì§€ë©ë‹ˆë‹¤)')) return;
        
        showLoading('ì„œë²„ì—ì„œ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');
        const startTime = Date.now();
        
        let totalRows = 0;
        let sheetCount = 0;
        let fileCount = 0;
        let loadedFolderCount = 0;
        
        // ===== ëª¨ë“  ë°ì´í„° ë³‘ë ¬ë¡œ ë¶ˆëŸ¬ì˜¤ê¸° =====
        updateLoadingText('ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');
        
        const [foldersSnapshot, sheetsSnapshot, filesSnapshot, fileFoldersSnapshot] = await Promise.all([
            db.collection('folders').where('userId', '==', currentUser.uid).get().catch(() => ({ empty: true, docs: [] })),
            db.collection('sheets').get(),
            db.collection('userFiles').where('userId', '==', currentUser.uid).orderBy('uploadedAt', 'desc').get().catch(() => ({ empty: true, docs: [] })),
            db.collection('fileFolders').where('userId', '==', currentUser.uid).get().catch(() => ({ empty: true, docs: [] }))
        ]);
        
        // ===== í´ë” ì²˜ë¦¬ =====
        if (!foldersSnapshot.empty) {
            for (const folderDoc of foldersSnapshot.docs) {
                const folderData = folderDoc.data();
                const folderId = folderDoc.id;
                
                if (!sheetFolders[folderId]) {
                    sheetFolders[folderId] = {
                        name: folderData.name,
                        parentId: folderData.parentId || null,
                        createdAt: folderData.createdAt || new Date().toISOString()
                    };
                    loadedFolderCount++;
                }
            }
            saveFolderData();
        }
        
        // ===== ì‹œíŠ¸ ë³‘ë ¬ ë¡œë“œ =====
        if (!sheetsSnapshot.empty) {
            updateLoadingText(`${sheetsSnapshot.size}ê°œ ì‹œíŠ¸ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...`);
            
            const loadPromises = sheetsSnapshot.docs.map(async (sheetDoc) => {
                const sheetData = sheetDoc.data();
                const sheetName = sheetDoc.id;
                
                try {
                    // ë¨¼ì € chunkIndexë¡œ ì •ë ¬ ì‹œë„
                    let chunksSnapshot;
                    try {
                        chunksSnapshot = await db.collection('sheets')
                            .doc(sheetName)
                            .collection('chunks')
                            .orderBy('chunkIndex')
                            .get();
                    } catch (orderErr) {
                        // chunkIndex ì¸ë±ìŠ¤ê°€ ì—†ìœ¼ë©´ indexë¡œ ì¬ì‹œë„ (êµ¬ë²„ì „ í˜¸í™˜)
                        console.log(`ì‹œíŠ¸ '${sheetName}': chunkIndex ì¸ë±ìŠ¤ ì—†ìŒ, indexë¡œ ì¬ì‹œë„`);
                        chunksSnapshot = await db.collection('sheets')
                            .doc(sheetName)
                            .collection('chunks')
                            .orderBy('index')
                            .get();
                    }
                    
                    const allRows = [];
                    // ë¬¸ì„œ ID ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ìˆœì„œ ë³´ì¥ (í´ë°±)
                    const sortedDocs = chunksSnapshot.docs.sort((a, b) => {
                        const aData = a.data();
                        const bData = b.data();
                        const aIdx = aData.chunkIndex !== undefined ? aData.chunkIndex : (aData.index !== undefined ? aData.index : 0);
                        const bIdx = bData.chunkIndex !== undefined ? bData.chunkIndex : (bData.index !== undefined ? bData.index : 0);
                        return aIdx - bIdx;
                    });
                    
                    sortedDocs.forEach(doc => {
                        const chunk = doc.data();
                        try {
                            if (chunk.rowsJson) {
                                allRows.push(...JSON.parse(chunk.rowsJson));
                            } else if (chunk.rows) {
                                allRows.push(...chunk.rows);
                            }
                        } catch (parseErr) {
                            console.error('ì²­í¬ íŒŒì‹± ì˜¤ë¥˜:', parseErr, 'chunk:', chunk);
                        }
                    });
                    
                    // êµ¬ë²„ì „ í˜¸í™˜
                    if (allRows.length === 0) {
                        const rowsSnapshot = await db.collection('sheets')
                            .doc(sheetName)
                            .collection('rows')
                            .orderBy('rowIndex')
                            .get();
                        rowsSnapshot.docs.forEach(doc => {
                            allRows.push(doc.data().data);
                        });
                    }
                    
                    return { sheetName, sheetData, allRows, success: true };
                } catch (err) {
                    console.error(`ì‹œíŠ¸ '${sheetName}' ë¡œë“œ ì˜¤ë¥˜:`, err);
                    return { sheetName, success: false };
                }
            });
            
            const results = await Promise.all(loadPromises);
            
            for (const result of results) {
                if (!result.success) continue;
                
                const { sheetName, sheetData, allRows } = result;
                
                WB[sheetName] = {
                    headers: sheetData.headers,
                    data: allRows
                };
                COL_ORDER[sheetName] = sheetData.headers.map((_, i) => i);
                HIDDEN_COLS[sheetName] = new Set();
                autoFitColumnWidths(sheetName);
                
                // í´ë” ë§¤í•‘ ë³µì› (í´ë”ê°€ ì¡´ì¬í•˜ë©´ ë§¤í•‘, ì—†ìœ¼ë©´ ë¬´ì‹œ)
                if (sheetData.folderId) {
                    if (sheetFolders[sheetData.folderId]) {
                        sheetToFolder[sheetName] = sheetData.folderId;
                    } else {
                        console.log('í´ë” ì—†ìŒ, ë§¤í•‘ ê±´ë„ˆëœ€:', sheetName, '->', sheetData.folderId);
                    }
                }
                
                totalRows += allRows.length;
                sheetCount++;
            }
            
            saveFolderData();
        }
        
        // ===== íŒŒì¼ ë³´ê´€í•¨ ì²˜ë¦¬ =====
        updateLoadingText('íŒŒì¼ ë³´ê´€í•¨ ì²˜ë¦¬ ì¤‘...');
        try {
            if (!filesSnapshot.empty) {
                const loadedServerFiles = [];
                let skippedCount = 0;
                
                for (const fileDoc of filesSnapshot.docs) {
                    try {
                        const fileData = fileDoc.data();
                        
                        if (!fileData || !fileData.name) {
                            skippedCount++;
                            continue;
                        }
                        
                        if (fileData.data && fileData.data.length > 1.5 * 1024 * 1024) {
                            skippedCount++;
                            continue;
                        }
                        
                        loadedServerFiles.push({
                            id: fileDoc.id,
                            name: fileData.name,
                            type: fileData.type,
                            size: fileData.size,
                            data: fileData.data || null,
                            textContent: fileData.textContent || null,
                            uploadedAt: fileData.uploadedAt,
                            isLocal: false
                        });
                    } catch (fileErr) {
                        skippedCount++;
                    }
                }
                
                if (loadedServerFiles.length > 0) {
                    const localFiles = fileStorage.filter(f => f.isLocal);
                    for (const serverFile of loadedServerFiles) {
                        const exists = localFiles.some(f => f.id === serverFile.id);
                        if (!exists) {
                            localFiles.push(serverFile);
                            fileCount++;
                        }
                    }
                    fileStorage = localFiles;
                }
            }
        } catch (fileLoadErr) {
            console.error('íŒŒì¼ ë³´ê´€í•¨ ë¡œë“œ ì˜¤ë¥˜:', fileLoadErr);
        }
        
        // ===== íŒŒì¼ í´ë” ì²˜ë¦¬ =====
        let loadedFileFolderCount = 0;
        try {
            if (!fileFoldersSnapshot.empty) {
                // ì„œë²„ì— ìˆëŠ” í´ë” ID ëª©ë¡
                const serverFolderIds = new Set(fileFoldersSnapshot.docs.map(doc => doc.id));
                
                // ë¡œì»¬ì—ë§Œ ìˆê³  ì„œë²„ì— ì—†ëŠ” í´ë” ì‚­ì œ (ë™ê¸°í™”)
                for (const localFolderId of Object.keys(fileFolders)) {
                    if (!serverFolderIds.has(localFolderId)) {
                        delete fileFolders[localFolderId];
                        // í•´ë‹¹ í´ë”ì— ì—°ê²°ëœ íŒŒì¼ë“¤ì˜ ë§¤í•‘ë„ ì œê±°
                        for (const fileId in fileToFolder) {
                            if (fileToFolder[fileId] === localFolderId) {
                                delete fileToFolder[fileId];
                            }
                        }
                        console.log('ì„œë²„ì— ì—†ëŠ” ë¡œì»¬ í´ë” ì‚­ì œ:', localFolderId);
                    }
                }
                
                for (const folderDoc of fileFoldersSnapshot.docs) {
                    const folderData = folderDoc.data();
                    const folderId = folderDoc.id;
                    
                    if (!fileFolders[folderId]) {
                        fileFolders[folderId] = {
                            name: folderData.name,
                            parentId: folderData.parentId || null,
                            createdAt: folderData.createdAt || new Date().toISOString()
                        };
                        loadedFileFolderCount++;
                    }
                }
                saveFileFolderData();
            }
            
            // íŒŒì¼-í´ë” ë§¤í•‘ ë¶ˆëŸ¬ì˜¤ê¸°
            const userSettingsDoc = await db.collection('userSettings').doc(currentUser.uid).get();
            if (userSettingsDoc.exists) {
                const settings = userSettingsDoc.data();
                if (settings.fileToFolder) {
                    fileToFolder = { ...fileToFolder, ...settings.fileToFolder };
                    saveFileFolderData();
                }
            }
        } catch (fileFolderErr) {
            console.log('íŒŒì¼ í´ë” ë¡œë“œ ì˜¤ë¥˜ (ë¬´ì‹œ):', fileFolderErr);
        }

        // ===== ì›ë³¸ íŒŒì¼ ì²˜ë¦¬ =====
        let loadedRawFileCount = 0;
        try {
            updateLoadingText('ì›ë³¸ íŒŒì¼ ì²˜ë¦¬ ì¤‘...');
            const rawFilesSnapshot = await db.collection('rawFiles')
                .where('userId', '==', currentUser.uid)
                .get();

            if (!rawFilesSnapshot.empty) {
                for (const doc of rawFilesSnapshot.docs) {
                    const data = doc.data();
                    const fileName = data.name;

                    // ë¡œì»¬ì— ì—†ëŠ” ê²½ìš°ë§Œ ì¶”ê°€
                    if (!rawFiles[fileName]) {
                        rawFiles[fileName] = {
                            name: data.name,
                            displayName: data.displayName || fileName,
                            sheets: data.sheets || {},
                            lastUpdated: data.lastUpdated?.toDate() || new Date(),
                            totalRows: data.totalRows || 0,
                            sourceFiles: data.sourceFiles || [fileName]
                        };
                        loadedRawFileCount++;
                    }
                }
                saveRawFilesToLocalStorage();
            }
        } catch (rawFileErr) {
            console.log('ì›ë³¸ íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜ (ë¬´ì‹œ):', rawFileErr);
        }

        // ì²« ë²ˆì§¸ ì‹œíŠ¸ ì„ íƒ
        const sheetNames = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
        if (sheetNames.length > 0) {
            SHEET = sheetNames[0];
        }
        
        // ë£¨íŠ¸ í´ë”ë¡œ ì´ë™
        currentFolderId = null;
        currentFileFolderId = null;
        
        // ì‹œíŠ¸ íƒ­ìœ¼ë¡œ ì „í™˜
        currentMainTab = 'sheets';
        const sheetsContainer = document.getElementById('sheetsContainer');
        const filesContainer = document.getElementById('fileStorageContainer');
        if (sheetsContainer) sheetsContainer.style.display = '';
        if (filesContainer) filesContainer.style.display = 'none';
        document.querySelectorAll('.main-tab').forEach(t => {
            t.classList.toggle('active', t.dataset.tab === 'sheets');
        });
        
        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
        hideLoading();
        renderMainScreen();
        renderFileStoragePanel();
        
        // ë¡œì»¬ ì €ì¥ì†Œì— ì €ì¥
        saveToLocalStorage();
        
        let msg = 'ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ (';
        const parts = [];
        if (loadedFolderCount > 0) parts.push(`${loadedFolderCount}ê°œ ì‹œíŠ¸í´ë”`);
        if (loadedFileFolderCount > 0) parts.push(`${loadedFileFolderCount}ê°œ íŒŒì¼í´ë”`);
        if (sheetCount > 0) parts.push(`${sheetCount}ê°œ ì‹œíŠ¸, ${totalRows}í–‰`);
        if (fileCount > 0) parts.push(`${fileCount}ê°œ íŒŒì¼`);
        if (loadedRawFileCount > 0) parts.push(`${loadedRawFileCount}ê°œ ì›ë³¸íŒŒì¼`);
        if (parts.length === 0) parts.push('ë°ì´í„° ì—†ìŒ');
        msg += parts.join(', ') + `, ${elapsed}ì´ˆ)`;
        toast(msg);
        
    } catch (error) {
        hideLoading();
        console.error('ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
        toast('ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + error.message);
    }
}

// ===== ê°„ë‹¨í•œ ì„œë²„ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° =====

// ì„œë²„ ì €ì¥ (í˜„ì¬ íƒ­ ê¸°ì¤€)
async function simpleServerSave() {
    if (!currentUser) {
        toast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
        return;
    }
    if (!db) {
        toast('Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
        return;
    }

    switch (currentMainTab) {
        case 'sheets':
            await saveAllToFirestore();
            break;
        case 'files':
            await saveAllToFirestore(); // íŒŒì¼ ë³´ê´€í•¨ë„ ê°™ì´ ì €ì¥ë¨
            break;
        case 'rawfiles':
            await saveRawFilesToFirestore();
            break;
        default:
            await saveAllToFirestore();
    }
}

// ì„œë²„ ë¶ˆëŸ¬ì˜¤ê¸° (í˜„ì¬ íƒ­ ê¸°ì¤€)
async function simpleServerLoad() {
    if (!currentUser) {
        toast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
        return;
    }
    if (!db) {
        toast('Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
        return;
    }

    switch (currentMainTab) {
        case 'sheets':
            await loadSheetsFromFirestore();
            break;
        case 'files':
            await loadSheetsFromFirestore(); // íŒŒì¼ ë³´ê´€í•¨ë„ ê°™ì´ ë¶ˆëŸ¬ì˜´
            break;
        case 'rawfiles':
            await loadRawFilesFromFirestore();
            break;
        default:
            await loadSheetsFromFirestore();
    }
}

// ===== ì €ì¥ ë“œë¡­ë‹¤ìš´ ë©”ë‰´ (ë ˆê±°ì‹œ) =====

// ì €ì¥ ë“œë¡­ë‹¤ìš´ í† ê¸€
function toggleSaveDropdown() {
    const menu = document.getElementById('saveDropdownMenu');
    if (!menu) return;
    menu.classList.toggle('show');

    // ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
    if (menu.classList.contains('show')) {
        setTimeout(() => {
            document.addEventListener('click', closeSaveDropdown, { once: true });
        }, 10);
    }
}

function closeSaveDropdown(e) {
    const menu = document.getElementById('saveDropdownMenu');
    if (!menu) return;
    const wrapper = document.querySelector('.save-dropdown-wrapper');
    if (wrapper && !wrapper.contains(e?.target)) {
        menu.classList.remove('show');
    }
}

// í˜„ì¬ ì‹œíŠ¸ë§Œ ì €ì¥
async function saveCurrentSheetOnly() {
    closeSaveDropdown();
    
    if (!currentUser || !db) {
        toast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
        return;
    }
    
    if (!SHEET || !WB[SHEET]) {
        toast('ì €ì¥í•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì‹œíŠ¸ë¥¼ ë¨¼ì € ì—´ì–´ì£¼ì„¸ìš”.');
        return;
    }
    
    showLoading(`'${SHEET}' ì €ì¥ ì¤‘...`);
    
    try {
        const folderId = sheetToFolder[SHEET] || null;
        await saveSheetToFirestoreWithFolder(SHEET, folderId);
        hideLoading();
        toast(`'${SHEET}' ì €ì¥ ì™„ë£Œ`);
    } catch (error) {
        hideLoading();
        console.error('ì €ì¥ ì˜¤ë¥˜:', error);
        toast('ì €ì¥ ì‹¤íŒ¨: ' + error.message);
    }
}

// í˜„ì¬ í´ë” ì „ì²´ ì €ì¥
async function saveCurrentFolderAll() {
    closeSaveDropdown();
    
    if (!currentUser || !db) {
        toast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
        return;
    }
    
    // currentFolderIdê°€ nullì´ë©´ ì „ì²´ ì‹œíŠ¸
    const folderId = currentFolderId;
    const folderName = folderId ? sheetFolders[folderId]?.name : 'ì „ì²´';
    
    // í•´ë‹¹ í´ë”ì˜ ì‹œíŠ¸ë“¤
    let sheetsToSave = [];
    if (folderId === null) {
        // ì „ì²´: ëª¨ë“  ì‹œíŠ¸ ì €ì¥ (í´ë” í¬í•¨ ì—¬ë¶€ ë¬´ê´€)
        sheetsToSave = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
    } else {
        // íŠ¹ì • í´ë” ì•ˆì˜ ì‹œíŠ¸ë“¤
        sheetsToSave = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0 && sheetToFolder[n] === folderId);
    }
    
    if (sheetsToSave.length === 0) {
        toast('ì €ì¥í•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    const msg = folderId 
        ? `'${folderName}' í´ë”ì™€ ë‚´ë¶€ ${sheetsToSave.length}ê°œ ì‹œíŠ¸ë¥¼ ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`
        : `ì „ì²´ ${sheetsToSave.length}ê°œ ì‹œíŠ¸ë¥¼ ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
    
    if (!confirm(msg)) return;
    
    showLoading('í´ë” ì €ì¥ ì¤‘...');
    
    try {
        // í´ë” ì •ë³´ ì €ì¥ (í´ë”ê°€ ìˆëŠ” ê²½ìš°)
        if (folderId && sheetFolders[folderId]) {
            updateLoadingText('í´ë” ì •ë³´ ì €ì¥ ì¤‘...');
            await db.collection('folders').doc(folderId).set({
                name: sheetFolders[folderId].name,
                parentId: sheetFolders[folderId].parentId || null,
                createdAt: sheetFolders[folderId].createdAt,
                userId: currentUser.uid,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
        }
        
        // ì‹œíŠ¸ë“¤ ì €ì¥
        let savedCount = 0;
        for (const sheetName of sheetsToSave) {
            updateLoadingText(`'${sheetName}' ì €ì¥ ì¤‘... (${savedCount + 1}/${sheetsToSave.length})`);
            await saveSheetToFirestoreWithFolder(sheetName, folderId);
            savedCount++;
        }
        
        hideLoading();
        toast(`${folderName}: ${savedCount}ê°œ ì‹œíŠ¸ ì €ì¥ ì™„ë£Œ`);
        
    } catch (error) {
        hideLoading();
        console.error('í´ë” ì €ì¥ ì˜¤ë¥˜:', error);
        toast('ì €ì¥ ì‹¤íŒ¨: ' + error.message);
    }
}

// ëª¨ë“  ì‹œíŠ¸ë¥¼ ì„œë²„ì— ì €ì¥ (í´ë” í¬í•¨)
async function saveAllToFirestore() {
    closeSaveDropdown();
    
    if (!currentUser) {
        toast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
        return;
    }
    
    if (!db) {
        toast('Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (ì˜¤í”„ë¼ì¸ ëª¨ë“œ)');
        return;
    }
    
    const localSheetNames = Object.keys(WB).filter(n => WB[n] && WB[n].data && WB[n].data.length > 0);
    const localFiles = fileStorage.filter(f => f.isLocal);
    const localFolderCount = Object.keys(sheetFolders).length;
    const localFileFolderCount = Object.keys(fileFolders).length;
    
    if (localSheetNames.length === 0 && localFiles.length === 0 && localFolderCount === 0 && localFileFolderCount === 0) {
        toast('ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    // 1MB ì´ˆê³¼ íŒŒì¼ ì²´í¬
    const largeFiles = localFiles.filter(f => f.size > 1024 * 1024);
    if (largeFiles.length > 0) {
        const names = largeFiles.map(f => f.name).join(', ');
        if (!confirm(`ë‹¤ìŒ íŒŒì¼ì€ 1MBë¥¼ ì´ˆê³¼í•˜ì—¬ ì €ì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:\n${names}\n\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
    }
    
    const savableFiles = localFiles.filter(f => f.size <= 1024 * 1024);
    const serverFiles = fileStorage.filter(f => !f.isLocal);
    const totalFileCount = savableFiles.length + serverFiles.length;
    
    let confirmMsg = '';
    if (localFolderCount > 0) confirmMsg += `${localFolderCount}ê°œ ì‹œíŠ¸í´ë”, `;
    if (localFileFolderCount > 0) confirmMsg += `${localFileFolderCount}ê°œ íŒŒì¼í´ë”, `;
    if (localSheetNames.length > 0) confirmMsg += `${localSheetNames.length}ê°œ ì‹œíŠ¸`;
    if (totalFileCount > 0) {
        if (confirmMsg) confirmMsg += ', ';
        confirmMsg += `${totalFileCount}ê°œ íŒŒì¼`;
        if (savableFiles.length > 0) {
            confirmMsg += ` (ìƒˆ íŒŒì¼ ${savableFiles.length}ê°œ)`;
        }
    }
    
    if (!confirm(`${confirmMsg}ì„(ë¥¼) ì„œë²„ì— ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ì‚­ì œëœ í•­ëª©ì€ ì„œë²„ì—ì„œë„ ì‚­ì œë©ë‹ˆë‹¤)`)) return;
    
    showLoading('ì„œë²„ì— ì €ì¥ ì¤‘...');
    const startTime = Date.now();
    let totalRows = 0;
    let deletedCount = 0;
    let savedFileCount = 0;
    let savedFolderCount = 0;
    let savedFileFolderCount = 0;
    
    try {
        // ===== ì‹œíŠ¸ í´ë” ì €ì¥ =====
        if (localFolderCount > 0) {
            updateLoadingText('ì‹œíŠ¸ í´ë” ì €ì¥ ì¤‘...');
            
            for (const [folderId, folder] of Object.entries(sheetFolders)) {
                await db.collection('folders').doc(folderId).set({
                    name: folder.name,
                    parentId: folder.parentId || null,
                    createdAt: folder.createdAt,
                    userId: currentUser.uid,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                savedFolderCount++;
            }
        }
        
        // ===== íŒŒì¼ í´ë” ì €ì¥ =====
        if (localFileFolderCount > 0) {
            updateLoadingText('íŒŒì¼ í´ë” ì €ì¥ ì¤‘...');
            
            for (const [folderId, folder] of Object.entries(fileFolders)) {
                await db.collection('fileFolders').doc(folderId).set({
                    name: folder.name,
                    parentId: folder.parentId || null,
                    createdAt: folder.createdAt,
                    userId: currentUser.uid,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                savedFileFolderCount++;
            }
            
            // íŒŒì¼-í´ë” ë§¤í•‘ë„ ì €ì¥
            await db.collection('userSettings').doc(currentUser.uid).set({
                fileToFolder: fileToFolder
            }, { merge: true });
        }
        
        // ===== ì‹œíŠ¸ ì €ì¥ (í´ë” ID í¬í•¨) =====
        if (localSheetNames.length > 0) {
            // 1. ì„œë²„ì— ìˆëŠ” ì‹œíŠ¸ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            updateLoadingText('ì„œë²„ ì‹œíŠ¸ ëª©ë¡ í™•ì¸ ì¤‘...');
            const serverSnapshot = await db.collection('sheets').get();
            const serverSheetNames = serverSnapshot.docs.map(doc => doc.id);
            
            // 2. ì„œë²„ì—ë§Œ ìˆê³  ë¡œì»¬ì— ì—†ëŠ” ì‹œíŠ¸ ì‚­ì œ
            const toDelete = serverSheetNames.filter(name => !localSheetNames.includes(name));
            
            for (const serverName of toDelete) {
                updateLoadingText(`'${serverName}' ì„œë²„ì—ì„œ ì‚­ì œ ì¤‘...`);
                await deleteSheetFromFirestoreSilent(serverName);
                deletedCount++;
            }
            
            // 3. ë¡œì»¬ ì‹œíŠ¸ ì €ì¥ (í´ë” ID í¬í•¨)
            for (const name of localSheetNames) {
                const folderId = sheetToFolder[name] || null;
                await saveSheetToFirestoreWithFolder(name, folderId);
                totalRows += WB[name].data.length;
            }
        }
        
        // ===== íŒŒì¼ ë³´ê´€í•¨ ì €ì¥ =====
        let failedFileCount = 0;
        if (savableFiles.length > 0) {
            updateLoadingText('íŒŒì¼ ë³´ê´€í•¨ ì €ì¥ ì¤‘...');
            
            // ì„œë²„ì˜ ê¸°ì¡´ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            try {
                const serverFilesSnapshot = await db.collection('userFiles')
                    .where('userId', '==', currentUser.uid)
                    .get();
                const serverFileIds = serverFilesSnapshot.docs.map(doc => doc.id);
            } catch (e) {
                console.warn('ì„œë²„ íŒŒì¼ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:', e);
            }
            
            // ë¡œì»¬ íŒŒì¼ ê°œë³„ ì €ì¥ (ì˜¤ë¥˜ ê²©ë¦¬)
            const FIRESTORE_DOC_LIMIT = 700 * 1024; // 700KB (Firestore 1MB ì œí•œ ëŒ€ë¹„ ì—¬ìœ )
            
            for (const file of savableFiles) {
                try {
                    updateLoadingText(`'${file.name}' ì €ì¥ ì¤‘...`);
                    
                    let fileDoc = {
                        name: file.name,
                        type: file.type,
                        size: file.size,
                        textContent: file.textContent || null,
                        folderId: fileToFolder[file.id] || null,
                        uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        userId: currentUser.uid
                    };
                    
                    // íŒŒì¼ í¬ê¸°ê°€ í¬ë©´ Storageì— ì €ì¥
                    if (file.data && file.data.length > FIRESTORE_DOC_LIMIT) {
                        if (storage) {
                            const storagePath = `userFiles/${currentUser.uid}/${Date.now()}_${file.name}`;
                            const storageRef = storage.ref(storagePath);
                            
                            // Base64ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
                            const base64Data = file.data.split(',')[1] || file.data;
                            const byteChars = atob(base64Data);
                            const byteNumbers = new Array(byteChars.length);
                            for (let i = 0; i < byteChars.length; i++) {
                                byteNumbers[i] = byteChars.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray]);
                            
                            await storageRef.put(blob);
                            const downloadURL = await storageRef.getDownloadURL();
                            
                            fileDoc.storagePath = storagePath;
                            fileDoc.downloadURL = downloadURL;
                            fileDoc.data = null; // Firestoreì—ëŠ” ë°ì´í„° ì €ì¥ ì•ˆí•¨
                        } else {
                            console.warn('Storage ë¯¸ì´ˆê¸°í™” - í° íŒŒì¼ ì €ì¥ ë¶ˆê°€:', file.name);
                            failedFileCount++;
                            continue;
                        }
                    } else {
                        fileDoc.data = file.data; // ì‘ì€ íŒŒì¼ì€ ì§ì ‘ ì €ì¥
                    }
                    
                    const docRef = await db.collection('userFiles').add(fileDoc);
                    
                    // ë¡œì»¬ íŒŒì¼ ID ì—…ë°ì´íŠ¸ (ì„œë²„ IDë¡œ)
                    file.id = docRef.id;
                    file.isLocal = false;
                    if (fileDoc.storagePath) file.storagePath = fileDoc.storagePath;
                    if (fileDoc.downloadURL) file.downloadURL = fileDoc.downloadURL;
                    
                    savedFileCount++;
                } catch (fileErr) {
                    console.error(`íŒŒì¼ ì €ì¥ ì‹¤íŒ¨ (${file.name}):`, fileErr);
                    failedFileCount++;
                    // ì‹¤íŒ¨í•´ë„ ë‹¤ìŒ íŒŒì¼ ê³„ì† ì €ì¥
                }
            }
        }
        
        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
        hideLoading();
        
        let msg = 'ì €ì¥ ì™„ë£Œ (';
        const parts = [];
        if (localSheetNames.length > 0) parts.push(`${localSheetNames.length}ê°œ ì‹œíŠ¸, ${totalRows}í–‰`);
        if (savedFileCount > 0) parts.push(`${savedFileCount}ê°œ íŒŒì¼`);
        msg += parts.join(', ') + `, ${elapsed}ì´ˆ)`;
        if (deletedCount > 0) {
            msg += ` / ${deletedCount}ê°œ ì‹œíŠ¸ ì‚­ì œë¨`;
        }
        if (failedFileCount > 0) {
            msg += ` / ${failedFileCount}ê°œ íŒŒì¼ ì €ì¥ ì‹¤íŒ¨`;
        }
        toast(msg);
        
        renderFileStoragePanel();
        
    } catch (error) {
        hideLoading();
        console.error('ì €ì¥ ì˜¤ë¥˜:', error);
        toast('ì„œë²„ ì €ì¥ ì‹¤íŒ¨: ' + error.message);
    }
}

// ì›ë³¸ íŒŒì¼(rawFiles)ì„ ì„œë²„ì— ì €ì¥
async function saveRawFilesToFirestore() {
    closeSaveDropdown();

    if (!currentUser) {
        toast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
        return;
    }

    if (!db) {
        toast('Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (ì˜¤í”„ë¼ì¸ ëª¨ë“œ)');
        return;
    }

    const rawFileNames = Object.keys(rawFiles);
    if (rawFileNames.length === 0) {
        toast('ì €ì¥í•  ì›ë³¸ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }

    // ì´ í–‰ ìˆ˜ ê³„ì‚°
    let totalRows = 0;
    rawFileNames.forEach(fileName => {
        const file = rawFiles[fileName];
        Object.values(file.sheets || {}).forEach(sheet => {
            totalRows += (sheet.data || []).length;
        });
    });

    if (!confirm(`${rawFileNames.length}ê°œ ì›ë³¸ íŒŒì¼ (${totalRows}í–‰)ì„ ì„œë²„ì— ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;

    showLoading('ì›ë³¸ íŒŒì¼ ì„œë²„ ì €ì¥ ì¤‘...');
    const startTime = Date.now();
    let savedCount = 0;
    let failedCount = 0;

    try {
        for (const fileName of rawFileNames) {
            try {
                updateLoadingText(`'${fileName}' ì €ì¥ ì¤‘...`);
                const fileData = rawFiles[fileName];

                // ì‹œíŠ¸ë³„ë¡œ ì €ì¥ (ë°ì´í„° í¬ê¸° ì œí•œ ëŒ€ë¹„)
                const sheetsToSave = {};
                for (const [sheetName, sheetData] of Object.entries(fileData.sheets || {})) {
                    sheetsToSave[sheetName] = {
                        headers: sheetData.headers || [],
                        data: sheetData.data || [],
                        // ìŠ¤íƒ€ì¼ì€ ë„ˆë¬´ í¬ë¯€ë¡œ ì €ì¥ ì•ˆí•¨
                        colWidths: sheetData.colWidths || [],
                        rowHeights: sheetData.rowHeights || []
                    };
                }

                const docData = {
                    name: fileData.name,
                    displayName: fileData.displayName || fileName,
                    sheets: sheetsToSave,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    totalRows: fileData.totalRows || 0,
                    sourceFiles: fileData.sourceFiles || [fileName],
                    userId: currentUser.uid
                };

                // íŒŒì¼ëª…ì„ IDë¡œ ì‚¬ìš© (íŠ¹ìˆ˜ë¬¸ì ì²˜ë¦¬)
                const docId = fileName.replace(/[\/\\\.]/g, '_');
                await db.collection('rawFiles').doc(docId).set(docData);
                savedCount++;
            } catch (fileErr) {
                console.error(`ì›ë³¸ íŒŒì¼ ì €ì¥ ì‹¤íŒ¨ (${fileName}):`, fileErr);
                failedCount++;
            }
        }

        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
        hideLoading();

        let msg = `ì›ë³¸ íŒŒì¼ ì €ì¥ ì™„ë£Œ (${savedCount}ê°œ, ${totalRows}í–‰, ${elapsed}ì´ˆ)`;
        if (failedCount > 0) {
            msg += ` / ${failedCount}ê°œ ì‹¤íŒ¨`;
        }
        toast(msg);

    } catch (error) {
        hideLoading();
        console.error('ì›ë³¸ íŒŒì¼ ì €ì¥ ì˜¤ë¥˜:', error);
        toast('ì›ë³¸ íŒŒì¼ ì„œë²„ ì €ì¥ ì‹¤íŒ¨: ' + error.message);
    }
}

// ì„œë²„ì—ì„œ ì›ë³¸ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°
async function loadRawFilesFromFirestore() {
    if (!currentUser || !db) return;

    try {
        const snapshot = await db.collection('rawFiles')
            .where('userId', '==', currentUser.uid)
            .get();

        if (snapshot.empty) return;

        snapshot.forEach(doc => {
            const data = doc.data();
            const fileName = data.name;

            // ë¡œì»¬ì— ì—†ëŠ” ê²½ìš°ë§Œ ì¶”ê°€
            if (!rawFiles[fileName]) {
                rawFiles[fileName] = {
                    name: data.name,
                    displayName: data.displayName || fileName,
                    sheets: data.sheets || {},
                    lastUpdated: data.lastUpdated?.toDate() || new Date(),
                    totalRows: data.totalRows || 0,
                    sourceFiles: data.sourceFiles || [fileName]
                };
            }
        });

        saveRawFilesToLocalStorage();
        console.log(`ì„œë²„ì—ì„œ ì›ë³¸ íŒŒì¼ ${snapshot.size}ê°œ ë¶ˆëŸ¬ì˜´`);

    } catch (error) {
        console.error('ì›ë³¸ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
    }
}

// ì„œë²„ì—ì„œ ë°ì´í„° ì‚­ì œ (í† ìŠ¤íŠ¸ ì—†ì´)
async function deleteSheetFromFirestoreSilent(sheetName) {
    if (!db) return;
    
    try {
        // ì²­í¬ ë°ì´í„° ì‚­ì œ
        const chunksSnapshot = await db.collection('sheets').doc(sheetName).collection('chunks').get();
        const chunkDeletes = chunksSnapshot.docs.map(doc => doc.ref.delete());
        await Promise.all(chunkDeletes);
        
        // êµ¬ë²„ì „ rows ë°ì´í„° ì‚­ì œ
        const rowsSnapshot = await db.collection('sheets').doc(sheetName).collection('rows').get();
        const rowDeletes = rowsSnapshot.docs.map(doc => doc.ref.delete());
        await Promise.all(rowDeletes);
        
        // ì‹œíŠ¸ ë¬¸ì„œ ì‚­ì œ
        await db.collection('sheets').doc(sheetName).delete();
    } catch (error) {
        console.error('ì‚­ì œ ì˜¤ë¥˜:', error);
    }
}

// ì„œë²„ì—ì„œ ë°ì´í„° ì‚­ì œ
async function deleteSheetFromFirestore(sheetName) {
    if (!db) {
        toast('Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (ì˜¤í”„ë¼ì¸ ëª¨ë“œ)');
        return;
    }
    
    try {
        // ì²­í¬ ë°ì´í„° ì‚­ì œ
        const chunksSnapshot = await db.collection('sheets').doc(sheetName).collection('chunks').get();
        const chunkDeletes = chunksSnapshot.docs.map(doc => doc.ref.delete());
        await Promise.all(chunkDeletes);
        
        // êµ¬ë²„ì „ rows ë°ì´í„° ì‚­ì œ
        const rowsSnapshot = await db.collection('sheets').doc(sheetName).collection('rows').get();
        const rowDeletes = rowsSnapshot.docs.map(doc => doc.ref.delete());
        await Promise.all(rowDeletes);
        
        // ì‹œíŠ¸ ë¬¸ì„œ ì‚­ì œ
        await db.collection('sheets').doc(sheetName).delete();
        
        toast(`'${sheetName}' ì„œë²„ì—ì„œ ì‚­ì œë¨`);
    } catch (error) {
        console.error('ì‚­ì œ ì˜¤ë¥˜:', error);
        toast('ì„œë²„ ì‚­ì œ ì‹¤íŒ¨');
    }
}

// ===================================================================
// íŒŒì¼ ë³€í™˜ ë° ê´€ë¦¬ ì‹œìŠ¤í…œ (9ê°€ì§€ ê¸°ëŠ¥)
// ===================================================================

// íŒŒì¼ íƒ€ì…ë³„ ì•„ì´ì½˜
function getFileIcon(ext) {
    const icons = {
        'pdf': 'ğŸ“•',
        'pptx': 'ğŸ“™',
        'ppt': 'ğŸ“™',
        'docx': 'ğŸ“˜',
        'doc': 'ğŸ“˜',
        'txt': 'ğŸ“„',
        'html': 'ğŸŒ',
        'htm': 'ğŸŒ',
        'xlsx': 'ğŸ“—',
        'xls': 'ğŸ“—',
        'csv': 'ğŸ“Š',
        'png': 'ğŸ–¼ï¸',
        'jpg': 'ğŸ–¼ï¸',
        'jpeg': 'ğŸ–¼ï¸',
        'gif': 'ğŸ–¼ï¸',
        'webp': 'ğŸ–¼ï¸',
        'bmp': 'ğŸ–¼ï¸',
        'svg': 'ğŸ–¼ï¸'
    };
    return icons[ext.toLowerCase()] || 'ğŸ“';
}

// íŒŒì¼ í™•ì¥ì ì¶”ì¶œ
function getFileExtension(filename) {
    return filename.split('.').pop().toLowerCase();
}

// íŒŒì¼ í¬ê¸° í¬ë§·
function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// ===== 1. íŒŒì¼ ì—…ë¡œë“œ ì„ íƒ ëª¨ë‹¬ =====
let pendingUploadFile = null;

function showUploadChoiceModal(file) {
    pendingUploadFile = file;
    const ext = getFileExtension(file.name);
    const icon = getFileIcon(ext);
    
    const modalHtml = `
        <div class="modal-overlay upload-choice-modal show" id="uploadChoiceModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>íŒŒì¼ ì—…ë¡œë“œ</h3>
                    <button class="modal-close" onclick="closeUploadChoiceModal()">Ã—</button>
                </div>
                <div class="upload-file-info">
                    <span class="upload-file-icon">${icon}</span>
                    <div class="upload-file-details">
                        <div class="upload-file-name">${file.name}</div>
                        <div class="upload-file-size">${formatFileSize(file.size)} â€¢ ${ext.toUpperCase()}</div>
                    </div>
                </div>
                <div class="upload-choice-options">
                    <label class="upload-choice-option selected" onclick="selectUploadChoice('save')">
                        <input type="radio" name="uploadChoice" value="save" checked>
                        <div class="upload-choice-label">
                            <strong>ì›ë³¸ ê·¸ëŒ€ë¡œ ì €ì¥</strong>
                            <span>íŒŒì¼ì„ ë³€í™˜ ì—†ì´ ë³´ê´€í•¨ì— ì €ì¥í•©ë‹ˆë‹¤</span>
                        </div>
                    </label>
                    <label class="upload-choice-option" onclick="selectUploadChoice('convert')">
                        <input type="radio" name="uploadChoice" value="convert">
                        <div class="upload-choice-label">
                            <strong>ì—‘ì…€ ì‹œíŠ¸ë¡œ ë³€í™˜</strong>
                            <span>ë‚´ìš©ì„ ì¶”ì¶œí•˜ì—¬ ì‹œíŠ¸ë¡œ ì¶”ê°€í•©ë‹ˆë‹¤</span>
                        </div>
                    </label>
                    <label class="upload-choice-option" onclick="selectUploadChoice('both')">
                        <input type="radio" name="uploadChoice" value="both">
                        <div class="upload-choice-label">
                            <strong>ë‘˜ ë‹¤</strong>
                            <span>ì›ë³¸ ì €ì¥ + ì‹œíŠ¸ ë³€í™˜ ë™ì‹œ ì§„í–‰</span>
                        </div>
                    </label>
                </div>
                <div class="modal-footer">
                    <button class="modal-btn" onclick="closeUploadChoiceModal()">ì·¨ì†Œ</button>
                    <button class="modal-btn primary" onclick="processUploadChoice()">í™•ì¸</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function selectUploadChoice(choice) {
    document.querySelectorAll('.upload-choice-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    document.querySelector(`input[value="${choice}"]`).closest('.upload-choice-option').classList.add('selected');
    document.querySelector(`input[value="${choice}"]`).checked = true;
}

function closeUploadChoiceModal() {
    const modal = document.getElementById('uploadChoiceModal');
    if (modal) modal.remove();
    pendingUploadFile = null;
}

async function processUploadChoice() {
    const choiceInput = document.querySelector('input[name="uploadChoice"]:checked');
    
    if (!choiceInput) {
        toast('ì„ íƒëœ ì˜µì…˜ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    const choice = choiceInput.value;
    
    const file = pendingUploadFile;
    closeUploadChoiceModal();
    
    if (!file) return;
    
    showLoading('íŒŒì¼ ì²˜ë¦¬ ì¤‘...');
    
    try {
        if (choice === 'save' || choice === 'both') {
            await saveFileToStorage(file);
        }
        if (choice === 'convert' || choice === 'both') {
            await convertFileToSheet(file);
        }
        hideLoading();
        saveToLocalStorage(); // ë¡œì»¬ ì €ì¥ì†Œì— ì €ì¥
        toast('íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ!');
        
        // ì„ íƒì— ë”°ë¼ ì ì ˆí•œ íƒ­ìœ¼ë¡œ ìë™ ì „í™˜
        if (choice === 'save') {
            // ì›ë³¸ ì €ì¥ë§Œ: íŒŒì¼ ë³´ê´€í•¨ìœ¼ë¡œ ì´ë™
            switchMainTab('files');
        } else if (choice === 'convert') {
            // ì‹œíŠ¸ ë³€í™˜ë§Œ: ì‹œíŠ¸ ëª©ë¡ìœ¼ë¡œ ì´ë™
            switchMainTab('sheets');
            renderMainScreen();
        } else if (choice === 'both') {
            // ë‘˜ ë‹¤: ì‹œíŠ¸ ëª©ë¡ìœ¼ë¡œ ì´ë™ (ì£¼ ì‘ì—… ê²°ê³¼)
            switchMainTab('sheets');
            renderMainScreen();
        }
    } catch (error) {
        hideLoading();
        console.error('íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
        toast('íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
    }
}

// ===== 2. ì›ë³¸ íŒŒì¼ ì €ì¥ (ë¡œì»¬ ë³´ê´€í•¨) =====
async function saveFileToStorage(file) {
    const ext = getFileExtension(file.name);
    let textContent = null;
    
    // TXT, HTML íŒŒì¼ì€ ë‚´ìš© ì¶”ì¶œí•˜ì—¬ ê²€ìƒ‰ ê°€ëŠ¥í•˜ê²Œ ì €ì¥
    if (ext === 'txt' || ext === 'html' || ext === 'htm') {
        textContent = await file.text();
    }
    
    // í•­ìƒ ë¡œì»¬ ì €ì¥ (Firebase Storage CORS ë¬¸ì œ íšŒí”¼)
    const reader = new FileReader();
    return new Promise((resolve, reject) => {
        reader.onload = (e) => {
            const fileData = {
                id: 'local_' + Date.now(),
                name: file.name,
                type: ext,
                size: file.size,
                data: e.target.result, // Base64
                textContent: textContent, // TXT/HTML íŒŒì¼ ë‚´ìš© (ê²€ìƒ‰ìš©)
                uploadedAt: new Date().toISOString(),
                isLocal: true
            };
            fileStorage.push(fileData);
            
            // ìºì‹œ ë¬´íš¨í™” í›„ íƒ­ ì „í™˜ ë° ë Œë”ë§
            invalidateFileRenderCache();
            switchMainTab('files');
            renderFileStoragePanel();
            toast(`'${file.name}' ë³´ê´€í•¨ì— ì €ì¥ë¨`);
            resolve(fileData);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

// ===== 3. íŒŒì¼ â†’ ì‹œíŠ¸ ë³€í™˜ =====
async function convertFileToSheet(file) {
    const ext = getFileExtension(file.name);
    const baseName = file.name.replace(/\.[^/.]+$/, '');
    
    updateLoadingText(`${ext.toUpperCase()} íŒŒì¼ ë³€í™˜ ì¤‘...`);
    
    switch(ext) {
        case 'pdf':
            await convertPdfToSheet(file, baseName);
            break;
        case 'pptx':
        case 'ppt':
            await convertPptxToSheet(file, baseName);
            break;
        case 'docx':
        case 'doc':
            await convertDocxToSheet(file, baseName);
            break;
        case 'txt':
            await convertTxtToSheet(file, baseName);
            break;
        case 'html':
        case 'htm':
            await convertHtmlToSheet(file, baseName);
            break;
        default:
            throw new Error('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤: ' + ext);
    }
}

// PDF â†’ ì‹œíŠ¸ ë³€í™˜
async function convertPdfToSheet(file, baseName) {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    
    const headers = ['í˜ì´ì§€', 'ìœ í˜•', 'ë‚´ìš©'];
    const data = [];
    
    for (let i = 1; i <= pdf.numPages; i++) {
        updateLoadingText(`PDF ë³€í™˜ ì¤‘... (${i}/${pdf.numPages} í˜ì´ì§€)`);
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        
        let pageText = '';
        let currentLine = '';
        let lastY = null;
        
        textContent.items.forEach(item => {
            if (lastY !== null && Math.abs(item.transform[5] - lastY) > 5) {
                if (currentLine.trim()) {
                    pageText += currentLine.trim() + '\n';
                }
                currentLine = '';
            }
            currentLine += item.str + ' ';
            lastY = item.transform[5];
        });
        if (currentLine.trim()) {
            pageText += currentLine.trim();
        }
        
        // í˜ì´ì§€ í…ìŠ¤íŠ¸ë¥¼ ì¤„ ë‹¨ìœ„ë¡œ ë¶„ë¦¬
        const lines = pageText.split('\n').filter(l => l.trim());
        lines.forEach(line => {
            data.push([String(i), 'í…ìŠ¤íŠ¸', line.trim()]);
        });
    }
    
    // ì‹œíŠ¸ ìƒì„±
    let sheetName = baseName;
    if (WB[sheetName] && WB[sheetName].data.length > 0) {
        let suffix = 2;
        while (WB[`${sheetName}(${suffix})`]) suffix++;
        sheetName = `${sheetName}(${suffix})`;
    }
    
    WB[sheetName] = { headers, data };
    COL_ORDER[sheetName] = headers.map((_, i) => i);
    HIDDEN_COLS[sheetName] = new Set();
    SHEET = sheetName;
    
    toast(`PDF â†’ '${sheetName}' ì‹œíŠ¸ ìƒì„± (${data.length}í–‰)`);
}

// PPTX â†’ ì‹œíŠ¸ ë³€í™˜
async function convertPptxToSheet(file, baseName) {
    const arrayBuffer = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(arrayBuffer);
    
    const headers = ['ìŠ¬ë¼ì´ë“œ', 'ìœ í˜•', 'ë‚´ìš©'];
    const data = [];
    
    // ìŠ¬ë¼ì´ë“œ íŒŒì¼ ì°¾ê¸°
    const slideFiles = Object.keys(zip.files)
        .filter(name => name.match(/ppt\/slides\/slide\d+\.xml$/))
        .sort((a, b) => {
            const numA = parseInt(a.match(/slide(\d+)/)[1]);
            const numB = parseInt(b.match(/slide(\d+)/)[1]);
            return numA - numB;
        });
    
    for (let i = 0; i < slideFiles.length; i++) {
        updateLoadingText(`PPTX ë³€í™˜ ì¤‘... (${i+1}/${slideFiles.length} ìŠ¬ë¼ì´ë“œ)`);
        
        const slideXml = await zip.file(slideFiles[i]).async('text');
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(slideXml, 'text/xml');
        
        // í…ìŠ¤íŠ¸ ì¶”ì¶œ (a:t íƒœê·¸)
        const textElements = xmlDoc.getElementsByTagName('a:t');
        let slideTexts = [];
        
        for (let j = 0; j < textElements.length; j++) {
            const text = textElements[j].textContent.trim();
            if (text) {
                slideTexts.push(text);
            }
        }
        
        // ì¤‘ë³µ ì œê±° ë° ì˜ë¯¸ ìˆëŠ” í…ìŠ¤íŠ¸ë§Œ ì €ì¥
        const uniqueTexts = [...new Set(slideTexts)];
        uniqueTexts.forEach((text, idx) => {
            const type = idx === 0 ? 'ì œëª©' : (text.length > 50 ? 'ë³¸ë¬¸' : 'í…ìŠ¤íŠ¸');
            data.push([String(i + 1), type, text]);
        });
    }
    
    // ì‹œíŠ¸ ìƒì„±
    let sheetName = baseName;
    if (WB[sheetName] && WB[sheetName].data.length > 0) {
        let suffix = 2;
        while (WB[`${sheetName}(${suffix})`]) suffix++;
        sheetName = `${sheetName}(${suffix})`;
    }
    
    WB[sheetName] = { headers, data };
    COL_ORDER[sheetName] = headers.map((_, i) => i);
    HIDDEN_COLS[sheetName] = new Set();
    SHEET = sheetName;
    
    toast(`PPTX â†’ '${sheetName}' ì‹œíŠ¸ ìƒì„± (${data.length}í–‰)`);
}

// DOCX â†’ ì‹œíŠ¸ ë³€í™˜
async function convertDocxToSheet(file, baseName) {
    const arrayBuffer = await file.arrayBuffer();
    
    // mammoth.jsë¡œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
    const result = await mammoth.extractRawText({ arrayBuffer });
    const text = result.value;
    
    const headers = ['ìˆœë²ˆ', 'ìœ í˜•', 'ë‚´ìš©'];
    const data = [];
    
    // ë¬¸ë‹¨ ë‹¨ìœ„ë¡œ ë¶„ë¦¬
    const paragraphs = text.split('\n').filter(p => p.trim());
    
    paragraphs.forEach((para, idx) => {
        const trimmed = para.trim();
        if (trimmed) {
            const type = trimmed.length < 30 ? 'ì œëª©' : 'ë³¸ë¬¸';
            data.push([String(idx + 1), type, trimmed]);
        }
    });
    
    // ì‹œíŠ¸ ìƒì„±
    let sheetName = baseName;
    if (WB[sheetName] && WB[sheetName].data.length > 0) {
        let suffix = 2;
        while (WB[`${sheetName}(${suffix})`]) suffix++;
        sheetName = `${sheetName}(${suffix})`;
    }
    
    WB[sheetName] = { headers, data };
    COL_ORDER[sheetName] = headers.map((_, i) => i);
    HIDDEN_COLS[sheetName] = new Set();
    SHEET = sheetName;
    
    toast(`DOCX â†’ '${sheetName}' ì‹œíŠ¸ ìƒì„± (${data.length}í–‰)`);
}

// TXT â†’ ì‹œíŠ¸ ë³€í™˜
async function convertTxtToSheet(file, baseName) {
    const text = await file.text();
    
    const headers = ['ì¤„ë²ˆí˜¸', 'ë‚´ìš©'];
    const data = [];
    
    const lines = text.split('\n');
    lines.forEach((line, idx) => {
        data.push([String(idx + 1), line]);
    });
    
    // ì‹œíŠ¸ ìƒì„±
    let sheetName = baseName;
    if (WB[sheetName] && WB[sheetName].data.length > 0) {
        let suffix = 2;
        while (WB[`${sheetName}(${suffix})`]) suffix++;
        sheetName = `${sheetName}(${suffix})`;
    }
    
    WB[sheetName] = { headers, data };
    COL_ORDER[sheetName] = headers.map((_, i) => i);
    HIDDEN_COLS[sheetName] = new Set();
    SHEET = sheetName;
    
    toast(`TXT â†’ '${sheetName}' ì‹œíŠ¸ ìƒì„± (${data.length}í–‰)`);
}

// HTML â†’ ì‹œíŠ¸ ë³€í™˜
async function convertHtmlToSheet(file, baseName) {
    const html = await file.text();
    
    // HTML íŒŒì„œ ì‚¬ìš©
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // í…Œì´ë¸”ì´ ìˆìœ¼ë©´ í…Œì´ë¸” ë°ì´í„° ì¶”ì¶œ
    const tables = doc.querySelectorAll('table');
    
    if (tables.length > 0) {
        // í…Œì´ë¸” ë°ì´í„° ì¶”ì¶œ
        let tableIdx = 1;
        for (const table of tables) {
            const rows = table.querySelectorAll('tr');
            if (rows.length === 0) continue;
            
            const data = [];
            let headers = [];
            let maxCols = 0;
            
            rows.forEach((row, rowIdx) => {
                const cells = row.querySelectorAll('th, td');
                const rowData = [];
                cells.forEach(cell => {
                    rowData.push(cell.textContent.trim());
                });
                maxCols = Math.max(maxCols, rowData.length);
                
                if (rowIdx === 0 && row.querySelectorAll('th').length > 0) {
                    headers = rowData;
                } else {
                    data.push(rowData);
                }
            });
            
            // í—¤ë”ê°€ ì—†ìœ¼ë©´ ìë™ ìƒì„±
            if (headers.length === 0) {
                headers = Array.from({length: maxCols}, (_, i) => `ì—´${i + 1}`);
            }
            
            // ì‹œíŠ¸ ìƒì„±
            let sheetName = tables.length > 1 ? `${baseName}_í‘œ${tableIdx}` : baseName;
            if (WB[sheetName] && WB[sheetName].data.length > 0) {
                let suffix = 2;
                while (WB[`${sheetName}(${suffix})`]) suffix++;
                sheetName = `${sheetName}(${suffix})`;
            }
            
            WB[sheetName] = { headers, data };
            COL_ORDER[sheetName] = headers.map((_, i) => i);
            HIDDEN_COLS[sheetName] = new Set();
            SHEET = sheetName;
            
            tableIdx++;
        }
        toast(`HTML â†’ ${tables.length}ê°œ í…Œì´ë¸” ì‹œíŠ¸ ìƒì„±`);
    } else {
        // í…Œì´ë¸”ì´ ì—†ìœ¼ë©´ í…ìŠ¤íŠ¸ ì¶”ì¶œ
        const body = doc.body;
        const text = body ? body.textContent : doc.documentElement.textContent;
        
        const headers = ['ì¤„ë²ˆí˜¸', 'ë‚´ìš©'];
        const data = [];
        
        const lines = text.split('\n').filter(line => line.trim());
        lines.forEach((line, idx) => {
            data.push([String(idx + 1), line.trim()]);
        });
        
        // ì‹œíŠ¸ ìƒì„±
        let sheetName = baseName;
        if (WB[sheetName] && WB[sheetName].data.length > 0) {
            let suffix = 2;
            while (WB[`${sheetName}(${suffix})`]) suffix++;
            sheetName = `${sheetName}(${suffix})`;
        }
        
        WB[sheetName] = { headers, data };
        COL_ORDER[sheetName] = headers.map((_, i) => i);
        HIDDEN_COLS[sheetName] = new Set();
        SHEET = sheetName;
        
        toast(`HTML â†’ '${sheetName}' ì‹œíŠ¸ ìƒì„± (${data.length}í–‰)`);
    }
}

// ===== 4. íŒŒì¼ ë³´ê´€í•¨ UI =====
let currentMainTab = 'sheets'; // 'sheets', 'files', or 'rawfiles'
let fileFavoriteFilter = false; // íŒŒì¼ ì¦ê²¨ì°¾ê¸° í•„í„°

// ===== ì›ë³¸ íŒŒì¼ ë°ì´í„° =====
// rawFiles êµ¬ì¡°: { fileName: { name, sheets: { sheetName: { headers, data: [...rows], uploadHistory: [{date, rowCount}] } }, lastUpdated, totalRows } }
var rawFiles = {};
var currentRawFile = null; // í˜„ì¬ ì„ íƒëœ ì›ë³¸ íŒŒì¼ëª…
var currentRawSheet = null; // í˜„ì¬ ì„ íƒëœ ì›ë³¸ íŒŒì¼ì˜ ì‹œíŠ¸ëª…

// ===== ì›ë³¸ íŒŒì¼ ê²€ìƒ‰/í•„í„°/ì •ë ¬ =====
var rawFileSearchKeyword = '';      // íŒŒì¼ëª… ê²€ìƒ‰ì–´
var rawFileSortBy = 'lastUpdated';  // ì •ë ¬ ê¸°ì¤€: 'name', 'lastUpdated', 'totalRows'
var rawFileSortOrder = 'desc';      // ì •ë ¬ ìˆœì„œ: 'asc', 'desc'
var rawFileViewMode = 'list';       // ë·° ëª¨ë“œ: 'list', 'card', 'icon'
var selectedRawFiles = new Set();   // ì„ íƒëœ ì›ë³¸ íŒŒì¼ë“¤
var rawFileSelectMode = false;      // ì„ íƒ ëª¨ë“œ í™œì„±í™” ì—¬ë¶€
var rawFileToSheetMapping = {};     // ì›ë³¸ íŒŒì¼ â†’ ì‹œíŠ¸ ì—°ê²° ë§¤í•‘

// ===== ì›ë³¸ íŒŒì¼ í´ë” ì‹œìŠ¤í…œ =====
var rawFileFolders = {};            // { folderId: { name, createdAt, color } }
var rawFileToFolder = {};           // { fileName: folderId }
var currentRawFolderId = null;      // í˜„ì¬ ë³´ê³  ìˆëŠ” í´ë” (null = ë£¨íŠ¸)

// ===== íŒŒì¼ ë³´ê´€í•¨ ì„±ëŠ¥ ìµœì í™” =====
let fileRenderTimeout = null; // ë Œë”ë§ ë””ë°”ìš´ìŠ¤
let fileRenderCache = { hash: '', html: '' }; // ë Œë”ë§ ìºì‹œ
let lastFileRenderTime = 0; // ë§ˆì§€ë§‰ ë Œë”ë§ ì‹œê°„
const FILE_RENDER_DEBOUNCE = 50; // ë Œë”ë§ ë””ë°”ìš´ìŠ¤ ì‹œê°„ (ms)
const FILE_RENDER_MIN_INTERVAL = 100; // ìµœì†Œ ë Œë”ë§ ê°„ê²© (ms)
const FILE_VIRTUAL_SCROLL_THRESHOLD = 100; // ê°€ìƒ ìŠ¤í¬ë¡¤ ì ìš© ì„ê³„ê°’

// ìºì‹œ í•´ì‹œ ìƒì„± (ë¹ ë¥¸ ë¹„êµìš©)
function getFileRenderHash() {
    return `${fileStorage.length}-${currentFileFolderId}-${fileFavoriteFilter}-${fileViewMode}-${Object.keys(fileFolders).length}-${selectedFiles.size}-${multiSelectedFiles.size}-${favoriteFiles.size}`;
}

// ë””ë°”ìš´ìŠ¤ëœ ë Œë”ë§
function renderFileStoragePanelDebounced() {
    if (fileRenderTimeout) {
        clearTimeout(fileRenderTimeout);
    }
    fileRenderTimeout = setTimeout(() => {
        renderFileStoragePanelCore();
    }, FILE_RENDER_DEBOUNCE);
}

// ì¦‰ì‹œ ë Œë”ë§ (ì¤‘ìš”í•œ ë³€ê²½ ì‹œ)
function renderFileStoragePanelImmediate() {
    if (fileRenderTimeout) {
        clearTimeout(fileRenderTimeout);
        fileRenderTimeout = null;
    }
    renderFileStoragePanelCore();
}

// ë©”ì¸ ë Œë”ë§ í•¨ìˆ˜ (ì™¸ë¶€ í˜¸ì¶œìš©) - ìŠ¤ë¡œí‹€ë§ ì ìš©
function renderFileStoragePanel() {
    const now = Date.now();
    
    // ìµœì†Œ ê°„ê²© ì²´í¬
    if (now - lastFileRenderTime < FILE_RENDER_MIN_INTERVAL) {
        renderFileStoragePanelDebounced();
        return;
    }
    
    lastFileRenderTime = now;
    renderFileStoragePanelCore();
}

// í•µì‹¬ ë Œë”ë§ ë¡œì§
function renderFileStoragePanelCore() {
    const container = document.getElementById('fileStorageContainer');
    if (!container) {
        return;
    }
    
    // ìºì‹œ ì²´í¬ (ë™ì¼í•œ ìƒíƒœë©´ ë Œë”ë§ ìŠ¤í‚µ)
    const currentHash = getFileRenderHash();
    if (fileRenderCache.hash === currentHash && fileRenderCache.html) {
        return; // ë³€ê²½ ì—†ìŒ - ìŠ¤í‚µ
    }
    
    const startTime = performance.now();
    let html = '';
    
    // ===== í—¤ë” ì˜ì—­ (ì‹œíŠ¸ ëª©ë¡ê³¼ ë™ì¼) =====
    html += `
        <div class="file-list-header">
            <div class="file-list-title">
                <span id="fileCountBadge" class="count-badge">${fileStorage.length}ê°œ</span>
                <label class="favorite-filter">
                    <input type="checkbox" id="fileFavoriteFilter" onchange="toggleFileFavoriteFilter()" ${fileFavoriteFilter ? 'checked' : ''}> ì¦ê²¨ì°¾ê¸°ë§Œ
                </label>
                <div class="view-mode-toggle">
                    <button class="view-mode-btn ${fileViewMode === 'card' ? 'active' : ''}" onclick="setFileViewMode('card')" title="ì¹´ë“œ ë³´ê¸°">â–¦</button>
                    <button class="view-mode-btn ${fileViewMode === 'list' ? 'active' : ''}" onclick="setFileViewMode('list')" title="ë¦¬ìŠ¤íŠ¸ ë³´ê¸°">â˜°</button>
                    <button class="view-mode-btn ${fileViewMode === 'icon' ? 'active' : ''}" onclick="setFileViewMode('icon')" title="ì•„ì´ì½˜ ë³´ê¸°">â€¢â€¢â€¢</button>
                </div>
            </div>
            <div class="file-list-actions">
                <div class="action-group">
                    <div class="download-dropdown-wrapper" id="fileDownloadWrapper">
                        <button class="action-btn download-dropdown-btn" onclick="toggleFileDownloadDropdown()">
                            ë‹¤ìš´ë¡œë“œ â–¼
                        </button>
                        <div class="download-dropdown-menu" id="fileDownloadDropdownMenu">
                            <div class="download-dropdown-item" onclick="showFileMultiSelectDownloadModal()">
                                <span class="download-icon">â˜‘ï¸</span>
                                <div class="download-item-content">
                                    <div class="download-item-title">íŒŒì¼ ì„ íƒ ë‹¤ìš´ë¡œë“œ</div>
                                    <div class="download-item-desc">ì›í•˜ëŠ” íŒŒì¼ ì„ íƒ</div>
                                </div>
                            </div>
                            <div class="download-dropdown-item" onclick="downloadAllFilesAsZip()">
                                <span class="download-icon">ğŸ“¦</span>
                                <div class="download-item-content">
                                    <div class="download-item-title">ì „ì²´ ë‹¤ìš´ë¡œë“œ (ZIP)</div>
                                    <div class="download-item-desc">ëª¨ë“  íŒŒì¼ ì••ì¶•</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="action-group">
                    <button class="action-btn" onclick="toggleFileFavoriteMode()" id="fileFavoriteModeBtn">ì¦ê²¨ì°¾ê¸°</button>
                </div>
                <div class="action-group">
                    <button class="action-btn" onclick="resetFileFilters()" style="background:var(--retro-mustard);color:white;">í•„í„° ì´ˆê¸°í™”</button>
                </div>
            </div>
        </div>
    `;
    
    // ===== í´ë” ë„¤ë¹„ê²Œì´ì…˜ ë°” =====
    html += `
        <div class="folder-nav-bar">
            <div class="folder-breadcrumb">
    `;
    
    if (currentFileFolderId !== null) {
        const folder = fileFolders[currentFileFolderId];
        html += `
            <span class="folder-breadcrumb-item" onclick="navigateFileFolder(null)"
                  ondragover="handleFileFolderDragOver(event)"
                  ondragleave="handleFileFolderDragLeave(event)"
                  ondrop="handleFileDropToRoot(event)">ğŸ“ ì „ì²´</span>
            <span class="folder-breadcrumb-sep">â€º</span>
            <span class="folder-breadcrumb-item current">${escHtml(folder?.name || 'í´ë”')}</span>
        `;
    } else {
        html += `<span class="folder-breadcrumb-item current">ğŸ“ ì „ì²´</span>`;
    }
    
    html += `
            </div>
            <div class="folder-nav-actions">
                <button class="folder-nav-btn" onclick="createNewFileFolder()">ğŸ“ ìƒˆ í´ë”</button>
            </div>
        </div>
    `;
    
    // ===== í´ë” ì¹´ë“œ ë Œë”ë§ =====
    const childFolders = Object.entries(fileFolders).filter(([id, f]) => {
        if (currentFileFolderId === null) return !f.parentId;
        return f.parentId === currentFileFolderId;
    });
    
    // í˜„ì¬ í´ë”ì˜ íŒŒì¼ í•„í„°ë§
    let filesToShow = fileStorage.filter(file => {
        const fileFolderId = fileToFolder[file.id];
        if (currentFileFolderId === null) {
            return !fileFolderId;
        }
        return fileFolderId === currentFileFolderId;
    });
    
    // ì¦ê²¨ì°¾ê¸° í•„í„°
    if (fileFavoriteFilter) {
        filesToShow = filesToShow.filter(file => favoriteFiles.has(file.id));
    }
    
    // ëŒ€ìš©ëŸ‰ íŒŒì¼ ë°°ì¹˜ ë Œë”ë§ ì„¤ì •
    const INITIAL_RENDER_COUNT = 50; // ì´ˆê¸° ë Œë”ë§ ê°œìˆ˜
    const totalFiles = filesToShow.length;
    const hasMoreFiles = totalFiles > INITIAL_RENDER_COUNT;
    const filesToRender = hasMoreFiles ? filesToShow.slice(0, INITIAL_RENDER_COUNT) : filesToShow;
    
    // ë¹ˆ ìƒíƒœ ì²´í¬
    if (filesToShow.length === 0 && childFolders.length === 0) {
        html += `
            <div class="file-storage-empty">
                <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“</div>
                <div>${currentFileFolderId ? 'ì´ í´ë”ì— íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤' : (fileFavoriteFilter ? 'ì¦ê²¨ì°¾ê¸°í•œ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤' : 'ë³´ê´€ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤')}</div>
                <div style="font-size: 12px; margin-top: 8px;">PDF, PPT, DOCX, TXT, HTML íŒŒì¼ì„ ì—…ë¡œë“œí•´ë³´ì„¸ìš”</div>
            </div>
        `;
        container.innerHTML = html;
        return;
    }
    
    // ===== ì¹´ë“œ ë·° =====
    if (fileViewMode === VIEW_MODE.CARD) {
        html += `<div class="file-card-grid ${fileDownloadMode ? 'download-mode' : ''}">`;
        
        // í´ë” ë¨¼ì €
        for (const [folderId, folder] of childFolders) {
            const fileCount = Object.values(fileToFolder).filter(fid => fid === folderId).length;
            const safeFolderId = folderId.replace(/'/g, "\\'");
            html += `
                <div class="folder-card" data-folder="${escHtml(folderId)}"
                     ondblclick="navigateFileFolder('${safeFolderId}')"
                     ondragover="handleFileFolderDragOver(event)"
                     ondragleave="handleFileFolderDragLeave(event)"
                     ondrop="handleFileDropToFolder(event, '${safeFolderId}')"
                     oncontextmenu="showFileFolderContextMenu(event, '${safeFolderId}')">
                    <div class="folder-card-icon">ğŸ“</div>
                    <div class="folder-card-name">${escHtml(folder.name)}</div>
                    <div class="folder-card-count">${fileCount}ê°œ</div>
                </div>
            `;
        }
        
        // íŒŒì¼ ì¹´ë“œ
        filesToRender.forEach((file, idx) => {
            const realIdx = fileStorage.indexOf(file);
            const icon = getFileIcon(file.type);
            const date = file.uploadedAt ? new Date(file.uploadedAt.seconds ? file.uploadedAt.seconds * 1000 : file.uploadedAt).toLocaleDateString('ko-KR') : '';
            const isFavorite = favoriteFiles.has(file.id);
            const isSelected = selectedFiles.has(file.id) || multiSelectedFiles.has(file.id);
            const safeFileId = (file.id || '').replace(/'/g, "\\'");
            
            html += `
                <div class="file-card ${isSelected ? 'selected' : ''}" 
                     data-file-id="${escHtml(file.id)}"
                     data-idx="${realIdx}"
                     onclick="handleFileCardClick('${safeFileId}', ${realIdx}, event)"
                     ondblclick="viewFile(${realIdx})"
                     draggable="true"
                     ondragstart="handleFileDragStart(event, '${safeFileId}')"
                     ondragend="handleFileDragEnd(event)"
                     oncontextmenu="showFileItemContextMenu(event, '${safeFileId}', ${realIdx})">
                    <input type="checkbox" class="file-card-checkbox" data-file-id="${escHtml(file.id)}" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleFileDownloadSelect('${safeFileId}')">
                    <span class="file-card-favorite ${isFavorite ? 'active' : ''}" onclick="event.stopPropagation(); toggleFileFavorite('${safeFileId}')">â­</span>
                    <div class="file-card-icon">${icon}</div>
                    <div class="file-card-name" title="${escHtml(file.name)}">${escHtml(file.name)}</div>
                    <div class="file-card-meta">${formatFileSize(file.size)}</div>
                </div>
            `;
        });
        
        html += '</div>';
        
        // ë” ë³´ê¸° ë²„íŠ¼ (ëŒ€ìš©ëŸ‰ì¼ ê²½ìš°)
        if (hasMoreFiles) {
            html += `
                <div class="load-more-files" style="text-align:center;padding:20px;">
                    <button onclick="loadMoreFiles()" style="padding:10px 30px;background:var(--retro-teal);color:white;border:none;border-radius:6px;cursor:pointer;font-size:14px;">
                        ${totalFiles - INITIAL_RENDER_COUNT}ê°œ ë” ë³´ê¸°
                    </button>
                    <div style="font-size:12px;color:var(--retro-warm-gray);margin-top:8px;">
                        ${INITIAL_RENDER_COUNT}/${totalFiles}ê°œ í‘œì‹œ ì¤‘
                    </div>
                </div>
            `;
        }
    }
    // ===== ì•„ì´ì½˜ ë·° =====
    else if (fileViewMode === VIEW_MODE.ICON) {
        html += `<div class="file-card-grid icon-view ${fileDownloadMode ? 'download-mode' : ''} ${freePositionMode ? 'free-position' : ''}">`;
        
        // í´ë” ë¨¼ì €
        let autoIndex = 0; // ìë™ ë°°ì¹˜ ì¸ë±ìŠ¤
        const iconWidth = 90; // ì•„ì´ì½˜ ë„ˆë¹„ + ê°„ê²©
        const iconHeight = 95; // ì•„ì´ì½˜ ë†’ì´ + ê°„ê²©
        const cols = 8; // í•œ ì¤„ì— ë°°ì¹˜í•  ê°œìˆ˜
        
        for (const [folderId, folder] of childFolders) {
            const safeFolderId = folderId.replace(/'/g, "\\'");
            const folderPos = fileFolderIconPositions[folderId] || {};
            let folderStyle = '';
            if (freePositionMode) {
                if (folderPos.x !== undefined) {
                    folderStyle = `style="left:${folderPos.x}px;top:${folderPos.y}px;"`;
                } else {
                    // ìë™ ë°°ì¹˜
                    const autoX = (autoIndex % cols) * iconWidth + 10;
                    const autoY = Math.floor(autoIndex / cols) * iconHeight + 10;
                    folderStyle = `style="left:${autoX}px;top:${autoY}px;"`;
                }
            }
            autoIndex++;
            html += `
                <div class="folder-card" data-folder="${escHtml(folderId)}" ${folderStyle}
                     ondblclick="navigateFileFolder('${safeFolderId}')"
                     onmousedown="startPositionDrag(event, 'fileFolder', '${safeFolderId}')"
                     ondragover="handleFileFolderDragOver(event)"
                     ondragleave="handleFileFolderDragLeave(event)"
                     ondrop="handleFileDropToFolder(event, '${safeFolderId}')"
                     oncontextmenu="showFileFolderContextMenu(event, '${safeFolderId}')">
                    <div class="folder-card-icon">ğŸ“</div>
                    <div class="folder-card-name">${escHtml(folder.name)}</div>
                </div>
            `;
        }
        
        // íŒŒì¼ ì•„ì´ì½˜
        filesToRender.forEach((file, idx) => {
            const realIdx = fileStorage.indexOf(file);
            const icon = getFileIcon(file.type);
            const isFavorite = favoriteFiles.has(file.id);
            const safeFileId = (file.id || '').replace(/'/g, "\\'");
            const filePos = fileIconPositions[file.id] || {};
            let fileStyle = '';
            if (freePositionMode) {
                if (filePos.x !== undefined) {
                    fileStyle = `style="left:${filePos.x}px;top:${filePos.y}px;"`;
                } else {
                    // ìë™ ë°°ì¹˜
                    const autoX = (autoIndex % cols) * iconWidth + 10;
                    const autoY = Math.floor(autoIndex / cols) * iconHeight + 10;
                    fileStyle = `style="left:${autoX}px;top:${autoY}px;"`;
                }
            }
            autoIndex++;
            
            html += `
                <div class="file-card ${isFavorite ? 'favorite' : ''}" 
                     data-file-id="${escHtml(file.id)}"
                     data-idx="${realIdx}" ${fileStyle}
                     draggable="true"
                     onmousedown="startPositionDrag(event, 'file', '${safeFileId}')"
                     onclick="handleFileCardClick('${safeFileId}', ${realIdx}, event)"
                     ondblclick="viewFile(${realIdx})"
                     ondragstart="handleFileDragStart(event, '${safeFileId}')"
                     ondragend="handleFileDragEnd(event)"
                     oncontextmenu="showFileItemContextMenu(event, '${safeFileId}', ${realIdx})">
                    <div class="file-card-icon">${icon}</div>
                    <div class="file-card-name" title="${escHtml(file.name)}">${escHtml(file.name)}</div>
                </div>
            `;
        });
        
        html += '</div>';
        
        // ë” ë³´ê¸° ë²„íŠ¼ (ëŒ€ìš©ëŸ‰ì¼ ê²½ìš°)
        if (hasMoreFiles) {
            html += `
                <div class="load-more-files" style="text-align:center;padding:20px;">
                    <button onclick="loadMoreFiles()" style="padding:10px 30px;background:var(--retro-teal);color:white;border:none;border-radius:6px;cursor:pointer;font-size:14px;">
                        ${totalFiles - INITIAL_RENDER_COUNT}ê°œ ë” ë³´ê¸°
                    </button>
                    <div style="font-size:12px;color:var(--retro-warm-gray);margin-top:8px;">
                        ${INITIAL_RENDER_COUNT}/${totalFiles}ê°œ í‘œì‹œ ì¤‘
                    </div>
                </div>
            `;
        }
    }
    // ===== ë¦¬ìŠ¤íŠ¸ ë·° =====
    else {
        html += `<div class="file-list-view ${fileDownloadMode ? 'download-mode' : ''}">`;
        
        // í´ë” ë¨¼ì €
        for (const [folderId, folder] of childFolders) {
            const fileCount = Object.values(fileToFolder).filter(fid => fid === folderId).length;
            const safeFolderId = folderId.replace(/'/g, "\\'");
            html += `
                <div class="file-storage-item folder-item" data-folder="${escHtml(folderId)}"
                     ondblclick="navigateFileFolder('${safeFolderId}')"
                     ondragover="handleFileFolderDragOver(event)"
                     ondragleave="handleFileFolderDragLeave(event)"
                     ondrop="handleFileDropToFolder(event, '${safeFolderId}')"
                     oncontextmenu="showFileFolderContextMenu(event, '${safeFolderId}')">
                    <span class="file-icon">ğŸ“</span>
                    <div class="file-info">
                        <div class="file-name">${escHtml(folder.name)}</div>
                        <div class="file-meta">${fileCount}ê°œ íŒŒì¼</div>
                    </div>
                </div>
            `;
        }
        
        // íŒŒì¼ ë¦¬ìŠ¤íŠ¸
        filesToRender.forEach((file, idx) => {
            const realIdx = fileStorage.indexOf(file);
            const icon = getFileIcon(file.type);
            const date = file.uploadedAt ? new Date(file.uploadedAt.seconds ? file.uploadedAt.seconds * 1000 : file.uploadedAt).toLocaleDateString('ko-KR') : '';
            const isFavorite = favoriteFiles.has(file.id);
            const isSelected = selectedFiles.has(file.id) || multiSelectedFiles.has(file.id);
            const safeFileId = (file.id || '').replace(/'/g, "\\'");
            
            html += `
                <div class="file-storage-item ${isSelected ? 'selected' : ''}" 
                     data-idx="${realIdx}" 
                     data-file-id="${escHtml(file.id)}"
                     draggable="true"
                     onclick="handleFileCardClick('${safeFileId}', ${realIdx}, event)"
                     ondblclick="viewFile(${realIdx})"
                     ondragstart="handleFileDragStart(event, '${safeFileId}')"
                     ondragend="handleFileDragEnd(event)"
                     oncontextmenu="showFileItemContextMenu(event, '${safeFileId}', ${realIdx})">
                    <input type="checkbox" class="file-checkbox" data-file-id="${escHtml(file.id)}" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleFileDownloadSelect('${safeFileId}')">
                    <span class="file-card-favorite ${isFavorite ? 'active' : ''}" onclick="event.stopPropagation(); toggleFileFavorite('${safeFileId}')" style="margin-right:5px;">â­</span>
                    <span class="file-icon ${file.type}">${icon}</span>
                    <div class="file-info">
                        <div class="file-name" ondblclick="event.stopPropagation(); startRenameFile(event, ${realIdx})">${escHtml(file.name)}</div>
                        <div class="file-meta">${formatFileSize(file.size)} â€¢ ${date}</div>
                    </div>
                    <div class="file-actions">
                        <button class="file-action-btn" onclick="event.stopPropagation(); viewFile(${realIdx})" title="ë³´ê¸°">ë³´ê¸°</button>
                        <button class="file-action-btn" onclick="event.stopPropagation(); downloadStoredFile(${realIdx})" title="ì €ì¥">ì €ì¥</button>
                        <button class="file-action-btn danger" onclick="event.stopPropagation(); deleteStoredFile(${realIdx})" title="ì‚­ì œ">ì‚­ì œ</button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        
        // ë” ë³´ê¸° ë²„íŠ¼ (ëŒ€ìš©ëŸ‰ì¼ ê²½ìš°)
        if (hasMoreFiles) {
            html += `
                <div class="load-more-files" style="text-align:center;padding:20px;">
                    <button onclick="loadMoreFiles()" style="padding:10px 30px;background:var(--retro-teal);color:white;border:none;border-radius:6px;cursor:pointer;font-size:14px;">
                        ${totalFiles - INITIAL_RENDER_COUNT}ê°œ ë” ë³´ê¸°
                    </button>
                    <div style="font-size:12px;color:var(--retro-warm-gray);margin-top:8px;">
                        ${INITIAL_RENDER_COUNT}/${totalFiles}ê°œ í‘œì‹œ ì¤‘
                    </div>
                </div>
            `;
        }
    }
    
    // DOM ì—…ë°ì´íŠ¸ (requestAnimationFrameìœ¼ë¡œ ìµœì í™”)
    requestAnimationFrame(() => {
        container.innerHTML = html;
        
        // ìºì‹œ ì—…ë°ì´íŠ¸
        fileRenderCache.hash = currentHash;
        fileRenderCache.html = html;
        
        // íŒŒì¼ ê°œìˆ˜ ë°°ì§€ ì—…ë°ì´íŠ¸
        updateFileCountBadge();
        
        // ì„±ëŠ¥ ë¡œê¹… (ë””ë²„ê·¸ìš©)
        const elapsed = performance.now() - startTime;
        if (elapsed > 50) {
            console.log(`íŒŒì¼ ë³´ê´€í•¨ ë Œë”ë§: ${elapsed.toFixed(1)}ms, íŒŒì¼ ${filesToRender.length}/${totalFiles}ê°œ`);
        }
    });
}

// ìºì‹œ ë¬´íš¨í™” (ë°ì´í„° ë³€ê²½ ì‹œ í˜¸ì¶œ)
function invalidateFileRenderCache() {
    fileRenderCache.hash = '';
    fileRenderCache.html = '';
}

// ë” ë³´ê¸° ë²„íŠ¼ í´ë¦­ ì‹œ ì „ì²´ íŒŒì¼ ë¡œë“œ
let fileRenderShowAll = false;
function loadMoreFiles() {
    fileRenderShowAll = true;
    invalidateFileRenderCache();
    renderFileStoragePanelFull();
}

// ì „ì²´ íŒŒì¼ ë Œë”ë§ (ë” ë³´ê¸° í´ë¦­ ì‹œ)
function renderFileStoragePanelFull() {
    const container = document.getElementById('fileStorageContainer');
    if (!container) return;
    
    const startTime = performance.now();
    
    // í˜„ì¬ í´ë”ì˜ íŒŒì¼ í•„í„°ë§
    let filesToShow = fileStorage.filter(file => {
        const fileFolderId = fileToFolder[file.id];
        if (currentFileFolderId === null) {
            return !fileFolderId;
        }
        return fileFolderId === currentFileFolderId;
    });
    
    if (fileFavoriteFilter) {
        filesToShow = filesToShow.filter(file => favoriteFiles.has(file.id));
    }
    
    const childFolders = Object.entries(fileFolders).filter(([id, f]) => {
        if (currentFileFolderId === null) return !f.parentId;
        return f.parentId === currentFileFolderId;
    });
    
    let html = '';
    
    // í—¤ë” (ê¸°ì¡´ê³¼ ë™ì¼)
    html += `
        <div class="file-list-header">
            <div class="file-list-title">
                <span id="fileCountBadge" class="count-badge">${fileStorage.length}ê°œ</span>
                <label class="favorite-filter">
                    <input type="checkbox" id="fileFavoriteFilter" onchange="toggleFileFavoriteFilter()" ${fileFavoriteFilter ? 'checked' : ''}> ì¦ê²¨ì°¾ê¸°ë§Œ
                </label>
                <div class="view-mode-toggle">
                    <button class="view-mode-btn ${fileViewMode === 'card' ? 'active' : ''}" onclick="setFileViewMode('card')" title="ì¹´ë“œ ë³´ê¸°">â–¦</button>
                    <button class="view-mode-btn ${fileViewMode === 'list' ? 'active' : ''}" onclick="setFileViewMode('list')" title="ë¦¬ìŠ¤íŠ¸ ë³´ê¸°">â˜°</button>
                    <button class="view-mode-btn ${fileViewMode === 'icon' ? 'active' : ''}" onclick="setFileViewMode('icon')" title="ì•„ì´ì½˜ ë³´ê¸°">â€¢â€¢â€¢</button>
                </div>
            </div>
            <div class="file-list-actions">
                <div class="action-group">
                    <div class="download-dropdown-wrapper" id="fileDownloadWrapper">
                        <button class="action-btn download-dropdown-btn" onclick="toggleFileDownloadDropdown()">
                            ë‹¤ìš´ë¡œë“œ â–¼
                        </button>
                        <div class="download-dropdown-menu" id="fileDownloadDropdownMenu">
                            <div class="download-dropdown-item" onclick="showFileMultiSelectDownloadModal()">
                                <span class="download-icon">â˜‘ï¸</span>
                                <div class="download-item-content">
                                    <div class="download-item-title">íŒŒì¼ ì„ íƒ ë‹¤ìš´ë¡œë“œ</div>
                                    <div class="download-item-desc">ì›í•˜ëŠ” íŒŒì¼ ì„ íƒ</div>
                                </div>
                            </div>
                            <div class="download-dropdown-item" onclick="downloadAllFilesAsZip()">
                                <span class="download-icon">ğŸ“¦</span>
                                <div class="download-item-content">
                                    <div class="download-item-title">ì „ì²´ ë‹¤ìš´ë¡œë“œ (ZIP)</div>
                                    <div class="download-item-desc">ëª¨ë“  íŒŒì¼ ì••ì¶•</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="action-group">
                    <button class="action-btn" onclick="toggleFileFavoriteMode()" id="fileFavoriteModeBtn">ì¦ê²¨ì°¾ê¸°</button>
                </div>
                <div class="action-group">
                    <button class="action-btn" onclick="resetFileFilters()" style="background:var(--retro-mustard);color:white;">í•„í„° ì´ˆê¸°í™”</button>
                </div>
            </div>
        </div>
    `;
    
    // í´ë” ë„¤ë¹„ê²Œì´ì…˜ ë°”
    html += `
        <div class="folder-nav-bar">
            <div class="folder-breadcrumb">
    `;
    
    if (currentFileFolderId !== null) {
        const folder = fileFolders[currentFileFolderId];
        html += `
            <span class="folder-breadcrumb-item" onclick="navigateFileFolder(null)"
                  ondragover="handleFileFolderDragOver(event)"
                  ondragleave="handleFileFolderDragLeave(event)"
                  ondrop="handleFileDropToRoot(event)">ğŸ“ ì „ì²´</span>
            <span class="folder-breadcrumb-sep">â€º</span>
            <span class="folder-breadcrumb-item current">${escHtml(folder?.name || 'í´ë”')}</span>
        `;
    } else {
        html += `<span class="folder-breadcrumb-item current">ğŸ“ ì „ì²´</span>`;
    }
    
    html += `
            </div>
            <div class="folder-nav-actions">
                <button class="folder-nav-btn" onclick="createNewFileFolder()">ğŸ“ ìƒˆ í´ë”</button>
            </div>
        </div>
    `;
    
    // ë¦¬ìŠ¤íŠ¸ ë·°ë¡œ ì „ì²´ ë Œë”ë§
    html += `<div class="file-list-view ${fileDownloadMode ? 'download-mode' : ''}">`;
    
    // í´ë”
    for (const [folderId, folder] of childFolders) {
        const fileCount = Object.values(fileToFolder).filter(fid => fid === folderId).length;
        const safeFolderId = folderId.replace(/'/g, "\\'");
        html += `
            <div class="file-storage-item folder-item" data-folder="${escHtml(folderId)}"
                 ondblclick="navigateFileFolder('${safeFolderId}')"
                 ondragover="handleFileFolderDragOver(event)"
                 ondragleave="handleFileFolderDragLeave(event)"
                 ondrop="handleFileDropToFolder(event, '${safeFolderId}')"
                 oncontextmenu="showFileFolderContextMenu(event, '${safeFolderId}')">
                <span class="file-icon">ğŸ“</span>
                <div class="file-info">
                    <div class="file-name">${escHtml(folder.name)}</div>
                    <div class="file-meta">${fileCount}ê°œ íŒŒì¼</div>
                </div>
            </div>
        `;
    }
    
    // ì „ì²´ íŒŒì¼
    filesToShow.forEach((file, idx) => {
        const realIdx = fileStorage.indexOf(file);
        const icon = getFileIcon(file.type);
        const date = file.uploadedAt ? new Date(file.uploadedAt.seconds ? file.uploadedAt.seconds * 1000 : file.uploadedAt).toLocaleDateString('ko-KR') : '';
        const isFavorite = favoriteFiles.has(file.id);
        const isSelected = selectedFiles.has(file.id) || multiSelectedFiles.has(file.id);
        const safeFileId = (file.id || '').replace(/'/g, "\\'");
        
        html += `
            <div class="file-storage-item ${isSelected ? 'selected' : ''}" 
                 data-idx="${realIdx}" 
                 data-file-id="${escHtml(file.id)}"
                 draggable="true"
                 onclick="handleFileCardClick('${safeFileId}', ${realIdx}, event)"
                 ondblclick="viewFile(${realIdx})"
                 ondragstart="handleFileDragStart(event, '${safeFileId}')"
                 ondragend="handleFileDragEnd(event)"
                 oncontextmenu="showFileItemContextMenu(event, '${safeFileId}', ${realIdx})">
                <input type="checkbox" class="file-checkbox" data-file-id="${escHtml(file.id)}" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleFileDownloadSelect('${safeFileId}')">
                <span class="file-card-favorite ${isFavorite ? 'active' : ''}" onclick="event.stopPropagation(); toggleFileFavorite('${safeFileId}')" style="margin-right:5px;">â­</span>
                <span class="file-icon ${file.type}">${icon}</span>
                <div class="file-info">
                    <div class="file-name" ondblclick="event.stopPropagation(); startRenameFile(event, ${realIdx})">${escHtml(file.name)}</div>
                    <div class="file-meta">${formatFileSize(file.size)} â€¢ ${date}</div>
                </div>
                <div class="file-actions">
                    <button class="file-action-btn" onclick="event.stopPropagation(); viewFile(${realIdx})" title="ë³´ê¸°">ë³´ê¸°</button>
                    <button class="file-action-btn" onclick="event.stopPropagation(); downloadStoredFile(${realIdx})" title="ì €ì¥">ì €ì¥</button>
                    <button class="file-action-btn danger" onclick="event.stopPropagation(); deleteStoredFile(${realIdx})" title="ì‚­ì œ">ì‚­ì œ</button>
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    
    requestAnimationFrame(() => {
        container.innerHTML = html;
        updateFileCountBadge();
        const elapsed = performance.now() - startTime;
        console.log(`íŒŒì¼ ë³´ê´€í•¨ ì „ì²´ ë Œë”ë§: ${elapsed.toFixed(1)}ms, íŒŒì¼ ${filesToShow.length}ê°œ`);
    });
    
    fileRenderShowAll = false; // í”Œë˜ê·¸ ë¦¬ì…‹
}

// íŒŒì¼ ê°œìˆ˜ ë°°ì§€ ì—…ë°ì´íŠ¸
function updateFileCountBadge() {
    const badge = document.getElementById('fileCountBadge');
    if (badge) {
        badge.textContent = fileStorage.length + 'ê°œ';
    }
}

// íŒŒì¼ ë·° ëª¨ë“œ ì„¤ì •
function setFileViewMode(mode) {
    fileViewMode = mode;
    invalidateFileRenderCache();
    renderFileStoragePanel();
}

// íŒŒì¼ ì¦ê²¨ì°¾ê¸° í•„í„° í† ê¸€
function toggleFileFavoriteFilter() {
    fileFavoriteFilter = document.getElementById('fileFavoriteFilter')?.checked || false;
    invalidateFileRenderCache();
    renderFileStoragePanel();
}

// íŒŒì¼ ì¦ê²¨ì°¾ê¸° í† ê¸€ (ë¶€ë¶„ ì—…ë°ì´íŠ¸ ìµœì í™”)
function toggleFileFavorite(fileId) {
    if (favoriteFiles.has(fileId)) {
        favoriteFiles.delete(fileId);
    } else {
        favoriteFiles.add(fileId);
    }
    
    // ì¦ê²¨ì°¾ê¸° í•„í„°ê°€ ì¼œì ¸ìˆìœ¼ë©´ ì „ì²´ ë Œë”ë§ í•„ìš”
    if (fileFavoriteFilter) {
        invalidateFileRenderCache();
        renderFileStoragePanel();
    } else {
        // ë¶€ë¶„ ì—…ë°ì´íŠ¸ (í•´ë‹¹ ìš”ì†Œë§Œ í† ê¸€)
        const fileCard = document.querySelector(`[data-file-id="${CSS.escape(fileId)}"]`);
        if (fileCard) {
            const star = fileCard.querySelector('.file-card-favorite');
            const isFavorite = favoriteFiles.has(fileId);
            fileCard.classList.toggle('favorite', isFavorite);
            if (star) star.classList.toggle('active', isFavorite);
        }
    }
    saveFavoriteFilesToStorage();
}

// íŒŒì¼ ì¦ê²¨ì°¾ê¸° ëª¨ë“œ í† ê¸€
function toggleFileFavoriteMode() {
    // ì¦ê²¨ì°¾ê¸° í•„í„° í† ê¸€
    fileFavoriteFilter = !fileFavoriteFilter;
    const checkbox = document.getElementById('fileFavoriteFilter');
    if (checkbox) checkbox.checked = fileFavoriteFilter;
    
    const btn = document.getElementById('fileFavoriteModeBtn');
    if (btn) {
        btn.classList.toggle('active', fileFavoriteFilter);
    }
    
    invalidateFileRenderCache();
    renderFileStoragePanel();
}

// íŒŒì¼ í•„í„° ì´ˆê¸°í™”
function resetFileFilters() {
    fileFavoriteFilter = false;
    const checkbox = document.getElementById('fileFavoriteFilter');
    if (checkbox) checkbox.checked = false;
    
    const btn = document.getElementById('fileFavoriteModeBtn');
    if (btn) btn.classList.remove('active');
    
    currentFileFolderId = null;
    invalidateFileRenderCache();
    renderFileStoragePanel();
    toast('í•„í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
}

// íŒŒì¼ ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬ (ë¶€ë¶„ ì—…ë°ì´íŠ¸ ìµœì í™”)
function handleFileCardClick(fileId, idx, event) {
    // Ctrl/Cmd í´ë¦­: ë‹¤ì¤‘ ì„ íƒ
    if (event && (event.ctrlKey || event.metaKey)) {
        if (multiSelectedFiles.has(fileId)) {
            multiSelectedFiles.delete(fileId);
        } else {
            multiSelectedFiles.add(fileId);
        }
        // ë¶€ë¶„ ì—…ë°ì´íŠ¸ (í•´ë‹¹ ìš”ì†Œë§Œ í† ê¸€)
        const fileCard = document.querySelector(`[data-file-id="${CSS.escape(fileId)}"]`);
        if (fileCard) {
            fileCard.classList.toggle('selected', multiSelectedFiles.has(fileId));
            const checkbox = fileCard.querySelector('.file-checkbox, .file-card-checkbox');
            if (checkbox) checkbox.checked = multiSelectedFiles.has(fileId);
        }
    }
    // ì¼ë°˜ í´ë¦­: ì•„ë¬´ ë™ì‘ ì—†ìŒ (ë”ë¸”í´ë¦­ìœ¼ë¡œ ë³´ê¸°)
}

// íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì„ íƒ í† ê¸€ (ë¶€ë¶„ ì—…ë°ì´íŠ¸ ìµœì í™”)
function toggleFileDownloadSelect(fileId) {
    if (selectedFiles.has(fileId)) {
        selectedFiles.delete(fileId);
    } else {
        selectedFiles.add(fileId);
    }
    // ë¶€ë¶„ ì—…ë°ì´íŠ¸ (í•´ë‹¹ ìš”ì†Œë§Œ í† ê¸€)
    const fileCard = document.querySelector(`[data-file-id="${CSS.escape(fileId)}"]`);
    if (fileCard) {
        fileCard.classList.toggle('selected', selectedFiles.has(fileId));
        const checkbox = fileCard.querySelector('.file-checkbox, .file-card-checkbox');
        if (checkbox) checkbox.checked = selectedFiles.has(fileId);
    }
}

// íŒŒì¼ ë‹¤ìš´ë¡œë“œ ë“œë¡­ë‹¤ìš´ í† ê¸€
function toggleFileDownloadDropdown() {
    const menu = document.getElementById('fileDownloadDropdownMenu');
    if (menu.classList.contains('show')) {
        menu.classList.remove('show');
    } else {
        document.querySelectorAll('.download-dropdown-menu.show').forEach(m => m.classList.remove('show'));
        menu.classList.add('show');
    }
}

// íŒŒì¼ ë‹¤ìš´ë¡œë“œ ë“œë¡­ë‹¤ìš´ ì™¸ë¶€ í´ë¦­ ë‹«ê¸°
document.addEventListener('click', (e) => {
    if (!e.target.closest('#fileDownloadWrapper')) {
        document.getElementById('fileDownloadDropdownMenu')?.classList.remove('show');
    }
});

// íŒŒì¼ ë‹¤ì¤‘ ì„ íƒ ë‹¤ìš´ë¡œë“œ ëª¨ë‹¬
function showFileMultiSelectDownloadModal() {
    document.getElementById('fileDownloadDropdownMenu')?.classList.remove('show');
    
    if (fileStorage.length === 0) {
        toast('ë‹¤ìš´ë¡œë“œí•  íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    selectedFiles.clear();
    
    let filesHtml = '';
    fileStorage.forEach((file, idx) => {
        const safeFileId = (file.id || '').replace(/"/g, '&quot;');
        filesHtml += `
            <div class="multi-download-item" data-type="file" data-file-id="${safeFileId}" data-idx="${idx}" onclick="toggleMultiFileDownloadItem(this)">
                <input type="checkbox" onclick="event.stopPropagation()">
                <span class="multi-download-item-icon">${getFileIcon(file.type)}</span>
                <span class="multi-download-item-name">${escHtml(file.name)}</span>
                <span class="multi-download-item-count">${formatFileSize(file.size)}</span>
            </div>
        `;
    });
    
    const modalHtml = `
        <div class="multi-download-modal" id="fileMultiDownloadModal" onclick="if(event.target===this) closeFileMultiDownloadModal()">
            <div class="multi-download-content">
                <div class="multi-download-header">
                    <h3>ë‹¤ìš´ë¡œë“œí•  íŒŒì¼ ì„ íƒ</h3>
                    <button class="multi-download-close" onclick="closeFileMultiDownloadModal()">âœ•</button>
                </div>
                <div class="multi-download-body">
                    <div class="multi-download-section">
                        <div class="multi-download-select-all">
                            <input type="checkbox" id="selectAllFilesForDownload" onchange="toggleSelectAllFilesForDownload()">
                            <label for="selectAllFilesForDownload">ì „ì²´ ì„ íƒ</label>
                        </div>
                        <div class="multi-download-list">
                            ${filesHtml}
                        </div>
                    </div>
                </div>
                <div class="multi-download-footer">
                    <div class="multi-download-summary" id="fileDownloadSummary">ì„ íƒ: 0ê°œ</div>
                    <div class="multi-download-actions">
                        <button class="multi-download-btn cancel" onclick="closeFileMultiDownloadModal()">ì·¨ì†Œ</button>
                        <button class="multi-download-btn primary" id="executeFileDownloadBtn" onclick="executeFileMultiDownload()" disabled>ë‹¤ìš´ë¡œë“œ</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeFileMultiDownloadModal() {
    document.getElementById('fileMultiDownloadModal')?.remove();
}

function toggleMultiFileDownloadItem(el) {
    const checkbox = el.querySelector('input[type="checkbox"]');
    checkbox.checked = !checkbox.checked;
    el.classList.toggle('selected', checkbox.checked);
    
    const fileId = el.dataset.fileId;
    if (checkbox.checked) {
        selectedFiles.add(fileId);
    } else {
        selectedFiles.delete(fileId);
    }
    
    updateFileDownloadSummary();
}

function toggleSelectAllFilesForDownload() {
    const isChecked = document.getElementById('selectAllFilesForDownload').checked;
    
    document.querySelectorAll('#fileMultiDownloadModal .multi-download-item').forEach(el => {
        const checkbox = el.querySelector('input[type="checkbox"]');
        checkbox.checked = isChecked;
        el.classList.toggle('selected', isChecked);
        
        const fileId = el.dataset.fileId;
        if (isChecked) {
            selectedFiles.add(fileId);
        } else {
            selectedFiles.delete(fileId);
        }
    });
    
    updateFileDownloadSummary();
}

function updateFileDownloadSummary() {
    const count = selectedFiles.size;
    document.getElementById('fileDownloadSummary').textContent = `ì„ íƒ: ${count}ê°œ`;
    document.getElementById('executeFileDownloadBtn').disabled = count === 0;
}

async function executeFileMultiDownload() {
    if (selectedFiles.size === 0) {
        toast('ë‹¤ìš´ë¡œë“œí•  íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    
    closeFileMultiDownloadModal();
    
    if (selectedFiles.size === 1) {
        // 1ê°œë©´ ë°”ë¡œ ë‹¤ìš´ë¡œë“œ
        const fileId = Array.from(selectedFiles)[0];
        const idx = fileStorage.findIndex(f => f.id === fileId);
        if (idx >= 0) downloadStoredFile(idx);
        selectedFiles.clear();
        return;
    }
    
    // ì—¬ëŸ¬ ê°œë©´ ZIP
    try {
        const zip = new JSZip();
        const dateStr = new Date().toISOString().slice(0,10);
        
        for (const fileId of selectedFiles) {
            const file = fileStorage.find(f => f.id === fileId);
            if (!file || !file.data) continue;
            
            try {
                const binary = atob(file.data.split(',')[1] || file.data);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                zip.file(file.name, bytes);
            } catch (e) {
                console.error('íŒŒì¼ ì¶”ê°€ ì˜¤ë¥˜:', file.name, e);
            }
        }
        
        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `íŒŒì¼_${selectedFiles.size}ê°œ_${dateStr}.zip`;
        link.click();
        URL.revokeObjectURL(link.href);
        
        toast(`${selectedFiles.size}ê°œ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
        selectedFiles.clear();
    } catch (error) {
        console.error('ZIP ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
        toast('ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}

// ì „ì²´ íŒŒì¼ ZIP ë‹¤ìš´ë¡œë“œ
async function downloadAllFilesAsZip() {
    document.getElementById('fileDownloadDropdownMenu')?.classList.remove('show');
    
    if (fileStorage.length === 0) {
        toast('ë‹¤ìš´ë¡œë“œí•  íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    try {
        const zip = new JSZip();
        const dateStr = new Date().toISOString().slice(0,10);
        
        fileStorage.forEach(file => {
            if (!file || !file.data) return;
            try {
                const binary = atob(file.data.split(',')[1] || file.data);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                zip.file(file.name, bytes);
            } catch (e) {
                console.error('íŒŒì¼ ì¶”ê°€ ì˜¤ë¥˜:', file.name);
            }
        });
        
        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `ì „ì²´íŒŒì¼_${fileStorage.length}ê°œ_${dateStr}.zip`;
        link.click();
        URL.revokeObjectURL(link.href);
        
        toast(`ì „ì²´ ${fileStorage.length}ê°œ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
    } catch (error) {
        console.error('ZIP ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
        toast('ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}

// ì¦ê²¨ì°¾ê¸° íŒŒì¼ ì €ì¥/ë¡œë“œ
function saveFavoriteFilesToStorage() {
    try {
        localStorage.setItem('excelmaster_favorite_files', JSON.stringify(Array.from(favoriteFiles)));
    } catch (e) {}
}

function loadFavoriteFilesFromStorage() {
    try {
        const saved = localStorage.getItem('excelmaster_favorite_files');
        if (saved) {
            favoriteFiles = new Set(JSON.parse(saved));
        }
    } catch (e) {}
}

// íŒŒì¼ ì´ë¦„ ë³€ê²½ ì‹œì‘
function startRenameFile(e, idx) {
    e.stopPropagation();
    const fileData = fileStorage[idx];
    if (!fileData) return;
    
    const nameDiv = e.target.closest('.file-name') || e.target.closest('.file-storage-item').querySelector('.file-name');
    const currentName = fileData.name;
    
    // í™•ì¥ì ë¶„ë¦¬
    const lastDot = currentName.lastIndexOf('.');
    const baseName = lastDot > 0 ? currentName.substring(0, lastDot) : currentName;
    const extension = lastDot > 0 ? currentName.substring(lastDot) : '';
    
    // ì…ë ¥ í•„ë“œë¡œ êµì²´
    const input = document.createElement('input');
    input.type = 'text';
    input.value = baseName;
    input.className = 'file-rename-input';
    input.style.cssText = 'width:100%;padding:3px 6px;font-size:13px;border:2px solid var(--retro-teal);border-radius:3px;outline:none;';
    
    nameDiv.innerHTML = '';
    nameDiv.appendChild(input);
    
    // í™•ì¥ì í‘œì‹œ
    const extSpan = document.createElement('span');
    extSpan.textContent = extension;
    extSpan.style.cssText = 'font-size:12px;color:var(--retro-warm-gray);margin-left:2px;';
    nameDiv.appendChild(extSpan);
    
    input.focus();
    input.select();
    
    // ì—”í„° ë˜ëŠ” í¬ì»¤ìŠ¤ ì•„ì›ƒ ì‹œ ì €ì¥
    input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
            ev.preventDefault();
            finishRenameFile(input, idx, extension);
        } else if (ev.key === 'Escape') {
            ev.preventDefault();
            renderFileStoragePanel();
        }
    });
    
    input.addEventListener('blur', () => {
        setTimeout(() => {
            if (document.contains(input)) {
                finishRenameFile(input, idx, extension);
            }
        }, 100);
    });
}

// íŒŒì¼ ì´ë¦„ ë³€ê²½ ì™„ë£Œ
function finishRenameFile(input, idx, extension) {
    const newBaseName = input.value.trim();
    const fileData = fileStorage[idx];
    
    if (!newBaseName || !fileData) {
        renderFileStoragePanel();
        return;
    }
    
    const newName = newBaseName + extension;
    
    if (newName === fileData.name) {
        renderFileStoragePanel();
        return;
    }
    
    // ì¤‘ë³µ ê²€ì‚¬
    if (fileStorage.some((f, i) => i !== idx && f.name === newName)) {
        toast('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” íŒŒì¼ ì´ë¦„ì…ë‹ˆë‹¤');
        renderFileStoragePanel();
        return;
    }
    
    // ì´ë¦„ ë³€ê²½
    const oldName = fileData.name;
    fileData.name = newName;
    
    // Firestore ì—…ë°ì´íŠ¸ (ë¡œê·¸ì¸ ìƒíƒœì¼ ë•Œ)
    if (db && fileData.id && !fileData.isLocal) {
        db.collection('userFiles').doc(fileData.id).update({ name: newName })
            .catch(err => console.error('íŒŒì¼ ì´ë¦„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', err));
    }
    
    renderFileStoragePanel();
    toast(`'${oldName}' â†’ '${newName}' ì´ë¦„ ë³€ê²½ë¨`);
}

// íŒŒì¼ ë³´ê´€í•¨ì—ì„œ ì‹œíŠ¸ë¡œ ë³€í™˜
async function convertStoredFileToSheet(idx) {
    const fileData = fileStorage[idx];
    if (!fileData) return;
    
    showLoading('íŒŒì¼ ë³€í™˜ ì¤‘...');
    
    try {
        let file;
        if (fileData.data) {
            // Base64 â†’ File ë³€í™˜
            const response = await fetch(fileData.data);
            const blob = await response.blob();
            file = new File([blob], fileData.name, { type: blob.type });
        } else if (fileData.downloadURL) {
            // URLì—ì„œ ë‹¤ìš´ë¡œë“œ
            const response = await fetch(fileData.downloadURL);
            const blob = await response.blob();
            file = new File([blob], fileData.name, { type: blob.type });
        } else {
            throw new Error('íŒŒì¼ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        }
        
        await convertFileToSheet(file);
        hideLoading();
        switchMainTab('sheets');
        renderMainScreen();
    } catch (error) {
        hideLoading();
        console.error('ë³€í™˜ ì˜¤ë¥˜:', error);
        toast('íŒŒì¼ ë³€í™˜ ì‹¤íŒ¨: ' + error.message);
    }
}

// ì €ì¥ëœ íŒŒì¼ ë‹¤ìš´ë¡œë“œ
async function downloadStoredFile(idx) {
    const fileData = fileStorage[idx];
    if (!fileData) return;
    
    try {
        let url;
        if (fileData.data) {
            url = fileData.data;
        } else if (fileData.downloadURL) {
            url = fileData.downloadURL;
        } else {
            throw new Error('ë‹¤ìš´ë¡œë“œ URLì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        }
        
        const a = document.createElement('a');
        a.href = url;
        a.download = fileData.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        toast('ë‹¤ìš´ë¡œë“œ ì‹œì‘: ' + fileData.name);
    } catch (error) {
        console.error('ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
        toast('ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨');
    }
}

// ì €ì¥ëœ íŒŒì¼ ì‚­ì œ
async function deleteStoredFile(idx) {
    const fileData = fileStorage[idx];
    if (!fileData) return;
    
    if (!confirm(`'${fileData.name}' íŒŒì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
    
    try {
        // ì„œë²„ì— ì €ì¥ëœ íŒŒì¼ì¸ ê²½ìš° (isLocalì´ falseì´ê±°ë‚˜ idê°€ ìˆëŠ” ê²½ìš°)
        if (!fileData.isLocal && fileData.id && db) {
            // Firebase Storageì— ìˆëŠ” ê²½ìš° ì‚­ì œ
            if (storage && fileData.storagePath) {
                try {
                    await storage.ref(fileData.storagePath).delete();
                } catch (storageErr) {
                    console.warn('Storage ì‚­ì œ ì‹¤íŒ¨ (ë¬´ì‹œ):', storageErr);
                }
            }
            // Firestore ë©”íƒ€ë°ì´í„° ì‚­ì œ
            await db.collection('userFiles').doc(fileData.id).delete();
            console.log('ì„œë²„ì—ì„œ íŒŒì¼ ì‚­ì œ:', fileData.id, fileData.name);
        }
        
        // í´ë” ë§¤í•‘ë„ ì‚­ì œ
        if (fileData.id) {
            delete fileToFolder[fileData.id];
        }
        
        fileStorage.splice(idx, 1);
        multiSelectedFiles.delete(fileData.id);
        invalidateFileRenderCache();
        renderFileStoragePanel();
        toast('íŒŒì¼ ì‚­ì œë¨');
    } catch (error) {
        console.error('ì‚­ì œ ì˜¤ë¥˜:', error);
        toast('ì‚­ì œ ì‹¤íŒ¨: ' + error.message);
    }
}

// ===== íŒŒì¼ ë³´ê´€í•¨ í´ë” ê¸°ëŠ¥ =====

// íŒŒì¼ í´ë” ìƒì„±
function createFileFolder(name = null) {
    const folderName = name || prompt('ìƒˆ í´ë” ì´ë¦„:', 'ìƒˆ í´ë”');
    if (!folderName || !folderName.trim()) return;
    
    const folderId = 'ff_' + Date.now();
    fileFolders[folderId] = {
        name: folderName.trim(),
        parentId: currentFileFolderId,
        createdAt: new Date().toISOString()
    };
    
    saveFileFolderData();
    invalidateFileRenderCache();
    renderFileStoragePanel();
    toast(`'${folderName.trim()}' í´ë” ìƒì„±ë¨`);
}

// íŒŒì¼ í´ë” ì‚­ì œ
function deleteFileFolder(folderId) {
    const folder = fileFolders[folderId];
    if (!folder) return;
    
    const fileCount = Object.values(fileToFolder).filter(fid => fid === folderId).length;
    
    if (fileCount > 0) {
        const choice = confirm(
            `'${folder.name}' í´ë”ì— ${fileCount}ê°œ íŒŒì¼ì´ ìˆìŠµë‹ˆë‹¤.\n\n` +
            `[í™•ì¸] íŒŒì¼ì„ 'ì „ì²´'ë¡œ ì´ë™í•˜ê³  í´ë” ì‚­ì œ\n` +
            `[ì·¨ì†Œ] ì‚­ì œ ì·¨ì†Œ`
        );
        
        if (!choice) return;
        
        // íŒŒì¼ì„ ì „ì²´ë¡œ ì´ë™
        for (const fileId in fileToFolder) {
            if (fileToFolder[fileId] === folderId) {
                delete fileToFolder[fileId];
            }
        }
    } else {
        if (!confirm(`'${folder.name}' í´ë”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
    }
    
    delete fileFolders[folderId];
    
    if (currentFileFolderId === folderId) {
        currentFileFolderId = null;
    }
    
    saveFileFolderData();
    renderFileStoragePanel();
    toast(`í´ë” '${folder.name}' ì‚­ì œë¨`);
}

// íŒŒì¼ í´ë” ë„¤ë¹„ê²Œì´ì…˜
function navigateFileFolder(folderId) {
    currentFileFolderId = folderId;
    multiSelectedFiles.clear();
    invalidateFileRenderCache();
    renderFileStoragePanel();
}

// íŒŒì¼ í´ë” ì´ë¦„ ë³€ê²½ ì‹œì‘ (ì¸ë¼ì¸ í¸ì§‘)
function startRenameFileFolderCard(folderId) {
    const folder = fileFolders[folderId];
    if (!folder) return;
    
    const folderCard = document.querySelector(`.file-folder-card[data-folder-id="${folderId}"]`);
    if (!folderCard) return;
    
    const nameEl = folderCard.querySelector('.file-folder-name');
    if (!nameEl) return;
    
    const currentName = folder.name;
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentName;
    input.className = 'folder-rename-input';
    input.style.cssText = 'width:100%;padding:4px 8px;border:2px solid var(--retro-blue);border-radius:4px;font-size:13px;text-align:center;';
    
    nameEl.innerHTML = '';
    nameEl.appendChild(input);
    input.focus();
    input.select();
    
    const finishRename = () => {
        const newName = input.value.trim();
        if (newName && newName !== currentName) {
            fileFolders[folderId].name = newName;
            saveFileFolderData();
            toast(`í´ë” ì´ë¦„ ë³€ê²½: '${newName}'`);
        }
        renderFileStoragePanel();
    };
    
    input.addEventListener('blur', finishRename);
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
        } else if (e.key === 'Escape') {
            input.value = currentName;
            input.blur();
        }
    });
}

// íŒŒì¼ ì„ íƒ í† ê¸€
function toggleFileSelect(event, fileId) {
    event.stopPropagation();
    
    if (event.ctrlKey || event.metaKey || event.target.type === 'checkbox') {
        // ë‹¤ì¤‘ ì„ íƒ ëª¨ë“œ
        if (multiSelectedFiles.has(fileId)) {
            multiSelectedFiles.delete(fileId);
        } else {
            multiSelectedFiles.add(fileId);
        }
    } else {
        // ë‹¨ì¼ í´ë¦­ - ì„ íƒ ì´ˆê¸°í™” í›„ ì„ íƒ
        multiSelectedFiles.clear();
        multiSelectedFiles.add(fileId);
    }
    
    renderFileStoragePanel();
}

// íŒŒì¼ ë“œë˜ê·¸ ì‹œì‘
function handleFileDragStart(event, fileId) {
    
    // ë‹¤ì¤‘ ì„ íƒëœ ìƒíƒœì—ì„œ ë“œë˜ê·¸í•˜ë©´, ì„ íƒëœ íŒŒì¼ì´ ì—†ê±°ë‚˜ í˜„ì¬ íŒŒì¼ì´ ì„ íƒ ì•ˆë˜ì–´ìˆìœ¼ë©´ í˜„ì¬ íŒŒì¼ë§Œ
    if (multiSelectedFiles.size > 0 && !multiSelectedFiles.has(fileId)) {
        // ì„ íƒ ì•ˆëœ íŒŒì¼ì„ ë“œë˜ê·¸í•˜ë©´ ê¸°ì¡´ ì„ íƒ ì´ˆê¸°í™”í•˜ê³  ì´ íŒŒì¼ë§Œ
        multiSelectedFiles.clear();
        document.querySelectorAll('.file-card.selected, .file-storage-item.selected').forEach(el => {
            el.classList.remove('selected');
        });
    }
    
    // ë‹¤ì¤‘ ì„ íƒì´ ì—†ìœ¼ë©´ í˜„ì¬ íŒŒì¼ì„ ì„ íƒì— ì¶”ê°€
    if (multiSelectedFiles.size === 0) {
        multiSelectedFiles.add(fileId);
    }
    
    // ë“œë˜ê·¸ ì•„ì´í…œ ì„¤ì • (ì‹œíŠ¸ì™€ ë™ì¼í•œ íŒ¨í„´)
    fileDragItem = { type: 'file', id: fileId };
    
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', JSON.stringify({
        type: 'file',
        fileId: fileId,
        selectedFiles: Array.from(multiSelectedFiles)
    }));
    
    // ë“œë˜ê·¸ ëŒ€ìƒ ìš”ì†Œ ì°¾ê¸° (ìì‹ ìš”ì†Œì—ì„œ ì‹œì‘ëœ ê²½ìš° ë¶€ëª¨ ì°¾ê¸°)
    let target = event.target;
    if (!target.classList.contains('file-card') && !target.classList.contains('file-storage-item')) {
        target = target.closest('.file-card') || target.closest('.file-storage-item') || target;
    }
    target.classList.add('dragging');
    
    // ë“œë˜ê·¸ ì‹œ ì„ íƒëœ ê°œìˆ˜ í‘œì‹œ
    if (multiSelectedFiles.size > 1) {
        toast(`${multiSelectedFiles.size}ê°œ íŒŒì¼ ë“œë˜ê·¸ ì¤‘...`);
    }
}

// íŒŒì¼ ë“œë˜ê·¸ ì¢…ë£Œ
function handleFileDragEnd(event) {
    // ë“œë˜ê·¸ ëŒ€ìƒ ìš”ì†Œ ì°¾ê¸°
    let target = event.target;
    if (!target.classList.contains('file-card') && !target.classList.contains('file-storage-item')) {
        target = target.closest('.file-card') || target.closest('.file-storage-item') || target;
    }
    target.classList.remove('dragging');
    
    fileDragItem = null; // ë“œë˜ê·¸ ì•„ì´í…œ ì´ˆê¸°í™”
    // folder-card, file-folder-card, folder-breadcrumb-item, folder-item ëª¨ë‘ ì²˜ë¦¬
    document.querySelectorAll('.folder-card.drag-over, .file-folder-card.drag-over, .folder-breadcrumb-item.drag-over, .folder-item.drag-over').forEach(el => {
        el.classList.remove('drag-over');
    });
}

// íŒŒì¼ í´ë” ìœ„ì— ë“œë˜ê·¸ ì˜¤ë²„
function handleFileFolderDragOver(event) {
    event.preventDefault();
    event.currentTarget.classList.add('drag-over');
}

// íŒŒì¼ í´ë”ì—ì„œ ë“œë˜ê·¸ ë– ë‚¨
function handleFileFolderDragLeave(event) {
    event.currentTarget.classList.remove('drag-over');
}

// í´ë”ì— íŒŒì¼ ë“œë¡­
function handleFileDropToFolder(event, folderId) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    // í´ë” ì¡´ì¬ í™•ì¸
    const folder = fileFolders[folderId];
    if (!folder) {
        console.error('í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', folderId);
        return;
    }
    
    // ì´ë™í•  íŒŒì¼ ëª©ë¡ ê²°ì •
    let filesToMove = [];
    
    try {
        const dataStr = event.dataTransfer.getData('text/plain');
        if (dataStr) {
            const data = JSON.parse(dataStr);
            if (data.type === 'file') {
                filesToMove = data.selectedFiles && data.selectedFiles.length > 0 ? data.selectedFiles : [data.fileId];
            }
        }
    } catch (e) {
    }
    
    // fallback: fileDragItem ë˜ëŠ” multiSelectedFiles ì‚¬ìš©
    if (filesToMove.length === 0) {
        if (multiSelectedFiles.size > 0) {
            filesToMove = Array.from(multiSelectedFiles);
        } else if (fileDragItem && fileDragItem.type === 'file') {
            filesToMove = [fileDragItem.id];
        }
    }
    
    if (filesToMove.length === 0) return;
    
    // ìœ íš¨í•œ íŒŒì¼ë§Œ ì´ë™
    let movedCount = 0;
    filesToMove.forEach(fileId => {
        // íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        const fileExists = fileStorage.some(f => f.id === fileId);
        if (fileExists) {
            fileToFolder[fileId] = folderId;
            movedCount++;
        }
    });
    
    if (movedCount > 0) {
        saveFileFolderData();
        multiSelectedFiles.clear();
        fileDragItem = null;
        renderFileStoragePanel();
        
        toast(`${movedCount}ê°œ íŒŒì¼ì„ '${folder.name}'ë¡œ ì´ë™`);
    }
}

// íŒŒì¼ì„ ë£¨íŠ¸(ì „ì²´)ë¡œ ë“œë¡­
function handleFileDropToRoot(event) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    // ì´ë™í•  íŒŒì¼ ëª©ë¡ ê²°ì •
    let filesToMove = [];
    
    try {
        const dataStr = event.dataTransfer.getData('text/plain');
        if (dataStr) {
            const data = JSON.parse(dataStr);
            if (data.type === 'file') {
                filesToMove = data.selectedFiles && data.selectedFiles.length > 0 ? data.selectedFiles : [data.fileId];
            }
        }
    } catch (e) {
    }
    
    // fallback: fileDragItem ë˜ëŠ” multiSelectedFiles ì‚¬ìš©
    if (filesToMove.length === 0) {
        if (multiSelectedFiles.size > 0) {
            filesToMove = Array.from(multiSelectedFiles);
        } else if (fileDragItem && fileDragItem.type === 'file') {
            filesToMove = [fileDragItem.id];
        }
    }
    
    if (filesToMove.length === 0) return;
    
    // ìœ íš¨í•œ íŒŒì¼ë§Œ ì´ë™
    let movedCount = 0;
    filesToMove.forEach(fileId => {
        // íŒŒì¼ì´ ì¡´ì¬í•˜ê³  í´ë”ì— ìˆëŠ” ê²½ìš°ë§Œ
        const fileExists = fileStorage.some(f => f.id === fileId);
        if (fileExists && fileToFolder[fileId]) {
            delete fileToFolder[fileId]; // í´ë” ë§¤í•‘ ì œê±° = ë£¨íŠ¸ë¡œ ì´ë™
            movedCount++;
        }
    });
    
    if (movedCount > 0) {
        saveFileFolderData();
        multiSelectedFiles.clear();
        fileDragItem = null;
        renderFileStoragePanel();
        
        toast(`${movedCount}ê°œ íŒŒì¼ì„ 'ì „ì²´'ë¡œ ì´ë™`);
    }
}

// íŒŒì¼ í´ë” ë°ì´í„° ì €ì¥
function saveFileFolderData() {
    try {
        localStorage.setItem('excelmaster_fileFolders', JSON.stringify(fileFolders));
        localStorage.setItem('excelmaster_fileToFolder', JSON.stringify(fileToFolder));
    } catch (e) {
        console.error('íŒŒì¼ í´ë” ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:', e);
    }
}

// íŒŒì¼ í´ë” ë°ì´í„° ë¡œë“œ
function loadFileFolderData() {
    try {
        const foldersData = localStorage.getItem('excelmaster_fileFolders');
        const mappingData = localStorage.getItem('excelmaster_fileToFolder');
        
        if (foldersData) {
            fileFolders = JSON.parse(foldersData);
        }
        if (mappingData) {
            fileToFolder = JSON.parse(mappingData);
        }
    } catch (e) {
        console.error('íŒŒì¼ í´ë” ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', e);
        fileFolders = {};
        fileToFolder = {};
    }
}

// íŒŒì¼ í´ë” ì´ë¦„ ë³€ê²½ ì‹œì‘
function startRenameFileFolder(folderId) {
    const folder = fileFolders[folderId];
    if (!folder) return;
    
    const newName = prompt('í´ë” ì´ë¦„ ë³€ê²½:', folder.name);
    if (!newName || !newName.trim() || newName === folder.name) return;
    
    folder.name = newName.trim();
    saveFileFolderData();
    renderFileStoragePanel();
    toast(`í´ë” ì´ë¦„ ë³€ê²½ë¨: '${newName}'`);
}

// íŒŒì¼ ì´ë¦„ ë³€ê²½ (prompt ë°©ì‹ - ìš°í´ë¦­ ë©”ë‰´ìš©)
function startRenameFileFromMenu(idx) {
    const fileData = fileStorage[idx];
    if (!fileData) return;
    
    const currentName = fileData.name;
    const lastDot = currentName.lastIndexOf('.');
    const baseName = lastDot > 0 ? currentName.substring(0, lastDot) : currentName;
    const extension = lastDot > 0 ? currentName.substring(lastDot) : '';
    
    const newBaseName = prompt('ìƒˆ íŒŒì¼ ì´ë¦„:', baseName);
    if (!newBaseName || !newBaseName.trim() || newBaseName === baseName) return;
    
    const newName = newBaseName.trim() + extension;
    
    // ì¤‘ë³µ ê²€ì‚¬
    if (fileStorage.some((f, i) => i !== idx && f.name === newName)) {
        toast('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” íŒŒì¼ ì´ë¦„ì…ë‹ˆë‹¤');
        return;
    }
    
    // ì´ë¦„ ë³€ê²½
    const oldName = fileData.name;
    fileData.name = newName;
    
    // Firestore ì—…ë°ì´íŠ¸ (ë¡œê·¸ì¸ ìƒíƒœì¼ ë•Œ)
    if (db && fileData.id && !fileData.isLocal) {
        db.collection('userFiles').doc(fileData.id).update({ name: newName })
            .catch(err => console.error('íŒŒì¼ ì´ë¦„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', err));
    }
    
    renderFileStoragePanel();
    toast(`íŒŒì¼ ì´ë¦„ ë³€ê²½: '${newName}'`);
}

// ì„ íƒëœ íŒŒì¼ë“¤ í´ë”ë¡œ ì´ë™ ëª¨ë‹¬
function moveSelectedFilesToFolder() {
    if (multiSelectedFiles.size === 0) {
        toast('ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    // ì´ë™ ê°€ëŠ¥í•œ í´ë” ëª©ë¡ ìƒì„±
    const folderList = Object.entries(fileFolders).map(([id, f]) => ({ id, name: f.name }));
    
    if (folderList.length === 0) {
        toast('ì´ë™í•  í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € í´ë”ë¥¼ ë§Œë“¤ì–´ì£¼ì„¸ìš”.');
        return;
    }
    
    const modalHtml = `
        <div class="modal-overlay show" id="moveFileModal" onclick="if(event.target===this)this.remove()">
            <div class="modal-content" style="width:350px;">
                <div class="modal-header">
                    <span>íŒŒì¼ ì´ë™ (${multiSelectedFiles.size}ê°œ)</span>
                    <button class="modal-close" onclick="document.getElementById('moveFileModal').remove()">&times;</button>
                </div>
                <div class="modal-body" style="padding:20px;">
                    <label style="font-weight:600;margin-bottom:10px;display:block;">ì´ë™í•  í´ë” ì„ íƒ:</label>
                    <select id="moveFileFolderSelect" style="width:100%;padding:10px;border:2px solid var(--retro-border);border-radius:6px;font-size:14px;">
                        ${folderList.map(f => `<option value="${f.id}">${escHtml(f.name)}</option>`).join('')}
                    </select>
                    <div style="margin-top:20px;display:flex;gap:10px;justify-content:flex-end;">
                        <button class="modal-btn" onclick="document.getElementById('moveFileModal').remove()">ì·¨ì†Œ</button>
                        <button class="modal-btn primary" onclick="executeMoveFilesToFolder()">ì´ë™</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

// í´ë”ë¡œ íŒŒì¼ ì´ë™ ì‹¤í–‰
function executeMoveFilesToFolder() {
    const select = document.getElementById('moveFileFolderSelect');
    const folderId = select?.value;
    
    if (!folderId) return;
    
    const count = multiSelectedFiles.size;
    multiSelectedFiles.forEach(fileId => {
        fileToFolder[fileId] = folderId;
    });
    
    saveFileFolderData();
    multiSelectedFiles.clear();
    
    document.getElementById('moveFileModal')?.remove();
    renderFileStoragePanel();
    
    const folderName = fileFolders[folderId]?.name || 'í´ë”';
    toast(`${count}ê°œ íŒŒì¼ì„ '${folderName}'ë¡œ ì´ë™`);
}

// ì„ íƒëœ íŒŒì¼ë“¤ ì „ì²´(ë£¨íŠ¸)ë¡œ ì´ë™
function moveSelectedFilesToRoot() {
    if (multiSelectedFiles.size === 0) {
        toast('ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    const count = multiSelectedFiles.size;
    multiSelectedFiles.forEach(fileId => {
        delete fileToFolder[fileId];
    });
    
    saveFileFolderData();
    multiSelectedFiles.clear();
    renderFileStoragePanel();
    
    toast(`${count}ê°œ íŒŒì¼ì„ 'ì „ì²´'ë¡œ ì´ë™`);
}

// íŒŒì¼ í´ë” ìš°í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
function showFileFolderContextMenu(event, folderId) {
    event.preventDefault();
    event.stopPropagation();
    
    document.getElementById('fileContextMenu')?.remove();
    
    const folder = fileFolders[folderId];
    if (!folder) return;
    
    const fileCount = Object.values(fileToFolder).filter(fid => fid === folderId).length;
    
    const menu = document.createElement('div');
    menu.id = 'fileContextMenu';
    menu.className = 'context-menu show';
    menu.style.cssText = `left:${event.clientX}px;top:${event.clientY}px;`;
    
    menu.innerHTML = `
        <div class="context-menu-item" onclick="navigateFileFolder('${folderId}'); closeFileContextMenu();">ğŸ“‚ í´ë” ì—´ê¸°</div>
        <div class="context-menu-item" onclick="startRenameFileFolder('${folderId}'); closeFileContextMenu();">âœï¸ ì´ë¦„ ë³€ê²½</div>
        <div class="context-menu-item" onclick="moveAllFilesFromFolder('${folderId}'); closeFileContextMenu();">â†© íŒŒì¼ ì „ì²´ë¡œ ì´ë™ (${fileCount}ê°œ)</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" onclick="deleteFileFolder('${folderId}'); closeFileContextMenu();">ğŸ—‘ï¸ í´ë” ì‚­ì œ</div>
    `;
    
    document.body.appendChild(menu);
    
    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
    if (rect.bottom > window.innerHeight) menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
    
    setTimeout(() => {
        document.addEventListener('click', closeFileContextMenu, { once: true });
    }, 10);
}

// íŒŒì¼ ì•„ì´í…œ ìš°í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
function showFileItemContextMenu(event, fileId, idx) {
    event.preventDefault();
    event.stopPropagation();
    
    document.getElementById('fileContextMenu')?.remove();
    
    const file = fileStorage[idx];
    if (!file) return;
    
    const currentFolderId = fileToFolder[fileId];
    const isInFolder = !!currentFolderId;
    
    // ì´ë™ ê°€ëŠ¥í•œ í´ë” ëª©ë¡ - í˜„ì¬ ìœ„ì¹˜(currentFileFolderId)ì˜ ìì‹ í´ë”ë“¤ë§Œ í‘œì‹œ
    // í˜„ì¬ íŒŒì¼ì´ ì†í•œ í´ë”ëŠ” ì œì™¸
    const folderOptions = Object.entries(fileFolders)
        .filter(([id, f]) => {
            // í˜„ì¬ íŒŒì¼ì´ ì´ë¯¸ ìˆëŠ” í´ë”ëŠ” ì œì™¸
            if (id === currentFolderId) return false;
            // í˜„ì¬ ë³´ê³  ìˆëŠ” ìœ„ì¹˜ì˜ ìì‹ í´ë”ë§Œ í‘œì‹œ
            if (currentFileFolderId === null) {
                return !f.parentId; // ë£¨íŠ¸ì—ì„œëŠ” ìµœìƒìœ„ í´ë”ë§Œ
            } else {
                return f.parentId === currentFileFolderId; // í˜„ì¬ í´ë”ì˜ ìì‹ë§Œ
            }
        })
        .map(([id, f]) => {
            const safeId = id.replace(/'/g, "\\'");
            return `<div class="context-menu-item" onclick="moveFileToFolder('${fileId}', '${safeId}'); closeFileContextMenu();">ğŸ“ '${escHtml(f.name)}'ë¡œ ì´ë™</div>`;
        })
        .join('');
    
    const menu = document.createElement('div');
    menu.id = 'fileContextMenu';
    menu.className = 'context-menu show';
    menu.style.cssText = `left:${event.clientX}px;top:${event.clientY}px;`;
    
    menu.innerHTML = `
        <div class="context-menu-item" onclick="viewFile(${idx}); closeFileContextMenu();">ğŸ‘ï¸ ìƒì„¸ë³´ê¸°</div>
        <div class="context-menu-item" onclick="startRenameFileFromMenu(${idx}); closeFileContextMenu();">âœï¸ ì´ë¦„ ë³€ê²½</div>
        <div class="context-menu-item" onclick="convertStoredFileToSheet(${idx}); closeFileContextMenu();">ğŸ“Š ì‹œíŠ¸ë¡œ ë³€í™˜</div>
        <div class="context-menu-item" onclick="downloadStoredFile(${idx}); closeFileContextMenu();">ğŸ’¾ ë‹¤ìš´ë¡œë“œ</div>
        <div class="context-menu-divider"></div>
        ${folderOptions}
        ${isInFolder ? `<div class="context-menu-item" onclick="moveFileToRoot('${fileId}'); closeFileContextMenu();">â†© ì „ì²´ë¡œ ì´ë™</div>` : ''}
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" onclick="deleteStoredFile(${idx}); closeFileContextMenu();">ğŸ—‘ï¸ ì‚­ì œ</div>
    `;
    
    document.body.appendChild(menu);
    
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
    if (rect.bottom > window.innerHeight) menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
    
    setTimeout(() => {
        document.addEventListener('click', closeFileContextMenu, { once: true });
    }, 10);
}

// ë‹¨ì¼ íŒŒì¼ í´ë”ë¡œ ì´ë™
function moveFileToFolder(fileId, folderId) {
    fileToFolder[fileId] = folderId;
    saveFileFolderData();
    renderFileStoragePanel();
    
    const folderName = fileFolders[folderId]?.name || 'í´ë”';
    toast(`íŒŒì¼ì„ '${folderName}'ë¡œ ì´ë™`);
}

// ë‹¨ì¼ íŒŒì¼ ì „ì²´(ë£¨íŠ¸)ë¡œ ì´ë™
function moveFileToRoot(fileId) {
    delete fileToFolder[fileId];
    saveFileFolderData();
    renderFileStoragePanel();
    toast('íŒŒì¼ì„ ì „ì²´ë¡œ ì´ë™');
}

// í´ë” ë‚´ ëª¨ë“  íŒŒì¼ ì „ì²´ë¡œ ì´ë™
function moveAllFilesFromFolder(folderId) {
    const folder = fileFolders[folderId];
    if (!folder) return;
    
    let count = 0;
    for (const fileId in fileToFolder) {
        if (fileToFolder[fileId] === folderId) {
            delete fileToFolder[fileId];
            count++;
        }
    }
    
    if (count === 0) {
        toast('ì´ë™í•  íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    saveFileFolderData();
    renderFileStoragePanel();
    toast(`${count}ê°œ íŒŒì¼ì„ ì „ì²´ë¡œ ì´ë™`);
}

// íŒŒì¼ ë³´ê´€í•¨ ìš°í´ë¦­ ë©”ë‰´ (ë¹ˆ ì˜ì—­)
function showFileContextMenu(event) {
    event.preventDefault();
    
    // ê¸°ì¡´ ë©”ë‰´ ì œê±°
    document.getElementById('fileContextMenu')?.remove();
    
    const menu = document.createElement('div');
    menu.id = 'fileContextMenu';
    menu.className = 'context-menu show';
    menu.style.cssText = `left:${event.clientX}px;top:${event.clientY}px;`;
    
    menu.innerHTML = `
        <div class="context-menu-item" onclick="createFileFolder(); closeFileContextMenu();">ğŸ“ ìƒˆ í´ë”</div>
        <div class="context-menu-item" onclick="document.getElementById('mainFileInput').click(); closeFileContextMenu();">ğŸ“„ íŒŒì¼ ì—…ë¡œë“œ</div>
        <div class="context-menu-item" onclick="renderFileStoragePanel(); closeFileContextMenu();">ğŸ”„ ìƒˆë¡œê³ ì¹¨</div>
    `;
    
    document.body.appendChild(menu);
    
    // ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
    setTimeout(() => {
        document.addEventListener('click', closeFileContextMenu, { once: true });
    }, 10);
}

function closeFileContextMenu() {
    document.getElementById('fileContextMenu')?.remove();
}

// íŒŒì¼ ë³´ê´€í•¨ ì´ˆê¸°í™” ì‹œ í´ë” ë°ì´í„° ë¡œë“œ
document.addEventListener('DOMContentLoaded', () => {
    loadFileFolderData();
});

// ===== 5. ìƒì„¸ë³´ê¸° ë·°ì–´ =====
let currentViewerPage = 1;
let totalViewerPages = 1;
let viewerZoom = 100;
let pdfDocumentCache = null;

function viewFile(idx) {
    const fileData = fileStorage[idx];
    if (!fileData) return;
    
    currentViewerFile = fileData;
    showFileViewer(fileData);
}

async function showFileViewer(fileData) {
    const icon = getFileIcon(fileData.type);
    
    const viewerHtml = `
        <div class="file-viewer-overlay show" id="fileViewerOverlay">
            <div class="file-viewer-header">
                <div class="file-viewer-title">
                    <span>${icon}</span>
                    <span>${fileData.name}</span>
                </div>
                <div class="file-viewer-controls">
                    <button class="viewer-nav-btn" onclick="viewerPrevPage()" id="viewerPrevBtn">â—€ ì´ì „</button>
                    <span class="viewer-page-info" id="viewerPageInfo">ë¡œë”© ì¤‘...</span>
                    <button class="viewer-nav-btn" onclick="viewerNextPage()" id="viewerNextBtn">ë‹¤ìŒ â–¶</button>
                    <div class="viewer-zoom-controls">
                        <button class="viewer-nav-btn" onclick="viewerZoomOut()">âˆ’</button>
                        <span id="viewerZoomLevel">100%</span>
                        <button class="viewer-nav-btn" onclick="viewerZoomIn()">+</button>
                    </div>
                </div>
                <button class="viewer-close-btn" onclick="closeFileViewer()">Ã—</button>
            </div>
            <div class="file-viewer-body">
                <div class="file-viewer-content" id="viewerContent">
                    <div style="padding: 50px; text-align: center; color: #666;">ë¡œë”© ì¤‘...</div>
                </div>
            </div>
            <div class="file-viewer-footer">
                <div>
                    <button class="viewer-footer-btn secondary" onclick="downloadFromViewer()">ë‹¤ìš´ë¡œë“œ</button>
                    <button class="viewer-footer-btn secondary" onclick="printFromViewer()">ì¸ì‡„</button>
                    <button class="viewer-footer-btn primary" onclick="convertFromViewer()">ì‹œíŠ¸ë¡œ ë³€í™˜</button>
                </div>
                <button class="viewer-footer-btn" onclick="closeFileViewer()">ë‹«ê¸°</button>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', viewerHtml);
    
    // íŒŒì¼ ë‚´ìš© ë¡œë“œ
    await loadViewerContent(fileData);
}

async function loadViewerContent(fileData) {
    const contentDiv = document.getElementById('viewerContent');
    currentViewerPage = 1;
    viewerZoom = 100;
    
    try {
        let fileBlob;
        
        // Base64 ë°ì´í„°ê°€ ìˆìœ¼ë©´ (ë¡œì»¬ ë˜ëŠ” ì„œë²„ì—ì„œ ë¶ˆëŸ¬ì˜¨ íŒŒì¼)
        if (fileData.data) {
            const response = await fetch(fileData.data);
            fileBlob = await response.blob();
        } 
        // downloadUrlì´ ìˆìœ¼ë©´ (Firebase Storageì—ì„œ ë¶ˆëŸ¬ì˜¨ íŒŒì¼)
        else if (fileData.downloadURL) {
            const response = await fetch(fileData.downloadURL);
            fileBlob = await response.blob();
        }
        // textContentë§Œ ìˆëŠ” ê²½ìš° (TXT, HTML)
        else if (fileData.textContent) {
            fileBlob = new Blob([fileData.textContent], { type: 'text/plain' });
        }
        else {
            throw new Error('íŒŒì¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤');
        }
        
        const ext = fileData.type.toLowerCase();
        
        if (ext === 'pdf') {
            await renderPdfViewer(fileBlob, contentDiv);
        } else if (ext === 'txt') {
            await renderTextViewer(fileBlob, contentDiv);
        } else if (ext === 'html' || ext === 'htm') {
            await renderHtmlViewer(fileBlob, contentDiv);
        } else if (ext === 'docx' || ext === 'doc') {
            await renderDocxViewer(fileBlob, contentDiv);
        } else if (ext === 'pptx' || ext === 'ppt') {
            await renderPptxViewer(fileBlob, contentDiv);
        } else if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'].includes(ext)) {
            await renderImageViewer(fileBlob, contentDiv);
        } else {
            contentDiv.innerHTML = '<div style="padding: 50px; text-align: center;">ë¯¸ë¦¬ë³´ê¸°ë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” í˜•ì‹ì…ë‹ˆë‹¤.</div>';
        }
    } catch (error) {
        console.error('ë·°ì–´ ë¡œë”© ì˜¤ë¥˜:', error);
        contentDiv.innerHTML = '<div style="padding: 50px; text-align: center; color: red;">íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</div>';
    }
}

async function renderPdfViewer(blob, container) {
    const arrayBuffer = await blob.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    pdfDocumentCache = pdf;
    totalViewerPages = pdf.numPages;
    
    container.classList.add('pdf-view');
    await renderPdfPage(currentViewerPage);
    updateViewerPageInfo();
}

async function renderPdfPage(pageNum) {
    if (!pdfDocumentCache) return;
    
    const page = await pdfDocumentCache.getPage(pageNum);
    const scale = viewerZoom / 100 * 1.5;
    const viewport = page.getViewport({ scale });
    
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;
    
    await page.render({ canvasContext: context, viewport }).promise;
    
    const container = document.getElementById('viewerContent');
    container.innerHTML = '';
    container.appendChild(canvas);
}

async function renderTextViewer(blob, container) {
    const text = await blob.text();
    container.classList.add('text-view');
    container.textContent = text;
    totalViewerPages = 1;
    updateViewerPageInfo();
}

async function renderHtmlViewer(blob, container) {
    const html = await blob.text();
    
    // HTML ì†ŒìŠ¤ ì½”ë“œë¥¼ í…ìŠ¤íŠ¸ë¡œ í‘œì‹œ
    container.classList.add('text-view');
    container.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word; padding: 20px; margin: 0; font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.5; background: #f8f8f8; color: #333;">${escHtml(html)}</pre>`;
    totalViewerPages = 1;
    updateViewerPageInfo();
}

async function renderDocxViewer(blob, container) {
    const arrayBuffer = await blob.arrayBuffer();
    const result = await mammoth.convertToHtml({ arrayBuffer });
    container.innerHTML = `<div style="padding: 30px; max-width: 800px; margin: 0 auto;">${result.value}</div>`;
    totalViewerPages = 1;
    updateViewerPageInfo();
}

async function renderPptxViewer(blob, container) {
    const arrayBuffer = await blob.arrayBuffer();
    const zip = await JSZip.loadAsync(arrayBuffer);
    
    const slideFiles = Object.keys(zip.files)
        .filter(name => name.match(/ppt\/slides\/slide\d+\.xml$/))
        .sort((a, b) => {
            const numA = parseInt(a.match(/slide(\d+)/)[1]);
            const numB = parseInt(b.match(/slide(\d+)/)[1]);
            return numA - numB;
        });
    
    totalViewerPages = slideFiles.length;
    
    // ì´ë¯¸ì§€ë“¤ì„ Base64ë¡œ ë¯¸ë¦¬ ì¶”ì¶œ
    const mediaFiles = {};
    const mediaKeys = Object.keys(zip.files).filter(name => name.startsWith('ppt/media/'));
    for (const mediaPath of mediaKeys) {
        const data = await zip.file(mediaPath).async('base64');
        const ext = mediaPath.split('.').pop().toLowerCase();
        const mimeType = ext === 'png' ? 'image/png' : ext === 'gif' ? 'image/gif' : 'image/jpeg';
        mediaFiles[mediaPath] = `data:${mimeType};base64,${data}`;
    }
    
    // zipê³¼ ë¯¸ë””ì–´ ìºì‹œ ì €ì¥
    container.dataset.slideFiles = JSON.stringify(slideFiles);
    container.pptxZip = zip;
    container.pptxMedia = mediaFiles;
    
    // í˜„ì¬ ìŠ¬ë¼ì´ë“œ ë Œë”ë§
    await renderPptxSlide(zip, slideFiles, currentViewerPage - 1, container, mediaFiles);
    updateViewerPageInfo();
}

async function renderPptxSlide(zip, slideFiles, slideIdx, container, mediaFiles) {
    if (slideIdx < 0 || slideIdx >= slideFiles.length) return;
    
    const slideNum = slideIdx + 1;
    const slideXml = await zip.file(slideFiles[slideIdx]).async('text');
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(slideXml, 'text/xml');
    
    // ìŠ¬ë¼ì´ë“œ-ì´ë¯¸ì§€ ê´€ê³„ íŒŒì¼ ì½ê¸°
    const relsPath = `ppt/slides/_rels/slide${slideNum}.xml.rels`;
    let imageRefs = {};
    if (zip.files[relsPath]) {
        const relsXml = await zip.file(relsPath).async('text');
        const relsDoc = parser.parseFromString(relsXml, 'text/xml');
        const relationships = relsDoc.getElementsByTagName('Relationship');
        for (let i = 0; i < relationships.length; i++) {
            const rel = relationships[i];
            const id = rel.getAttribute('Id');
            const target = rel.getAttribute('Target');
            if (target && target.includes('media/')) {
                const mediaPath = 'ppt/media/' + target.split('media/')[1];
                imageRefs[id] = mediaPath;
            }
        }
    }
    
    // í…ìŠ¤íŠ¸ ì¶”ì¶œ
    const textElements = xmlDoc.getElementsByTagName('a:t');
    let texts = [];
    for (let i = 0; i < textElements.length; i++) {
        const text = textElements[i].textContent.trim();
        if (text) texts.push(text);
    }
    
    // ì´ë¯¸ì§€ ì°¸ì¡° ì¶”ì¶œ
    const blipElements = xmlDoc.getElementsByTagName('a:blip');
    let images = [];
    for (let i = 0; i < blipElements.length; i++) {
        const embed = blipElements[i].getAttribute('r:embed');
        if (embed && imageRefs[embed] && mediaFiles[imageRefs[embed]]) {
            images.push(mediaFiles[imageRefs[embed]]);
        }
    }
    
    // HTML ìƒì„± - ìŠ¬ë¼ì´ë“œ ìŠ¤íƒ€ì¼
    let html = `
        <div style="
            width: 960px; 
            min-height: 540px; 
            margin: 20px auto; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            padding: 40px;
            box-sizing: border-box;
            color: white;
            position: relative;
        ">
            <div style="font-size: 11px; opacity: 0.7; margin-bottom: 15px;">ìŠ¬ë¼ì´ë“œ ${slideNum} / ${slideFiles.length}</div>
    `;
    
    // ì œëª© (ì²« ë²ˆì§¸ í…ìŠ¤íŠ¸)
    if (texts.length > 0) {
        html += `<h1 style="font-size: 28px; font-weight: bold; margin-bottom: 25px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">${escHtml(texts[0])}</h1>`;
    }
    
    // ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ í‘œì‹œ
    if (images.length > 0) {
        html += '<div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;">';
        images.forEach(imgSrc => {
            html += `<img src="${imgSrc}" style="max-width: 400px; max-height: 300px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">`;
        });
        html += '</div>';
    }
    
    // ë‚˜ë¨¸ì§€ í…ìŠ¤íŠ¸ (ë³¸ë¬¸)
    if (texts.length > 1) {
        html += '<div style="font-size: 16px; line-height: 1.8;">';
        for (let i = 1; i < texts.length; i++) {
            html += `<p style="margin: 8px 0;">${escHtml(texts[i])}</p>`;
        }
        html += '</div>';
    }
    
    html += '</div>';
    container.innerHTML = html;
}

async function renderImageViewer(blob, container) {
    const url = URL.createObjectURL(blob);
    container.innerHTML = `
        <div style="display: flex; justify-content: center; align-items: center; min-height: 400px; padding: 20px;">
            <img src="${url}" style="max-width: 100%; max-height: 70vh; object-fit: contain; border-radius: 4px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);" 
                 onload="URL.revokeObjectURL(this.src)">
        </div>
    `;
    totalViewerPages = 1;
    updateViewerPageInfo();
}

function updateViewerPageInfo() {
    const pageInfo = document.getElementById('viewerPageInfo');
    const prevBtn = document.getElementById('viewerPrevBtn');
    const nextBtn = document.getElementById('viewerNextBtn');
    const zoomLevel = document.getElementById('viewerZoomLevel');
    
    if (pageInfo) {
        pageInfo.textContent = `${currentViewerPage} / ${totalViewerPages}`;
    }
    if (prevBtn) prevBtn.disabled = currentViewerPage <= 1;
    if (nextBtn) nextBtn.disabled = currentViewerPage >= totalViewerPages;
    if (zoomLevel) zoomLevel.textContent = viewerZoom + '%';
}

async function viewerPrevPage() {
    if (currentViewerPage <= 1) return;
    currentViewerPage--;
    await updateViewerPage();
}

async function viewerNextPage() {
    if (currentViewerPage >= totalViewerPages) return;
    currentViewerPage++;
    await updateViewerPage();
}

async function updateViewerPage() {
    const fileData = currentViewerFile;
    if (!fileData) return;
    
    const ext = fileData.type.toLowerCase();
    
    if (ext === 'pdf' && pdfDocumentCache) {
        await renderPdfPage(currentViewerPage);
    } else if (ext === 'pptx' || ext === 'ppt') {
        // PPTX ìŠ¬ë¼ì´ë“œ ë³€ê²½ - ìºì‹œëœ ë°ì´í„° ì‚¬ìš©
        const container = document.getElementById('viewerContent');
        const slideFiles = JSON.parse(container.dataset.slideFiles || '[]');
        
        // ìºì‹œëœ zipê³¼ ë¯¸ë””ì–´ ì‚¬ìš©
        if (container.pptxZip && container.pptxMedia) {
            await renderPptxSlide(container.pptxZip, slideFiles, currentViewerPage - 1, container, container.pptxMedia);
        } else {
            // ìºì‹œê°€ ì—†ìœ¼ë©´ ë‹¤ì‹œ ë¡œë“œ
            let fileBlob;
            if (fileData.data) {
                const response = await fetch(fileData.data);
                fileBlob = await response.blob();
            } else if (fileData.downloadURL) {
                const response = await fetch(fileData.downloadURL);
                fileBlob = await response.blob();
            } else {
                console.error('PPTX íŒŒì¼ ë°ì´í„° ì—†ìŒ');
                return;
            }
            
            const arrayBuffer = await fileBlob.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);
            await renderPptxSlide(zip, slideFiles, currentViewerPage - 1, container, {});
        }
    }
    
    updateViewerPageInfo();
}

function viewerZoomIn() {
    if (viewerZoom >= 200) return;
    viewerZoom += 25;
    applyViewerZoom();
}

function viewerZoomOut() {
    if (viewerZoom <= 50) return;
    viewerZoom -= 25;
    applyViewerZoom();
}

async function applyViewerZoom() {
    const fileData = currentViewerFile;
    if (!fileData) return;
    
    const ext = fileData.type.toLowerCase();
    if (ext === 'pdf' && pdfDocumentCache) {
        await renderPdfPage(currentViewerPage);
    }
    
    updateViewerPageInfo();
}

function downloadFromViewer() {
    if (!currentViewerFile) return;
    const idx = fileStorage.findIndex(f => f.id === currentViewerFile.id || f.name === currentViewerFile.name);
    if (idx >= 0) downloadStoredFile(idx);
}

function printFromViewer() {
    if (!currentViewerFile) return;
    
    const contentDiv = document.getElementById('viewerContent');
    if (!contentDiv) return;
    
    // ì¸ì‡„ìš© ìŠ¤íƒ€ì¼ê³¼ ë‚´ìš©ì„ ìƒˆ ì°½ì—ì„œ ì—´ê¸°
    const printWindow = window.open('', '_blank');
    
    const ext = currentViewerFile.type.toLowerCase();
    let printContent = '';
    
    if (ext === 'pdf') {
        // PDFëŠ” ìº”ë²„ìŠ¤ë¥¼ ì´ë¯¸ì§€ë¡œ ë³€í™˜
        const canvas = contentDiv.querySelector('canvas');
        if (canvas) {
            printContent = `<img src="${canvas.toDataURL()}" style="max-width:100%;height:auto;">`;
        }
    } else if (ext === 'txt' || ext === 'html' || ext === 'htm') {
        // í…ìŠ¤íŠ¸/HTMLì€ pre ë˜ëŠ” ë‚´ìš© ê·¸ëŒ€ë¡œ
        const pre = contentDiv.querySelector('pre');
        if (pre) {
            printContent = `<pre style="white-space:pre-wrap;word-wrap:break-word;font-family:monospace;font-size:12px;">${pre.textContent}</pre>`;
        } else {
            printContent = contentDiv.innerHTML;
        }
    } else {
        // ê¸°íƒ€ íŒŒì¼ì€ ë‚´ìš© ê·¸ëŒ€ë¡œ
        printContent = contentDiv.innerHTML;
    }
    
    printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>${currentViewerFile.name} - ì¸ì‡„</title>
            <style>
                body { font-family: 'Malgun Gothic', sans-serif; padding: 20px; margin: 0; }
                @media print {
                    body { padding: 0; }
                }
            </style>
        </head>
        <body>
            <h3 style="margin-bottom:20px;border-bottom:1px solid #ccc;padding-bottom:10px;">${currentViewerFile.name}</h3>
            ${printContent}
        </body>
        </html>
    `);
    
    printWindow.document.close();
    printWindow.focus();
    
    // ì•½ê°„ ë”œë ˆì´ í›„ ì¸ì‡„ ëŒ€í™”ìƒì ì—´ê¸°
    setTimeout(() => {
        printWindow.print();
    }, 300);
}

async function convertFromViewer() {
    if (!currentViewerFile) return;
    const idx = fileStorage.findIndex(f => f.id === currentViewerFile.id || f.name === currentViewerFile.name);
    closeFileViewer();
    if (idx >= 0) await convertStoredFileToSheet(idx);
}

function closeFileViewer() {
    const overlay = document.getElementById('fileViewerOverlay');
    if (overlay) overlay.remove();
    currentViewerFile = null;
    pdfDocumentCache = null;
}

// ===== 6. ì‹œíŠ¸ â†’ ë¬¸ì„œ ë³€í™˜ (ë‚´ë³´ë‚´ê¸°) =====
function showExportModal() {
    if (!SHEET || !WB[SHEET]) {
        toast('ë‚´ë³´ë‚¼ ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    const modalHtml = `
        <div class="modal-overlay export-modal show" id="exportModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>'${SHEET}' ì‹œíŠ¸ ë‚´ë³´ë‚´ê¸°</h3>
                    <button class="modal-close" onclick="closeExportModal()">Ã—</button>
                </div>
                <div class="export-options">
                    <div class="export-option" onclick="selectExportFormat('pdf')">
                        <span class="export-option-icon">ğŸ“•</span>
                        <span class="export-option-label">PDF</span>
                        <span class="export-option-desc">ë¬¸ì„œ í˜•íƒœë¡œ ì €ì¥</span>
                    </div>
                    <div class="export-option" onclick="selectExportFormat('pptx')">
                        <span class="export-option-icon">ğŸ“™</span>
                        <span class="export-option-label">PowerPoint</span>
                        <span class="export-option-desc">í”„ë ˆì  í…Œì´ì…˜ìœ¼ë¡œ ì €ì¥</span>
                    </div>
                    <div class="export-option" onclick="selectExportFormat('docx')">
                        <span class="export-option-icon">ğŸ“˜</span>
                        <span class="export-option-label">Word</span>
                        <span class="export-option-desc">ì›Œë“œ ë¬¸ì„œë¡œ ì €ì¥</span>
                    </div>
                    <div class="export-option" onclick="selectExportFormat('txt')">
                        <span class="export-option-icon">ğŸ“„</span>
                        <span class="export-option-label">í…ìŠ¤íŠ¸</span>
                        <span class="export-option-desc">TXT íŒŒì¼ë¡œ ì €ì¥</span>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="modal-btn" onclick="closeExportModal()">ì·¨ì†Œ</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function selectExportFormat(format) {
    closeExportModal();
    exportSheetAs(format);
}

function closeExportModal() {
    const modal = document.getElementById('exportModal');
    if (modal) modal.remove();
}

async function exportSheetAs(format) {
    if (!SHEET || !WB[SHEET]) return;
    
    showLoading(`${format.toUpperCase()}ë¡œ ë³€í™˜ ì¤‘...`);
    
    try {
        const sheetData = WB[SHEET];
        const fileName = `${SHEET}_${new Date().toISOString().slice(0,10)}`;
        
        switch(format) {
            case 'pdf':
                await exportToPdf(sheetData, fileName);
                break;
            case 'pptx':
                await exportToPptx(sheetData, fileName);
                break;
            case 'docx':
                await exportToDocx(sheetData, fileName);
                break;
            case 'txt':
                exportToTxt(sheetData, fileName);
                break;
        }
        
        hideLoading();
        toast(`${format.toUpperCase()} ë‚´ë³´ë‚´ê¸° ì™„ë£Œ!`);
    } catch (error) {
        hideLoading();
        console.error('ë‚´ë³´ë‚´ê¸° ì˜¤ë¥˜:', error);
        toast('ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: ' + error.message);
    }
}

// PDF ë‚´ë³´ë‚´ê¸°
async function exportToPdf(sheetData, fileName) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    // í•œê¸€ í°íŠ¸ ì„¤ì • (ê¸°ë³¸ í°íŠ¸ ì‚¬ìš©)
    doc.setFont('helvetica');
    
    // ì œëª©
    doc.setFontSize(16);
    doc.text(SHEET, 14, 20);
    
    // í…Œì´ë¸” ë°ì´í„° ì¤€ë¹„
    const headers = sheetData.headers;
    const rows = sheetData.data.map(row => row.map(cell => String(cell || '')));
    
    // autoTable ì‚¬ìš©
    doc.autoTable({
        head: [headers],
        body: rows,
        startY: 30,
        styles: { fontSize: 8, cellPadding: 2 },
        headStyles: { fillColor: [45, 140, 158] }
    });
    
    doc.save(fileName + '.pdf');
}

// PPTX ë‚´ë³´ë‚´ê¸°
async function exportToPptx(sheetData, fileName) {
    const pptx = new PptxGenJS();
    
    // ì œëª© ìŠ¬ë¼ì´ë“œ
    let slide = pptx.addSlide();
    slide.addText(SHEET, { x: 0.5, y: 2, w: 9, h: 1, fontSize: 36, bold: true, align: 'center' });
    slide.addText(`ì´ ${sheetData.data.length}ê°œ í–‰`, { x: 0.5, y: 3, w: 9, h: 0.5, fontSize: 18, align: 'center', color: '666666' });
    
    // ë°ì´í„° í…Œì´ë¸” ìŠ¬ë¼ì´ë“œ (50í–‰ì”©)
    const rowsPerSlide = 15;
    for (let i = 0; i < sheetData.data.length; i += rowsPerSlide) {
        slide = pptx.addSlide();
        
        const tableData = [sheetData.headers];
        const chunk = sheetData.data.slice(i, i + rowsPerSlide);
        chunk.forEach(row => tableData.push(row.map(cell => String(cell || ''))));
        
        slide.addTable(tableData, {
            x: 0.3, y: 0.5, w: 9.4,
            fontSize: 9,
            border: { pt: 0.5, color: 'CCCCCC' },
            colW: Array(sheetData.headers.length).fill(9.4 / sheetData.headers.length),
            rowH: 0.4,
            valign: 'middle',
            fontFace: 'Arial'
        });
    }
    
    pptx.writeFile({ fileName: fileName + '.pptx' });
}

// DOCX ë‚´ë³´ë‚´ê¸°
async function exportToDocx(sheetData, fileName) {
    const { Document, Packer, Paragraph, Table, TableRow, TableCell, TextRun, WidthType, BorderStyle } = docx;
    
    // í…Œì´ë¸” í–‰ ìƒì„±
    const tableRows = [];
    
    // í—¤ë” í–‰
    const headerCells = sheetData.headers.map(h => new TableCell({
        children: [new Paragraph({ children: [new TextRun({ text: String(h), bold: true })] })],
        shading: { fill: '2D8C9E' }
    }));
    tableRows.push(new TableRow({ children: headerCells }));
    
    // ë°ì´í„° í–‰
    sheetData.data.forEach(row => {
        const cells = row.map(cell => new TableCell({
            children: [new Paragraph(String(cell || ''))]
        }));
        tableRows.push(new TableRow({ children: cells }));
    });
    
    const doc = new Document({
        sections: [{
            children: [
                new Paragraph({
                    children: [new TextRun({ text: SHEET, bold: true, size: 32 })]
                }),
                new Paragraph({ text: '' }),
                new Table({
                    rows: tableRows,
                    width: { size: 100, type: WidthType.PERCENTAGE }
                })
            ]
        }]
    });
    
    const blob = await Packer.toBlob(doc);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName + '.docx';
    a.click();
    URL.revokeObjectURL(url);
}

// TXT ë‚´ë³´ë‚´ê¸°
function exportToTxt(sheetData, fileName) {
    let text = sheetData.headers.join('\t') + '\n';
    sheetData.data.forEach(row => {
        text += row.map(cell => String(cell || '')).join('\t') + '\n';
    });
    
    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName + '.txt';
    a.click();
    URL.revokeObjectURL(url);
}

// ===== 7. ìƒˆ ë¬¸ì„œ ë§Œë“¤ê¸° =====
function showNewDocModal() {
    const modalHtml = `
        <div class="modal-overlay new-doc-modal show" id="newDocModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>ìƒˆ ë¬¸ì„œ ë§Œë“¤ê¸°</h3>
                    <button class="modal-close" onclick="closeNewDocModal()">Ã—</button>
                </div>
                <p style="color: var(--retro-warm-gray); font-size: 13px; margin-bottom: 15px;">ë§Œë“¤ ë¬¸ì„œ ìœ í˜•ì„ ì„ íƒí•˜ì„¸ìš”</p>
                <div class="new-doc-types">
                    <div class="new-doc-type" onclick="createNewDocument('xlsx')">
                        <span class="new-doc-type-icon">ğŸ“—</span>
                        <span class="new-doc-type-label">ì—‘ì…€ ì‹œíŠ¸</span>
                    </div>
                    <div class="new-doc-type" onclick="createNewDocument('pdf')">
                        <span class="new-doc-type-icon">ğŸ“•</span>
                        <span class="new-doc-type-label">PDF ë¬¸ì„œ</span>
                    </div>
                    <div class="new-doc-type" onclick="createNewDocument('pptx')">
                        <span class="new-doc-type-icon">ğŸ“™</span>
                        <span class="new-doc-type-label">PowerPoint</span>
                    </div>
                    <div class="new-doc-type" onclick="createNewDocument('docx')">
                        <span class="new-doc-type-icon">ğŸ“˜</span>
                        <span class="new-doc-type-label">Word ë¬¸ì„œ</span>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="modal-btn" onclick="closeNewDocModal()">ì·¨ì†Œ</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeNewDocModal() {
    const modal = document.getElementById('newDocModal');
    if (modal) modal.remove();
}

function createNewDocument(type) {
    closeNewDocModal();
    
    if (type === 'xlsx') {
        // ìƒˆ ì—‘ì…€ ì‹œíŠ¸ ìƒì„±
        const name = prompt('ìƒˆ ì‹œíŠ¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', 'ìƒˆì‹œíŠ¸');
        if (!name) return;
        
        let sheetName = name;
        if (WB[sheetName]) {
            let suffix = 2;
            while (WB[`${sheetName}(${suffix})`]) suffix++;
            sheetName = `${sheetName}(${suffix})`;
        }
        
        WB[sheetName] = {
            headers: ['ì—´1', 'ì—´2', 'ì—´3', 'ì—´4', 'ì—´5'],
            data: []
        };
        COL_ORDER[sheetName] = [0, 1, 2, 3, 4];
        HIDDEN_COLS[sheetName] = new Set();
        SHEET = sheetName;
        
        renderMainScreen();
        toast(`'${sheetName}' ì‹œíŠ¸ ìƒì„±ë¨`);
    } else {
        // ë‹¤ë¥¸ ë¬¸ì„œ íƒ€ì…ì€ ë¹ˆ ì‹œíŠ¸ ìƒì„± í›„ í•´ë‹¹ í˜•ì‹ìœ¼ë¡œ ë‚´ë³´ë‚´ê¸° ì•ˆë‚´
        toast(`${type.toUpperCase()} ë¬¸ì„œë¥¼ ë§Œë“¤ë ¤ë©´ ë¨¼ì € ì‹œíŠ¸ì— ë‚´ìš©ì„ ì…ë ¥í•œ í›„ ë‚´ë³´ë‚´ê¸°ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”`);
    }
}

// ===== 8. íŒŒì¼ ë³´ê´€í•¨ ì„œë²„ ì €ì¥ =====
async function loadFilesFromFirestore() {
    if (!db || !currentUser) return;
    
    try {
        const snapshot = await db.collection('userFiles')
            .where('userId', '==', currentUser.uid)
            .orderBy('uploadedAt', 'desc')
            .get();
        
        fileStorage = [];
        const updatePromises = [];
        
        snapshot.docs.forEach(doc => {
            const data = doc.data();
            data.id = doc.id;
            data.isLocal = false; // ì„œë²„ì—ì„œ ë¶ˆëŸ¬ì˜¨ íŒŒì¼
            fileStorage.push(data);
            
            // ì„œë²„ íŒŒì¼ì˜ folderIdë¥¼ fileToFolderì— ë°˜ì˜
            if (data.folderId) {
                fileToFolder[doc.id] = data.folderId;
            } else {
                // ë¡œì»¬ì— ë§¤í•‘ì´ ìˆëŠ”ë° ì„œë²„ì— folderIdê°€ ì—†ìœ¼ë©´ ì„œë²„ ì—…ë°ì´íŠ¸
                const localFolderId = fileToFolder[doc.id];
                if (localFolderId) {
                    data.folderId = localFolderId;
                    updatePromises.push(
                        db.collection('userFiles').doc(doc.id).update({ folderId: localFolderId })
                            .catch(e => console.log('íŒŒì¼ folderId ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', e))
                    );
                }
            }
        });
        
        // ì„œë²„ ì—…ë°ì´íŠ¸ ì‹¤í–‰
        if (updatePromises.length > 0) {
            await Promise.all(updatePromises);
            console.log(`ì„œë²„ íŒŒì¼ ${updatePromises.length}ê°œ folderId ë³µêµ¬ ì™„ë£Œ`);
        }
        
        // ë³€ê²½ëœ ë§¤í•‘ ì €ì¥
        saveFileFolderData();
        
        renderFileStoragePanel();
    } catch (error) {
        console.error('íŒŒì¼ ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', error);
    }
}

// ===== 9. ë©”ì¸ íƒ­ ì „í™˜ (ì‹œíŠ¸/íŒŒì¼ë³´ê´€í•¨/ì›ë³¸íŒŒì¼) =====
function switchMainTab(tab) {
    currentMainTab = tab;

    document.querySelectorAll('.main-tab').forEach(t => t.classList.remove('active'));
    document.querySelector(`.main-tab[data-tab="${tab}"]`)?.classList.add('active');

    const sheetsContainer = document.getElementById('sheetsContainer');
    const filesContainer = document.getElementById('fileStorageContainer');
    const rawFilesContainer = document.getElementById('rawFilesContainer');

    // ì‹œíŠ¸ ëª©ë¡ í—¤ë”ì˜ ì‹œíŠ¸ ì „ìš© ìš”ì†Œë“¤
    const sheetCountBadge = document.getElementById('sheetCountBadge');
    const sheetFavoriteFilter = document.querySelector('.sheet-list-header .favorite-filter');
    const sheetViewModeToggle = document.querySelector('.sheet-list-header .view-mode-toggle');
    const sheetListActions = document.querySelector('.sheet-list-actions');

    // ëª¨ë“  ì»¨í…Œì´ë„ˆ ìˆ¨ê¹€
    if (sheetsContainer) sheetsContainer.style.display = 'none';
    if (filesContainer) filesContainer.style.display = 'none';
    if (rawFilesContainer) rawFilesContainer.style.display = 'none';

    // í—¤ë” ìš”ì†Œë“¤ ê¸°ë³¸ ìˆ¨ê¹€
    if (sheetCountBadge) sheetCountBadge.style.display = 'none';
    if (sheetFavoriteFilter) sheetFavoriteFilter.style.display = 'none';
    if (sheetViewModeToggle) sheetViewModeToggle.style.display = 'none';
    if (sheetListActions) sheetListActions.style.display = 'none';

    if (tab === 'sheets') {
        if (sheetsContainer) sheetsContainer.style.display = '';
        // ì‹œíŠ¸ ëª©ë¡ í—¤ë” ìš”ì†Œë“¤ í‘œì‹œ
        if (sheetCountBadge) sheetCountBadge.style.display = '';
        if (sheetFavoriteFilter) sheetFavoriteFilter.style.display = '';
        if (sheetViewModeToggle) sheetViewModeToggle.style.display = '';
        if (sheetListActions) sheetListActions.style.display = '';
    } else if (tab === 'files') {
        if (filesContainer) filesContainer.style.display = '';
        // íŒŒì¼ íƒ­ ì „í™˜ ì‹œ ìºì‹œ ë¬´íš¨í™” í›„ ë Œë”ë§
        invalidateFileRenderCache();
        renderFileStoragePanel();
    } else if (tab === 'rawfiles') {
        if (rawFilesContainer) rawFilesContainer.style.display = '';
        renderRawFilesList();
    }
}

// ===== 10. ì›ë³¸ íŒŒì¼ ê¸°ëŠ¥ =====

// ì›ë³¸ íŒŒì¼ í•„í„°/ì •ë ¬ í•¨ìˆ˜
function filterAndSortRawFiles() {
    let fileNames = Object.keys(rawFiles);

    // ê²€ìƒ‰ì–´ í•„í„°ë§
    if (rawFileSearchKeyword) {
        const keyword = rawFileSearchKeyword.toLowerCase();
        fileNames = fileNames.filter(name =>
            name.toLowerCase().includes(keyword) ||
            (rawFiles[name].displayName && rawFiles[name].displayName.toLowerCase().includes(keyword))
        );
    }

    // ì •ë ¬
    fileNames.sort((a, b) => {
        let valA, valB;
        switch (rawFileSortBy) {
            case 'name':
                valA = a.toLowerCase();
                valB = b.toLowerCase();
                break;
            case 'lastUpdated':
                valA = new Date(rawFiles[a].lastUpdated || 0);
                valB = new Date(rawFiles[b].lastUpdated || 0);
                break;
            case 'totalRows':
                valA = rawFiles[a].totalRows || 0;
                valB = rawFiles[b].totalRows || 0;
                break;
            default:
                valA = a;
                valB = b;
        }
        const cmp = valA < valB ? -1 : valA > valB ? 1 : 0;
        return rawFileSortOrder === 'asc' ? cmp : -cmp;
    });

    return fileNames;
}

// ì •ë ¬ ì„¤ì • ë³€ê²½
function setRawFileSort(value) {
    const [sortBy, sortOrder] = value.split('-');
    rawFileSortBy = sortBy;
    rawFileSortOrder = sortOrder;
    renderRawFilesList();
}

// ë·° ëª¨ë“œ ì„¤ì • ë³€ê²½
function setRawFileViewMode(mode) {
    rawFileViewMode = mode;
    // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    document.querySelectorAll('.raw-file-view-btn').forEach(btn => btn.classList.remove('active'));
    const btnId = mode === 'list' ? 'rawFileListViewBtn' : mode === 'card' ? 'rawFileCardViewBtn' : 'rawFileIconViewBtn';
    const btn = document.getElementById(btnId);
    if (btn) btn.classList.add('active');
    renderRawFilesList();
}

// ì›ë³¸ íŒŒì¼ ëª©ë¡ ë Œë”ë§
function renderRawFilesList() {
    const container = document.getElementById('rawFilesList');
    if (!container) return;

    const allFileNames = Object.keys(rawFiles);
    let fileNames = filterAndSortRawFiles();

    // í˜„ì¬ í´ë”ì— ë”°ë¼ íŒŒì¼ í•„í„°ë§ (ê²€ìƒ‰ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
    if (!rawFileSearchKeyword) {
        if (currentRawFolderId) {
            fileNames = fileNames.filter(name => rawFileToFolder[name] === currentRawFolderId);
        } else {
            fileNames = fileNames.filter(name => !rawFileToFolder[name]);
        }
    }

    // íŒŒì¼ ê°œìˆ˜ í‘œì‹œ ì—…ë°ì´íŠ¸
    const countEl = document.querySelector('.raw-file-count');
    if (countEl) {
        if (rawFileSearchKeyword && fileNames.length !== allFileNames.length) {
            countEl.textContent = `${fileNames.length}/${allFileNames.length}ê°œ íŒŒì¼`;
        } else if (currentRawFolderId) {
            const folderName = rawFileFolders[currentRawFolderId]?.name || 'í´ë”';
            countEl.textContent = `${folderName}: ${fileNames.length}ê°œ`;
        } else {
            countEl.textContent = `${allFileNames.length}ê°œ íŒŒì¼`;
        }
    }

    // ë·° ëª¨ë“œ í´ë˜ìŠ¤ ì ìš©
    container.classList.remove('list-view', 'card-view', 'icon-view');
    container.classList.add(rawFileViewMode + '-view');

    // í˜„ì¬ í´ë” ì •ë³´ ë° ë’¤ë¡œê°€ê¸° ë²„íŠ¼
    let folderNavHtml = '';
    if (currentRawFolderId && !rawFileSearchKeyword) {
        const currentFolder = rawFileFolders[currentRawFolderId];
        folderNavHtml = `
            <div class="raw-folder-nav">
                <button class="raw-folder-back-btn" onclick="goToRawFileRoot()">
                    â† ë£¨íŠ¸ë¡œ
                </button>
                <span class="raw-folder-current" style="color: ${currentFolder?.color || '#666'}">
                    ğŸ“ ${escHtml(currentFolder?.name || 'í´ë”')}
                </span>
            </div>
        `;
    }

    if (allFileNames.length === 0 && Object.keys(rawFileFolders).length === 0) {
        container.innerHTML = `
            <div class="raw-files-empty">
                <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“Š</div>
                <div>ì›ë³¸ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>
                <div style="font-size: 12px; margin-top: 8px;">ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ë°ì´í„°ê°€ ëˆ„ì ë©ë‹ˆë‹¤</div>
            </div>
        `;
        return;
    }

    if (fileNames.length === 0 && rawFileSearchKeyword) {
        container.innerHTML = `
            <div class="raw-files-empty">
                <div style="font-size: 48px; margin-bottom: 15px;">ğŸ”</div>
                <div>ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤</div>
                <div style="font-size: 12px; margin-top: 8px;">"${escHtml(rawFileSearchKeyword)}"ì™€ ì¼ì¹˜í•˜ëŠ” íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>
            </div>
        `;
        return;
    }

    // ì„ íƒ ëª¨ë“œ í´ë˜ìŠ¤ ì ìš©
    container.classList.toggle('select-mode', rawFileSelectMode);

    let html = folderNavHtml;

    // í´ë” ë Œë”ë§ (ë£¨íŠ¸ì—ì„œë§Œ, ê²€ìƒ‰ ì¤‘ ì•„ë‹ ë•Œë§Œ)
    if (!currentRawFolderId && !rawFileSearchKeyword) {
        const folders = Object.entries(rawFileFolders);
        if (folders.length > 0) {
            html += '<div class="raw-folder-section">';
            folders.forEach(([folderId, folder]) => {
                const fileCount = getRawFileFolderCount(folderId);
                if (rawFileViewMode === 'icon') {
                    html += `
                        <div class="raw-folder-icon-item" ondblclick="openRawFileFolder('${folderId}')" oncontextmenu="showRawFolderContextMenu(event, '${folderId}')">
                            <div class="raw-folder-icon-img" style="color: ${folder.color}">ğŸ“</div>
                            <div class="raw-folder-icon-name" title="${escHtml(folder.name)}">${escHtml(folder.name)}</div>
                            <div class="raw-folder-icon-count">${fileCount}ê°œ íŒŒì¼</div>
                        </div>
                    `;
                } else if (rawFileViewMode === 'card') {
                    html += `
                        <div class="raw-folder-card" ondblclick="openRawFileFolder('${folderId}')" oncontextmenu="showRawFolderContextMenu(event, '${folderId}')">
                            <div class="raw-folder-card-header">
                                <span class="raw-folder-card-icon" style="color: ${folder.color}">ğŸ“</span>
                                <span class="raw-folder-card-name">${escHtml(folder.name)}</span>
                            </div>
                            <div class="raw-folder-card-meta">${fileCount}ê°œ íŒŒì¼</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="raw-folder-item" ondblclick="openRawFileFolder('${folderId}')" oncontextmenu="showRawFolderContextMenu(event, '${folderId}')">
                            <div class="raw-folder-icon" style="color: ${folder.color}">ğŸ“</div>
                            <div class="raw-folder-info">
                                <div class="raw-folder-name">${escHtml(folder.name)}</div>
                                <div class="raw-folder-meta">${fileCount}ê°œ íŒŒì¼</div>
                            </div>
                            <div class="raw-folder-actions">
                                <button class="raw-file-btn" onclick="event.stopPropagation(); startRenameRawFolder('${folderId}')" title="ì´ë¦„ ë³€ê²½">âœï¸</button>
                                <button class="raw-file-btn danger" onclick="event.stopPropagation(); deleteRawFileFolder('${folderId}')" title="ì‚­ì œ">ğŸ—‘ï¸</button>
                            </div>
                        </div>
                    `;
                }
            });
            html += '</div>';

            // í´ë”ì™€ íŒŒì¼ êµ¬ë¶„ì„ 
            if (fileNames.length > 0) {
                html += '<div class="raw-folder-divider"></div>';
            }
        }
    }

    // ë¹ˆ í´ë” ë˜ëŠ” ë£¨íŠ¸ê°€ ë¹„ì–´ìˆì„ ë•Œ
    if (fileNames.length === 0 && !rawFileSearchKeyword) {
        if (currentRawFolderId) {
            html += `
                <div class="raw-files-empty">
                    <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“‚</div>
                    <div>í´ë”ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</div>
                    <div style="font-size: 12px; margin-top: 8px;">íŒŒì¼ì„ ì´ í´ë”ë¡œ ì´ë™í•´ë³´ì„¸ìš”</div>
                </div>
            `;
        }
        container.innerHTML = html;
        return;
    }

    fileNames.forEach(fileName => {
        const fileData = rawFiles[fileName];
        const sheetNames = Object.keys(fileData.sheets);
        const totalRows = fileData.totalRows || 0;
        const lastUpdated = fileData.lastUpdated ? new Date(fileData.lastUpdated).toLocaleString('ko-KR') : '-';
        const isActive = currentRawFile === fileName;
        const isSelected = selectedRawFiles.has(fileName);
        const safeFileName = fileName.replace(/'/g, "\\'");
        const checkboxHtml = rawFileSelectMode ? `<input type="checkbox" class="raw-file-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleRawFileSelection('${safeFileName}')">` : '';
        const linkedCount = getLinkedSheetCount(fileName);
        const linkedBadge = linkedCount > 0 ? `<span class="linked-sheet-badge" title="ì—°ê²°ëœ ì‹œíŠ¸ ${linkedCount}ê°œ">ğŸ”—${linkedCount}</span>` : '';

        if (rawFileViewMode === 'icon') {
            // ì•„ì´ì½˜ ë·°
            html += `
                <div class="raw-file-icon-item ${isActive ? 'active' : ''} ${isSelected ? 'selected' : ''}" onclick="${rawFileSelectMode ? `toggleRawFileSelection('${safeFileName}')` : `selectRawFile('${safeFileName}')`}">
                    ${checkboxHtml}
                    <div class="raw-file-icon-img">ğŸ“Š</div>
                    <div class="raw-file-icon-name" title="${escHtml(fileName)}">${escHtml(fileName)}</div>
                    <div class="raw-file-icon-count">${totalRows.toLocaleString()}í–‰</div>
                </div>
            `;
        } else if (rawFileViewMode === 'card') {
            // ì¹´ë“œ ë·°
            html += `
                <div class="raw-file-card ${isActive ? 'active' : ''} ${isSelected ? 'selected' : ''}" onclick="${rawFileSelectMode ? `toggleRawFileSelection('${safeFileName}')` : `selectRawFile('${safeFileName}')`}">
                    ${checkboxHtml}
                    <div class="raw-file-card-header">
                        <span class="raw-file-card-icon">ğŸ“Š</span>
                        <span class="raw-file-card-name" title="${escHtml(fileName)}">${escHtml(fileName)}</span>
                        ${linkedBadge}
                    </div>
                    <div class="raw-file-card-meta">
                        <div>ğŸ“ ${totalRows.toLocaleString()}í–‰</div>
                        <div>ğŸ“‘ ${sheetNames.length}ê°œ ì‹œíŠ¸</div>
                    </div>
                    <div class="raw-file-card-date">ğŸ“… ${lastUpdated}</div>
                    ${!rawFileSelectMode ? `<div class="raw-file-card-actions">
                        <button onclick="event.stopPropagation(); showStatisticsModal('${safeFileName}')" title="í†µê³„">ğŸ“Š</button>
                        <button onclick="event.stopPropagation(); showDuplicateDetectionModal('${safeFileName}')" title="ì¤‘ë³µ íƒì§€">ğŸ”</button>
                        <button onclick="event.stopPropagation(); showDataCleaningModal('${safeFileName}')" title="ë°ì´í„° ì •ì œ">ğŸ§¹</button>
                        <button class="copy-to-sheet" onclick="event.stopPropagation(); copyRawFileToSheets('${safeFileName}')" title="ì‹œíŠ¸ë¡œ ë³µì‚¬">ğŸ“‘</button>
                        <button onclick="event.stopPropagation(); downloadRawFile('${safeFileName}')">ë‹¤ìš´ë¡œë“œ</button>
                        <button class="danger" onclick="event.stopPropagation(); deleteRawFile('${safeFileName}')">ì‚­ì œ</button>
                    </div>` : ''}
                </div>
            `;
        } else {
            // ë¦¬ìŠ¤íŠ¸ ë·° (ê¸°ë³¸)
            html += `
                <div class="raw-file-item ${isActive ? 'active' : ''} ${isSelected ? 'selected' : ''}" onclick="${rawFileSelectMode ? `toggleRawFileSelection('${safeFileName}')` : `selectRawFile('${safeFileName}')`}">
                    ${checkboxHtml}
                    <div class="raw-file-icon">ğŸ“Š</div>
                    <div class="raw-file-info">
                        <div class="raw-file-name">${escHtml(fileName)} ${linkedBadge}</div>
                        <div class="raw-file-meta">
                            <span>ğŸ“… ${lastUpdated}</span>
                            <span>ğŸ“ ${totalRows.toLocaleString()}í–‰</span>
                            <span>ğŸ“‘ ${sheetNames.length}ê°œ ì‹œíŠ¸</span>
                        </div>
                        <div class="raw-file-sheets">
                            ${sheetNames.map(sn => {
                                const sheetData = fileData.sheets[sn];
                                const rowCount = sheetData.data ? sheetData.data.length : 0;
                                const safeSheetName = sn.replace(/'/g, "\\'");
                                return `<span class="raw-file-sheet-badge" onclick="event.stopPropagation(); selectRawFileSheet('${safeFileName}', '${safeSheetName}')">${escHtml(sn)} (${rowCount}í–‰)</span>`;
                            }).join('')}
                        </div>
                    </div>
                    ${!rawFileSelectMode ? `<div class="raw-file-actions">
                        <button class="raw-file-btn" onclick="event.stopPropagation(); showStatisticsModal('${safeFileName}')" title="í†µê³„">ğŸ“Š</button>
                        <button class="raw-file-btn" onclick="event.stopPropagation(); showDuplicateDetectionModal('${safeFileName}')" title="ì¤‘ë³µ íƒì§€">ğŸ”</button>
                        <button class="raw-file-btn" onclick="event.stopPropagation(); showDataCleaningModal('${safeFileName}')" title="ë°ì´í„° ì •ì œ">ğŸ§¹</button>
                        <button class="raw-file-btn copy-to-sheet" onclick="event.stopPropagation(); copyRawFileToSheets('${safeFileName}')" title="ì‹œíŠ¸ë¡œ ë³µì‚¬">ğŸ“‘</button>
                        <button class="raw-file-btn" onclick="event.stopPropagation(); showRawFileHistory('${safeFileName}')" title="ì—…ë¡œë“œ ì´ë ¥">ğŸ“‹</button>
                        <button class="raw-file-btn" onclick="event.stopPropagation(); downloadRawFile('${safeFileName}')">ë‹¤ìš´ë¡œë“œ</button>
                        <button class="raw-file-btn danger" onclick="event.stopPropagation(); deleteRawFile('${safeFileName}')">ì‚­ì œ</button>
                    </div>` : ''}
                </div>
            `;
        }
    });

    container.innerHTML = html;
    updateRawFileSelectedCount();

    // í˜¸ë²„ ë¯¸ë¦¬ë³´ê¸° ì´ë²¤íŠ¸ ì„¤ì •
    if (!rawFileSelectMode) {
        setupRawFileHoverPreview();
    }
}

// ===== ì›ë³¸ íŒŒì¼ ì„ íƒ ëª¨ë“œ =====

// ì„ íƒ ëª¨ë“œ í† ê¸€
function toggleRawFileSelectMode() {
    rawFileSelectMode = !rawFileSelectMode;
    const btn = document.getElementById('rawFileSelectModeBtn');
    const actionBar = document.getElementById('rawFilesActionBar');

    if (btn) {
        btn.classList.toggle('active', rawFileSelectMode);
        btn.textContent = rawFileSelectMode ? 'ì·¨ì†Œ' : 'ì„ íƒ';
    }
    if (actionBar) {
        actionBar.style.display = rawFileSelectMode ? 'flex' : 'none';
    }

    if (!rawFileSelectMode) {
        selectedRawFiles.clear();
    }

    renderRawFilesList();
}

// íŒŒì¼ ì„ íƒ í† ê¸€
function toggleRawFileSelection(fileName) {
    if (selectedRawFiles.has(fileName)) {
        selectedRawFiles.delete(fileName);
    } else {
        selectedRawFiles.add(fileName);
    }
    renderRawFilesList();
}

// ì „ì²´ ì„ íƒ
function selectAllRawFiles() {
    const fileNames = filterAndSortRawFiles();
    fileNames.forEach(name => selectedRawFiles.add(name));
    renderRawFilesList();
}

// ì„ íƒ í•´ì œ
function deselectAllRawFiles() {
    selectedRawFiles.clear();
    renderRawFilesList();
}

// ì„ íƒ ê°œìˆ˜ ì—…ë°ì´íŠ¸
function updateRawFileSelectedCount() {
    const countEl = document.querySelector('.raw-file-selected-count');
    if (countEl) {
        countEl.textContent = `${selectedRawFiles.size}ê°œ ì„ íƒ`;
    }
}

// ì„ íƒëœ íŒŒì¼ ì¼ê´„ ì‚­ì œ
function deleteSelectedRawFiles() {
    if (selectedRawFiles.size === 0) {
        toast('ì‚­ì œí•  íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”');
        return;
    }

    if (!confirm(`ì„ íƒí•œ ${selectedRawFiles.size}ê°œ íŒŒì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;

    selectedRawFiles.forEach(fileName => {
        delete rawFiles[fileName];
    });

    toast(`${selectedRawFiles.size}ê°œ íŒŒì¼ ì‚­ì œ ì™„ë£Œ`);
    selectedRawFiles.clear();
    saveRawFilesToLocalStorage();
    toggleRawFileSelectMode();
}

// ì„ íƒëœ íŒŒì¼ ì¼ê´„ ë‹¤ìš´ë¡œë“œ
async function downloadSelectedRawFiles() {
    if (selectedRawFiles.size === 0) {
        toast('ë‹¤ìš´ë¡œë“œí•  íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”');
        return;
    }

    if (selectedRawFiles.size === 1) {
        // ë‹¨ì¼ íŒŒì¼ì€ ë°”ë¡œ ë‹¤ìš´ë¡œë“œ
        const fileName = [...selectedRawFiles][0];
        downloadRawFile(fileName);
        return;
    }

    // ì—¬ëŸ¬ íŒŒì¼ì€ ìˆœì°¨ ë‹¤ìš´ë¡œë“œ
    toast(`${selectedRawFiles.size}ê°œ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘...`);

    for (const fileName of selectedRawFiles) {
        downloadRawFile(fileName);
        await new Promise(r => setTimeout(r, 500)); // ê°„ê²© ë‘ê¸°
    }

    toast(`${selectedRawFiles.size}ê°œ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
}

// ===== í´ë” ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ë° ì´ë¦„ ë³€ê²½ =====

// í´ë” ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ
function showRawFolderContextMenu(event, folderId) {
    event.preventDefault();
    event.stopPropagation();

    // ê¸°ì¡´ ë©”ë‰´ ì œê±°
    const existingMenu = document.querySelector('.raw-folder-context-menu');
    if (existingMenu) existingMenu.remove();

    const folder = rawFileFolders[folderId];
    if (!folder) return;

    const menu = document.createElement('div');
    menu.className = 'raw-folder-context-menu';
    menu.style.cssText = `
        position: fixed;
        left: ${event.clientX}px;
        top: ${event.clientY}px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 10000;
        min-width: 150px;
        padding: 5px 0;
    `;

    menu.innerHTML = `
        <div class="ctx-menu-item" onclick="openRawFileFolder('${folderId}'); this.parentElement.remove();">
            ğŸ“‚ ì—´ê¸°
        </div>
        <div class="ctx-menu-item" onclick="startRenameRawFolder('${folderId}'); this.parentElement.remove();">
            âœï¸ ì´ë¦„ ë³€ê²½
        </div>
        <div class="ctx-menu-divider"></div>
        <div class="ctx-menu-item" onclick="showRawFolderColorPicker('${folderId}'); this.parentElement.remove();">
            ğŸ¨ ìƒ‰ìƒ ë³€ê²½
        </div>
        <div class="ctx-menu-divider"></div>
        <div class="ctx-menu-item danger" onclick="deleteRawFileFolder('${folderId}'); this.parentElement.remove();">
            ğŸ—‘ï¸ ì‚­ì œ
        </div>
    `;

    document.body.appendChild(menu);

    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡ ì¡°ì •
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) {
        menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
    }
    if (rect.bottom > window.innerHeight) {
        menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
    }

    // ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
    setTimeout(() => {
        document.addEventListener('click', function closeMenu(e) {
            if (!menu.contains(e.target)) {
                menu.remove();
                document.removeEventListener('click', closeMenu);
            }
        });
    }, 0);
}

// í´ë” ì´ë¦„ ë³€ê²½ ì‹œì‘
function startRenameRawFolder(folderId) {
    const folder = rawFileFolders[folderId];
    if (!folder) return;

    const newName = prompt('ìƒˆ í´ë” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', folder.name);
    if (newName && newName.trim() && newName.trim() !== folder.name) {
        renameRawFileFolder(folderId, newName.trim());
    }
}

// í´ë” ìƒ‰ìƒ ì„ íƒ ëª¨ë‹¬
function showRawFolderColorPicker(folderId) {
    const folder = rawFileFolders[folderId];
    if (!folder) return;

    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.innerHTML = `
        <div class="history-modal-content" style="max-width: 300px;">
            <div class="history-modal-header">
                <h3>ğŸ¨ í´ë” ìƒ‰ìƒ</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body" style="padding: 20px;">
                <div class="color-picker-grid">
                    ${RAW_FOLDER_COLORS.map(color => `
                        <div class="color-picker-item ${folder.color === color ? 'selected' : ''}"
                             style="background: ${color}"
                             onclick="changeRawFolderColor('${folderId}', '${color}'); this.closest('.raw-file-history-modal').remove();">
                            ${folder.color === color ? 'âœ“' : ''}
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `;

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);
}

// ===== í˜¸ë²„ ë¯¸ë¦¬ë³´ê¸° =====
let rawFilePreviewTimeout = null;

function setupRawFileHoverPreview() {
    const items = document.querySelectorAll('.raw-file-item, .raw-file-card');
    items.forEach(item => {
        const fileName = item.querySelector('.raw-file-name')?.textContent ||
                        item.querySelector('.raw-file-card-name')?.textContent;
        if (!fileName) return;

        item.addEventListener('mouseenter', (e) => {
            rawFilePreviewTimeout = setTimeout(() => {
                showRawFilePreview(fileName, e);
            }, 500); // 0.5ì´ˆ í›„ í‘œì‹œ
        });

        item.addEventListener('mouseleave', () => {
            clearTimeout(rawFilePreviewTimeout);
            hideRawFilePreview();
        });
    });
}

function showRawFilePreview(fileName, event) {
    const file = rawFiles[fileName];
    if (!file) return;

    // ê¸°ì¡´ ë¯¸ë¦¬ë³´ê¸° ì œê±°
    hideRawFilePreview();

    const firstSheetName = Object.keys(file.sheets)[0];
    if (!firstSheetName) return;

    const sheet = file.sheets[firstSheetName];
    const previewRows = (sheet.data || []).slice(0, 8);
    const headers = sheet.headers || [];

    const preview = document.createElement('div');
    preview.className = 'raw-file-preview-popup';
    preview.innerHTML = `
        <div class="preview-title">${escHtml(fileName)} - ${escHtml(firstSheetName)}</div>
        <table class="preview-table">
            <thead><tr>${headers.slice(0, 6).map(h => `<th>${escHtml(h)}</th>`).join('')}${headers.length > 6 ? '<th>...</th>' : ''}</tr></thead>
            <tbody>${previewRows.map(row => `<tr>${row.slice(0, 6).map(cell => `<td>${escHtml(cell || '')}</td>`).join('')}${row.length > 6 ? '<td>...</td>' : ''}</tr>`).join('')}</tbody>
        </table>
        ${previewRows.length < (sheet.data || []).length ? `<div class="preview-more">... ì™¸ ${(sheet.data.length - previewRows.length).toLocaleString()}í–‰</div>` : ''}
    `;

    // ìœ„ì¹˜ ì„¤ì •
    const rect = event.target.closest('.raw-file-item, .raw-file-card').getBoundingClientRect();
    preview.style.left = Math.min(rect.right + 10, window.innerWidth - 420) + 'px';
    preview.style.top = Math.max(rect.top, 10) + 'px';

    document.body.appendChild(preview);
}

function hideRawFilePreview() {
    const existing = document.querySelector('.raw-file-preview-popup');
    if (existing) existing.remove();
}

// ===== ì—…ë¡œë“œ ì´ë ¥ ëª¨ë‹¬ =====
function showRawFileHistory(fileName) {
    const file = rawFiles[fileName];
    if (!file) return;

    // ëª¨ë“  ì‹œíŠ¸ì˜ ì—…ë¡œë“œ ì´ë ¥ ìˆ˜ì§‘
    let allHistory = [];
    Object.keys(file.sheets).forEach(sheetName => {
        const sheet = file.sheets[sheetName];
        if (sheet.uploadHistory && sheet.uploadHistory.length > 0) {
            sheet.uploadHistory.forEach(h => {
                allHistory.push({
                    ...h,
                    sheetName: sheetName
                });
            });
        }
    });

    // ë‚ ì§œìˆœ ì •ë ¬ (ìµœì‹ ìˆœ)
    allHistory.sort((a, b) => new Date(b.date) - new Date(a.date));

    // ì´ë ¥ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì •ë³´ í‘œì‹œ
    if (allHistory.length === 0) {
        allHistory = [{
            date: file.lastUpdated || new Date().toISOString(),
            rowCount: file.totalRows || 0,
            sheetName: 'ì „ì²´',
            note: 'ì´ˆê¸° ì—…ë¡œë“œ'
        }];
    }

    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.innerHTML = `
        <div class="history-modal-content">
            <div class="history-modal-header">
                <h3>ğŸ“‹ ì—…ë¡œë“œ ì´ë ¥ - ${escHtml(fileName)}</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body">
                <div class="history-summary">
                    <div class="history-stat"><span class="stat-label">ì´ í–‰ ìˆ˜</span><span class="stat-value">${(file.totalRows || 0).toLocaleString()}í–‰</span></div>
                    <div class="history-stat"><span class="stat-label">ì‹œíŠ¸ ìˆ˜</span><span class="stat-value">${Object.keys(file.sheets).length}ê°œ</span></div>
                    <div class="history-stat"><span class="stat-label">ì—…ë¡œë“œ íšŸìˆ˜</span><span class="stat-value">${allHistory.length}íšŒ</span></div>
                </div>
                <div class="history-list">
                    ${allHistory.map((h, idx) => `
                        <div class="history-item">
                            <div class="history-date">${new Date(h.date).toLocaleString('ko-KR')}</div>
                            <div class="history-detail">
                                <span class="history-sheet">${escHtml(h.sheetName)}</span>
                                <span class="history-rows">+${(h.rowCount || 0).toLocaleString()}í–‰</span>
                                ${h.sourceFile ? `<span class="history-source">${escHtml(h.sourceFile)}</span>` : ''}
                                ${h.note ? `<span class="history-note">${escHtml(h.note)}</span>` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
    `;

    // ë°°ê²½ í´ë¦­ ì‹œ ë‹«ê¸°
    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);
}

// ========== ì›ë³¸â†’ì‹œíŠ¸ ì—°ë™ ê¸°ëŠ¥ ==========

// ì›ë³¸ íŒŒì¼ì„ ì‹œíŠ¸ ëª©ë¡(WB)ìœ¼ë¡œ ë³µì‚¬
function copyRawFileToSheets(fileName) {
    if (!rawFiles[fileName]) {
        showToast('íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    const file = rawFiles[fileName];
    const sheetNames = Object.keys(file.sheets);

    if (sheetNames.length === 0) {
        showToast('ë³µì‚¬í•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    // ì‹œíŠ¸ê°€ ì—¬ëŸ¬ ê°œì¸ ê²½ìš° ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
    if (sheetNames.length > 1) {
        showCopySheetSelectModal(fileName, sheetNames);
    } else {
        // ì‹œíŠ¸ê°€ 1ê°œì¸ ê²½ìš° ë°”ë¡œ ë³µì‚¬
        copyRawSheetToWB(fileName, sheetNames[0]);
    }
}

// ë³µì‚¬í•  ì‹œíŠ¸ ì„ íƒ ëª¨ë‹¬
function showCopySheetSelectModal(fileName, sheetNames) {
    const file = rawFiles[fileName];
    const displayName = file.displayName || fileName;

    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.innerHTML = `
        <div class="history-modal-content copy-sheet-modal">
            <div class="history-modal-header">
                <h3>ğŸ“‹ ì‹œíŠ¸ë¡œ ë³µì‚¬ - ${escHtml(displayName)}</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body">
                <p style="margin-bottom: 15px; color: #666;">ë³µì‚¬í•  ì‹œíŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”:</p>
                <div class="copy-sheet-list">
                    ${sheetNames.map(sheetName => {
                        const sheet = file.sheets[sheetName];
                        const rowCount = sheet.data ? sheet.data.length : 0;
                        return `
                            <div class="copy-sheet-item" onclick="copyRawSheetToWB('${escHtml(fileName)}', '${escHtml(sheetName)}'); this.closest('.raw-file-history-modal').remove();">
                                <span class="copy-sheet-name">ğŸ“„ ${escHtml(sheetName)}</span>
                                <span class="copy-sheet-rows">${rowCount.toLocaleString()}í–‰</span>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                    <button class="btn-copy-all" onclick="copyAllRawSheetsToWB('${escHtml(fileName)}'); this.closest('.raw-file-history-modal').remove();">
                        ğŸ“‘ ëª¨ë“  ì‹œíŠ¸ ë³µì‚¬ (${sheetNames.length}ê°œ)
                    </button>
                </div>
            </div>
        </div>
    `;

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);
}

// ë‹¨ì¼ ì‹œíŠ¸ ë³µì‚¬ (ì›ë³¸ â†’ WB)
function copyRawSheetToWB(fileName, sheetName, silent = false) {
    if (!rawFiles[fileName] || !rawFiles[fileName].sheets[sheetName]) {
        if (!silent) showToast('ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return null;
    }

    const file = rawFiles[fileName];
    const sheetData = file.sheets[sheetName];
    const displayName = file.displayName || fileName.replace(/\s*\d{4}\.\d{2}\.\d{2}/g, '').replace(/\.xlsx?$/i, '').trim() || fileName;

    // ìƒˆ ì‹œíŠ¸ëª… ìƒì„± (ì¤‘ë³µ ë°©ì§€)
    let newSheetName = `${displayName} - ${sheetName}`;
    let counter = 1;
    while (WB[newSheetName]) {
        newSheetName = `${displayName} - ${sheetName} (${counter++})`;
    }

    // í—¤ë”ì™€ ë°ì´í„° ë³µì‚¬ (ê¹Šì€ ë³µì‚¬)
    const headers = [...(sheetData.headers || [])];
    const rawData = sheetData.data || [];

    // ë‚ ì§œ ì—´ ì¸ë±ìŠ¤ ì°¾ê¸°
    const dateColIndices = new Set();
    headers.forEach((h, idx) => {
        if (h && (h.includes('ë‚ ì§œ') || h.includes('ì¼ì') || h.includes('ì¼ì‹œ') ||
                  h.includes('Date') || h.includes('date') || h.includes('DATE') ||
                  h === 'ì‘ì„±ì¼' || h === 'ì…ê¸ˆì¼' || h === 'í‡´ì‚¬ë‚ ì§œ' || h === 'ì…ì‚¬ì¼' ||
                  h === 'ì™„ë£Œì˜ˆì •ì¼' || h === 'ì˜ˆì•½ì¼ì •' || h.includes('ì˜ˆì •ì¼'))) {
            dateColIndices.add(idx);
        }
    });

    // ë°ì´í„° ì²˜ë¦¬ - ë‚ ì§œ ë³€í™˜ ì ìš©
    const processedData = rawData.map(row => {
        if (!row) return [];
        return row.map((cell, idx) => {
            if ((idx === 0 || dateColIndices.has(idx)) && cell !== '' && cell !== null && cell !== undefined) {
                return convertToKoreanDate(cell);
            }
            return cell;
        });
    });

    // WBì— ì‹œíŠ¸ ì¶”ê°€
    WB[newSheetName] = {
        headers: headers,
        data: processedData
    };
    COL_ORDER[newSheetName] = headers.map((_, i) => i);
    HIDDEN_COLS[newSheetName] = new Set();
    autoFitColumnWidths(newSheetName);

    // ì—°ê²° ì •ë³´ ì €ì¥
    if (!rawFileToSheetMapping) {
        window.rawFileToSheetMapping = {};
    }
    if (!rawFileToSheetMapping[fileName]) {
        rawFileToSheetMapping[fileName] = [];
    }
    rawFileToSheetMapping[fileName].push({
        sheetName: newSheetName,
        sourceSheet: sheetName,
        copiedAt: new Date().toISOString()
    });

    if (!silent) {
        showToast(`"${sheetName}" ì‹œíŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
    }

    return newSheetName;
}

// ëª¨ë“  ì‹œíŠ¸ ë³µì‚¬
function copyAllRawSheetsToWB(fileName) {
    if (!rawFiles[fileName]) {
        showToast('íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    const sheetNames = Object.keys(rawFiles[fileName].sheets);
    let copiedCount = 0;

    sheetNames.forEach(sheetName => {
        const result = copyRawSheetToWB(fileName, sheetName, true);
        if (result) copiedCount++;
    });

    if (copiedCount > 0) {
        showToast(`${copiedCount}ê°œ ì‹œíŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
        renderMainScreen();
        saveState();
    }
}

// ì›ë³¸ íŒŒì¼ê³¼ ì‹œíŠ¸ ì—°ê²° ìƒíƒœ í™•ì¸
function getRawFileLinkedSheets(fileName) {
    if (!rawFileToSheetMapping || !rawFileToSheetMapping[fileName]) {
        return [];
    }
    // ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ” ì‹œíŠ¸ë§Œ ë°˜í™˜
    return rawFileToSheetMapping[fileName].filter(link => WB[link.sheetName]);
}

// ì—°ê²°ëœ ì‹œíŠ¸ ìˆ˜ ê°€ì ¸ì˜¤ê¸°
function getLinkedSheetCount(fileName) {
    return getRawFileLinkedSheets(fileName).length;
}

// ========== ì›ë³¸ íŒŒì¼ í´ë” ì‹œìŠ¤í…œ ==========

// í´ë” ìƒ‰ìƒ ì˜µì…˜
const RAW_FOLDER_COLORS = [
    '#FFB74D', // ì£¼í™©
    '#4FC3F7', // í•˜ëŠ˜
    '#81C784', // ë…¹ìƒ‰
    '#F06292', // ë¶„í™
    '#BA68C8', // ë³´ë¼
    '#FFD54F', // ë…¸ë‘
    '#90A4AE', // íšŒìƒ‰
    '#A1887F', // ê°ˆìƒ‰
];

// ìƒˆ í´ë” ìƒì„±
function createRawFileFolder(name = 'ìƒˆ í´ë”') {
    const folderId = 'rf_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    rawFileFolders[folderId] = {
        name: name,
        createdAt: new Date().toISOString(),
        color: RAW_FOLDER_COLORS[Object.keys(rawFileFolders).length % RAW_FOLDER_COLORS.length]
    };
    saveRawFileFolders();
    renderRawFilesList();
    showToast(`"${name}" í´ë”ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
    return folderId;
}

// í´ë” ì‚­ì œ
function deleteRawFileFolder(folderId) {
    if (!rawFileFolders[folderId]) return;

    const folder = rawFileFolders[folderId];
    const filesInFolder = Object.keys(rawFileToFolder).filter(f => rawFileToFolder[f] === folderId);

    if (filesInFolder.length > 0) {
        if (!confirm(`"${folder.name}" í´ë”ì— ${filesInFolder.length}ê°œì˜ íŒŒì¼ì´ ìˆìŠµë‹ˆë‹¤.\ní´ë”ë¥¼ ì‚­ì œí•˜ë©´ íŒŒì¼ë“¤ì´ ë£¨íŠ¸ë¡œ ì´ë™í•©ë‹ˆë‹¤.\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
            return;
        }
        // íŒŒì¼ë“¤ì„ ë£¨íŠ¸ë¡œ ì´ë™
        filesInFolder.forEach(fileName => {
            delete rawFileToFolder[fileName];
        });
    }

    delete rawFileFolders[folderId];

    // í˜„ì¬ í´ë”ê°€ ì‚­ì œëœ í´ë”ë©´ ë£¨íŠ¸ë¡œ ì´ë™
    if (currentRawFolderId === folderId) {
        currentRawFolderId = null;
    }

    saveRawFileFolders();
    renderRawFilesList();
    showToast(`"${folder.name}" í´ë”ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
}

// í´ë” ì´ë¦„ ë³€ê²½
function renameRawFileFolder(folderId, newName) {
    if (!rawFileFolders[folderId]) return;
    if (!newName || !newName.trim()) {
        showToast('í´ë” ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
        return;
    }
    rawFileFolders[folderId].name = newName.trim();
    saveRawFileFolders();
    renderRawFilesList();
    showToast('í´ë” ì´ë¦„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
}

// í´ë” ìƒ‰ìƒ ë³€ê²½
function changeRawFolderColor(folderId, color) {
    if (!rawFileFolders[folderId]) return;
    rawFileFolders[folderId].color = color;
    saveRawFileFolders();
    renderRawFilesList();
}

// íŒŒì¼ì„ í´ë”ë¡œ ì´ë™
function moveRawFileToFolder(fileName, folderId) {
    if (!rawFiles[fileName]) return;

    if (folderId === null) {
        // ë£¨íŠ¸ë¡œ ì´ë™
        delete rawFileToFolder[fileName];
    } else if (rawFileFolders[folderId]) {
        rawFileToFolder[fileName] = folderId;
    }

    saveRawFileFolders();
    renderRawFilesList();
}

// ì„ íƒëœ íŒŒì¼ë“¤ì„ í´ë”ë¡œ ì´ë™
function moveSelectedRawFilesToFolder(folderId) {
    if (selectedRawFiles.size === 0) {
        showToast('ì´ë™í•  íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
        return;
    }

    selectedRawFiles.forEach(fileName => {
        if (folderId === null) {
            delete rawFileToFolder[fileName];
        } else if (rawFileFolders[folderId]) {
            rawFileToFolder[fileName] = folderId;
        }
    });

    const count = selectedRawFiles.size;
    selectedRawFiles.clear();
    rawFileSelectMode = false;

    saveRawFileFolders();
    renderRawFilesList();
    showToast(`${count}ê°œ íŒŒì¼ì´ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
}

// í´ë” ì—´ê¸°
function openRawFileFolder(folderId) {
    currentRawFolderId = folderId;
    renderRawFilesList();
}

// ìƒìœ„ í´ë”(ë£¨íŠ¸)ë¡œ ì´ë™
function goToRawFileRoot() {
    currentRawFolderId = null;
    renderRawFilesList();
}

// í´ë” ì´ë™ ëª¨ë‹¬ í‘œì‹œ
function showMoveToFolderModal(fileName) {
    const folders = Object.entries(rawFileFolders);
    const currentFolder = rawFileToFolder[fileName];

    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.innerHTML = `
        <div class="history-modal-content copy-sheet-modal">
            <div class="history-modal-header">
                <h3>ğŸ“ í´ë”ë¡œ ì´ë™</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body">
                <p style="margin-bottom: 15px; color: #666;">ì´ë™í•  í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”:</p>
                <div class="copy-sheet-list">
                    <div class="copy-sheet-item ${!currentFolder ? 'current-folder' : ''}" onclick="moveRawFileToFolder('${fileName.replace(/'/g, "\\'")}', null); this.closest('.raw-file-history-modal').remove();">
                        <span class="copy-sheet-name">ğŸ“‚ ë£¨íŠ¸ (ìµœìƒìœ„)</span>
                        ${!currentFolder ? '<span class="current-badge">í˜„ì¬</span>' : ''}
                    </div>
                    ${folders.map(([id, folder]) => `
                        <div class="copy-sheet-item ${currentFolder === id ? 'current-folder' : ''}" onclick="moveRawFileToFolder('${fileName.replace(/'/g, "\\'")}', '${id}'); this.closest('.raw-file-history-modal').remove();">
                            <span class="copy-sheet-name" style="color: ${folder.color}">ğŸ“ ${escHtml(folder.name)}</span>
                            ${currentFolder === id ? '<span class="current-badge">í˜„ì¬</span>' : ''}
                        </div>
                    `).join('')}
                </div>
                ${folders.length === 0 ? '<p style="text-align: center; color: #999; padding: 20px;">í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤. ìƒˆ í´ë”ë¥¼ ë¨¼ì € ìƒì„±í•´ì£¼ì„¸ìš”.</p>' : ''}
            </div>
        </div>
    `;

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);
}

// í´ë” ë‚´ íŒŒì¼ ìˆ˜ ê°€ì ¸ì˜¤ê¸°
function getRawFileFolderCount(folderId) {
    return Object.values(rawFileToFolder).filter(f => f === folderId).length;
}

// í´ë” ë°ì´í„° ì €ì¥
function saveRawFileFolders() {
    try {
        localStorage.setItem('excelmaster_rawFileFolders', JSON.stringify(rawFileFolders));
        localStorage.setItem('excelmaster_rawFileToFolder', JSON.stringify(rawFileToFolder));
    } catch (e) {
        console.warn('í´ë” ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:', e);
    }
}

// í´ë” ë°ì´í„° ë¡œë“œ
function loadRawFileFolders() {
    try {
        const foldersData = localStorage.getItem('excelmaster_rawFileFolders');
        const mappingData = localStorage.getItem('excelmaster_rawFileToFolder');

        if (foldersData) {
            rawFileFolders = JSON.parse(foldersData);
        }
        if (mappingData) {
            rawFileToFolder = JSON.parse(mappingData);
        }

        // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íŒŒì¼ ë§¤í•‘ ì •ë¦¬
        for (const fileName in rawFileToFolder) {
            if (!rawFiles[fileName]) {
                delete rawFileToFolder[fileName];
            }
        }
    } catch (e) {
        console.warn('í´ë” ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', e);
        rawFileFolders = {};
        rawFileToFolder = {};
    }
}

// ========== ì¤‘ë³µ í–‰ íƒì§€ ì‹œìŠ¤í…œ ==========

// ì¤‘ë³µ íƒì§€ ê²°ê³¼ ì €ì¥
var duplicateResults = null;

// í–‰ì„ ë¬¸ìì—´ë¡œ ë³€í™˜ (ë¹„êµìš©)
function rowToString(row) {
    if (!row) return '';
    return row.map(cell => {
        if (cell === null || cell === undefined) return '';
        return String(cell).trim();
    }).join('|||');
}

// ì™„ì „ ì¤‘ë³µ íƒì§€ (ëª¨ë“  ì—´ì´ ë™ì¼)
function findExactDuplicates(fileName, sheetName) {
    if (!rawFiles[fileName] || !rawFiles[fileName].sheets[sheetName]) {
        return { duplicates: [], groups: [] };
    }

    const sheetData = rawFiles[fileName].sheets[sheetName];
    const data = sheetData.data || [];

    const rowMap = new Map(); // rowString -> [rowIndices]
    const duplicates = [];
    const groups = [];

    data.forEach((row, idx) => {
        const rowStr = rowToString(row);
        if (!rowStr) return; // ë¹ˆ í–‰ ë¬´ì‹œ

        if (!rowMap.has(rowStr)) {
            rowMap.set(rowStr, [idx]);
        } else {
            rowMap.get(rowStr).push(idx);
        }
    });

    // ì¤‘ë³µ ê·¸ë£¹ ì¶”ì¶œ
    rowMap.forEach((indices, rowStr) => {
        if (indices.length > 1) {
            groups.push({
                indices: indices,
                count: indices.length,
                sample: data[indices[0]]
            });
            indices.forEach(idx => duplicates.push(idx));
        }
    });

    return {
        duplicates: duplicates.sort((a, b) => a - b),
        groups: groups,
        totalDuplicateRows: duplicates.length,
        uniqueGroups: groups.length
    };
}

// í‚¤ ì—´ ê¸°ì¤€ ì¤‘ë³µ íƒì§€
function findKeyDuplicates(fileName, sheetName, keyColumnIndices) {
    if (!rawFiles[fileName] || !rawFiles[fileName].sheets[sheetName]) {
        return { duplicates: [], groups: [] };
    }

    const sheetData = rawFiles[fileName].sheets[sheetName];
    const data = sheetData.data || [];

    const keyMap = new Map(); // keyString -> [rowIndices]
    const duplicates = [];
    const groups = [];

    data.forEach((row, idx) => {
        if (!row) return;

        // í‚¤ ê°’ë§Œ ì¶”ì¶œ
        const keyValues = keyColumnIndices.map(colIdx => {
            const cell = row[colIdx];
            if (cell === null || cell === undefined) return '';
            return String(cell).trim();
        });

        const keyStr = keyValues.join('|||');
        if (!keyStr || keyStr === '|||'.repeat(keyColumnIndices.length - 1)) return; // ë¹ˆ í‚¤ ë¬´ì‹œ

        if (!keyMap.has(keyStr)) {
            keyMap.set(keyStr, [idx]);
        } else {
            keyMap.get(keyStr).push(idx);
        }
    });

    // ì¤‘ë³µ ê·¸ë£¹ ì¶”ì¶œ
    keyMap.forEach((indices, keyStr) => {
        if (indices.length > 1) {
            groups.push({
                indices: indices,
                count: indices.length,
                keyValues: keyStr.split('|||'),
                sample: data[indices[0]]
            });
            indices.forEach(idx => duplicates.push(idx));
        }
    });

    return {
        duplicates: duplicates.sort((a, b) => a - b),
        groups: groups,
        totalDuplicateRows: duplicates.length,
        uniqueGroups: groups.length
    };
}

// ì¤‘ë³µ íƒì§€ ëª¨ë‹¬ í‘œì‹œ
function showDuplicateDetectionModal(fileName) {
    if (!rawFiles[fileName]) {
        showToast('íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    const file = rawFiles[fileName];
    const sheetNames = Object.keys(file.sheets);

    if (sheetNames.length === 0) {
        showToast('ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    // ì²« ë²ˆì§¸ ì‹œíŠ¸ì˜ í—¤ë” ê°€ì ¸ì˜¤ê¸°
    const firstSheet = file.sheets[sheetNames[0]];
    const headers = firstSheet.headers || [];

    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.id = 'duplicateDetectionModal';
    modal.innerHTML = `
        <div class="history-modal-content" style="max-width: 550px;">
            <div class="history-modal-header">
                <h3>ğŸ” ì¤‘ë³µ í–‰ íƒì§€ - ${escHtml(file.displayName || fileName)}</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body" style="padding: 20px;">
                <div class="duplicate-options">
                    <div class="option-group">
                        <label>ì‹œíŠ¸ ì„ íƒ:</label>
                        <select id="dupSheetSelect" onchange="updateDupHeaders('${escHtml(fileName)}')">
                            ${sheetNames.map(sn => `<option value="${escHtml(sn)}">${escHtml(sn)}</option>`).join('')}
                        </select>
                    </div>
                    <div class="option-group">
                        <label>íƒì§€ ë°©ì‹:</label>
                        <div class="radio-group">
                            <label><input type="radio" name="dupType" value="exact" checked onchange="toggleKeyColumns()"> ì™„ì „ ì¤‘ë³µ (ëª¨ë“  ì—´ ë™ì¼)</label>
                            <label><input type="radio" name="dupType" value="key" onchange="toggleKeyColumns()"> í‚¤ ì—´ ê¸°ì¤€ ì¤‘ë³µ</label>
                        </div>
                    </div>
                    <div class="option-group" id="keyColumnsGroup" style="display: none;">
                        <label>í‚¤ ì—´ ì„ íƒ (ì¤‘ë³µ íŒë‹¨ ê¸°ì¤€):</label>
                        <div class="key-columns-list" id="keyColumnsList">
                            ${headers.map((h, idx) => `
                                <label class="key-col-item">
                                    <input type="checkbox" value="${idx}">
                                    ${escHtml(h || `ì—´ ${idx + 1}`)}
                                </label>
                            `).join('')}
                        </div>
                    </div>
                </div>
                <div class="duplicate-actions">
                    <button class="btn-copy-all" onclick="runDuplicateDetection('${escHtml(fileName)}')">
                        ğŸ” ì¤‘ë³µ íƒì§€ ì‹¤í–‰
                    </button>
                </div>
                <div id="duplicateResultsArea" style="margin-top: 20px; display: none;">
                    <!-- ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                </div>
            </div>
        </div>
    `;

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);
}

// í‚¤ ì—´ ì„ íƒ í† ê¸€
function toggleKeyColumns() {
    const keyGroup = document.getElementById('keyColumnsGroup');
    const isKeyMode = document.querySelector('input[name="dupType"]:checked')?.value === 'key';
    if (keyGroup) {
        keyGroup.style.display = isKeyMode ? 'block' : 'none';
    }
}

// ì‹œíŠ¸ ë³€ê²½ ì‹œ í—¤ë” ì—…ë°ì´íŠ¸
function updateDupHeaders(fileName) {
    const sheetSelect = document.getElementById('dupSheetSelect');
    const sheetName = sheetSelect?.value;

    if (!rawFiles[fileName] || !rawFiles[fileName].sheets[sheetName]) return;

    const headers = rawFiles[fileName].sheets[sheetName].headers || [];
    const keyColumnsList = document.getElementById('keyColumnsList');

    if (keyColumnsList) {
        keyColumnsList.innerHTML = headers.map((h, idx) => `
            <label class="key-col-item">
                <input type="checkbox" value="${idx}">
                ${escHtml(h || `ì—´ ${idx + 1}`)}
            </label>
        `).join('');
    }
}

// ì¤‘ë³µ íƒì§€ ì‹¤í–‰
function runDuplicateDetection(fileName) {
    const sheetSelect = document.getElementById('dupSheetSelect');
    const sheetName = sheetSelect?.value;
    const dupType = document.querySelector('input[name="dupType"]:checked')?.value;

    if (!sheetName) {
        showToast('ì‹œíŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
        return;
    }

    let result;
    if (dupType === 'key') {
        const checkedBoxes = document.querySelectorAll('#keyColumnsList input:checked');
        const keyIndices = Array.from(checkedBoxes).map(cb => parseInt(cb.value));

        if (keyIndices.length === 0) {
            showToast('í‚¤ ì—´ì„ 1ê°œ ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
            return;
        }

        result = findKeyDuplicates(fileName, sheetName, keyIndices);
        result.type = 'key';
        result.keyIndices = keyIndices;
    } else {
        result = findExactDuplicates(fileName, sheetName);
        result.type = 'exact';
    }

    result.fileName = fileName;
    result.sheetName = sheetName;
    duplicateResults = result;

    // ê²°ê³¼ í‘œì‹œ
    displayDuplicateResults(result);
}

// ì¤‘ë³µ íƒì§€ ê²°ê³¼ í‘œì‹œ
function displayDuplicateResults(result) {
    const resultsArea = document.getElementById('duplicateResultsArea');
    if (!resultsArea) return;

    const headers = rawFiles[result.fileName]?.sheets[result.sheetName]?.headers || [];

    if (result.groups.length === 0) {
        resultsArea.innerHTML = `
            <div class="duplicate-no-result">
                <div style="font-size: 32px; margin-bottom: 10px;">âœ…</div>
                <div style="font-weight: 600; color: #4CAF50;">ì¤‘ë³µ ì—†ìŒ!</div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">ëª¨ë“  í–‰ì´ ê³ ìœ í•©ë‹ˆë‹¤.</div>
            </div>
        `;
        resultsArea.style.display = 'block';
        return;
    }

    resultsArea.innerHTML = `
        <div class="duplicate-summary">
            <div class="dup-stat">
                <span class="dup-stat-value">${result.uniqueGroups}</span>
                <span class="dup-stat-label">ì¤‘ë³µ ê·¸ë£¹</span>
            </div>
            <div class="dup-stat">
                <span class="dup-stat-value">${result.totalDuplicateRows}</span>
                <span class="dup-stat-label">ì¤‘ë³µ í–‰</span>
            </div>
            <div class="dup-stat">
                <span class="dup-stat-value">${result.totalDuplicateRows - result.uniqueGroups}</span>
                <span class="dup-stat-label">ì œê±° ê°€ëŠ¥</span>
            </div>
        </div>
        <div class="duplicate-groups-list">
            ${result.groups.slice(0, 10).map((group, gIdx) => `
                <div class="dup-group-item">
                    <div class="dup-group-header">
                        <span class="dup-group-badge">${group.count}ê°œ ì¤‘ë³µ</span>
                        <span class="dup-group-rows">í–‰ ë²ˆí˜¸: ${group.indices.map(i => i + 1).join(', ')}</span>
                    </div>
                    <div class="dup-group-preview">
                        ${group.sample ? group.sample.slice(0, 4).map((cell, cIdx) => `
                            <span class="dup-cell" title="${escHtml(headers[cIdx] || `ì—´${cIdx+1}`)}">${escHtml(String(cell || '').substring(0, 20))}</span>
                        `).join('') : ''}
                        ${group.sample && group.sample.length > 4 ? '<span class="dup-cell-more">...</span>' : ''}
                    </div>
                </div>
            `).join('')}
            ${result.groups.length > 10 ? `<div class="dup-more-groups">ì™¸ ${result.groups.length - 10}ê°œ ê·¸ë£¹ ë”...</div>` : ''}
        </div>
        <div class="duplicate-actions" style="margin-top: 15px;">
            <button class="btn-remove-dup" onclick="removeDuplicates()">
                ğŸ—‘ï¸ ì¤‘ë³µ ì œê±° (${result.totalDuplicateRows - result.uniqueGroups}í–‰)
            </button>
        </div>
    `;
    resultsArea.style.display = 'block';
}

// ì¤‘ë³µ ì œê±°
function removeDuplicates() {
    if (!duplicateResults || duplicateResults.groups.length === 0) {
        showToast('ì œê±°í•  ì¤‘ë³µì´ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    const { fileName, sheetName, groups } = duplicateResults;

    if (!rawFiles[fileName] || !rawFiles[fileName].sheets[sheetName]) {
        showToast('íŒŒì¼ ë˜ëŠ” ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    // ê° ê·¸ë£¹ì—ì„œ ì²« ë²ˆì§¸ í–‰ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ ì œê±°
    const indicesToRemove = new Set();
    groups.forEach(group => {
        // ì²« ë²ˆì§¸(ì¸ë±ìŠ¤ 0)ë¥¼ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ëª¨ë‘ ì œê±° ëŒ€ìƒ
        group.indices.slice(1).forEach(idx => indicesToRemove.add(idx));
    });

    const removeCount = indicesToRemove.size;

    if (!confirm(`${removeCount}ê°œì˜ ì¤‘ë³µ í–‰ì„ ì œê±°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ê° ê·¸ë£¹ì—ì„œ ì²« ë²ˆì§¸ í–‰ë§Œ ìœ ì§€ë©ë‹ˆë‹¤)`)) {
        return;
    }

    // ë°ì´í„°ì—ì„œ ì¤‘ë³µ í–‰ ì œê±°
    const originalData = rawFiles[fileName].sheets[sheetName].data;
    const newData = originalData.filter((_, idx) => !indicesToRemove.has(idx));

    rawFiles[fileName].sheets[sheetName].data = newData;

    // ì´ í–‰ ìˆ˜ ì—…ë°ì´íŠ¸
    let totalRows = 0;
    Object.values(rawFiles[fileName].sheets).forEach(sheet => {
        totalRows += (sheet.data?.length || 0);
    });
    rawFiles[fileName].totalRows = totalRows;

    // ì €ì¥
    saveRawFilesToLocalStorage();

    // ëª¨ë‹¬ ë‹«ê¸° ë° ê²°ê³¼ ì´ˆê¸°í™”
    document.getElementById('duplicateDetectionModal')?.remove();
    duplicateResults = null;

    showToast(`${removeCount}ê°œ ì¤‘ë³µ í–‰ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
    renderRawFilesList();
}

// ========== ê¸°ë³¸ í†µê³„ ì‹œìŠ¤í…œ ==========

// íŒŒì¼ í†µê³„ ê³„ì‚°
function calculateFileStatistics(fileName) {
    if (!rawFiles[fileName]) return null;

    const file = rawFiles[fileName];
    const sheets = file.sheets || {};
    const sheetNames = Object.keys(sheets);

    let totalRows = 0;
    let totalCells = 0;
    let emptyCells = 0;
    let allColumns = new Set();
    let sheetStats = [];

    sheetNames.forEach(sheetName => {
        const sheet = sheets[sheetName];
        const headers = sheet.headers || [];
        const data = sheet.data || [];
        const rowCount = data.length;
        const colCount = headers.length;

        headers.forEach(h => allColumns.add(h));

        let sheetEmptyCells = 0;
        data.forEach(row => {
            if (!row) return;
            row.forEach(cell => {
                if (cell === null || cell === undefined || cell === '') {
                    sheetEmptyCells++;
                }
            });
        });

        const sheetTotalCells = rowCount * colCount;
        const fillRate = sheetTotalCells > 0 ? ((sheetTotalCells - sheetEmptyCells) / sheetTotalCells * 100).toFixed(1) : 0;

        sheetStats.push({
            name: sheetName,
            rows: rowCount,
            columns: colCount,
            emptyCells: sheetEmptyCells,
            totalCells: sheetTotalCells,
            fillRate: fillRate
        });

        totalRows += rowCount;
        totalCells += sheetTotalCells;
        emptyCells += sheetEmptyCells;
    });

    const uploadHistory = [];
    sheetNames.forEach(sheetName => {
        const sheet = sheets[sheetName];
        if (sheet.uploadHistory) {
            sheet.uploadHistory.forEach(h => uploadHistory.push({ ...h, sheetName }));
        }
    });
    uploadHistory.sort((a, b) => new Date(b.date) - new Date(a.date));

    return {
        fileName,
        displayName: file.displayName || fileName,
        totalSheets: sheetNames.length,
        totalRows,
        totalColumns: allColumns.size,
        totalCells,
        emptyCells,
        fillRate: totalCells > 0 ? ((totalCells - emptyCells) / totalCells * 100).toFixed(1) : 0,
        lastUpdated: file.lastUpdated,
        sheetStats,
        uploadCount: uploadHistory.length,
        uploadHistory: uploadHistory.slice(0, 5)
    };
}

// ì—´ë³„ í†µê³„ ê³„ì‚°
function calculateColumnStatistics(fileName, sheetName) {
    if (!rawFiles[fileName] || !rawFiles[fileName].sheets[sheetName]) return [];

    const sheet = rawFiles[fileName].sheets[sheetName];
    const headers = sheet.headers || [];
    const data = sheet.data || [];

    return headers.map((header, colIdx) => {
        const values = data.map(row => row ? row[colIdx] : null);
        const nonEmpty = values.filter(v => v !== null && v !== undefined && v !== '');
        const uniqueValues = new Set(nonEmpty.map(v => String(v)));

        // ë°ì´í„° íƒ€ì… ì¶”ë¡ 
        let numericCount = 0;
        let dateCount = 0;
        nonEmpty.forEach(v => {
            if (!isNaN(Number(v))) numericCount++;
            if (v && /^\d{4}[-./]\d{1,2}[-./]\d{1,2}/.test(String(v))) dateCount++;
        });

        let dataType = 'í…ìŠ¤íŠ¸';
        if (numericCount > nonEmpty.length * 0.8) dataType = 'ìˆ«ì';
        else if (dateCount > nonEmpty.length * 0.5) dataType = 'ë‚ ì§œ';

        // ìˆ«ìì¸ ê²½ìš° min/max/avg
        let min = null, max = null, avg = null;
        if (dataType === 'ìˆ«ì' && nonEmpty.length > 0) {
            const nums = nonEmpty.map(v => Number(v)).filter(n => !isNaN(n));
            if (nums.length > 0) {
                min = Math.min(...nums);
                max = Math.max(...nums);
                avg = (nums.reduce((a, b) => a + b, 0) / nums.length).toFixed(2);
            }
        }

        return {
            index: colIdx,
            header: header || `ì—´ ${colIdx + 1}`,
            totalCount: values.length,
            nonEmptyCount: nonEmpty.length,
            emptyCount: values.length - nonEmpty.length,
            fillRate: values.length > 0 ? ((nonEmpty.length / values.length) * 100).toFixed(1) : 0,
            uniqueCount: uniqueValues.size,
            dataType,
            min, max, avg
        };
    });
}

// í†µê³„ ëª¨ë‹¬ í‘œì‹œ
function showStatisticsModal(fileName) {
    if (!rawFiles[fileName]) {
        showToast('íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    const stats = calculateFileStatistics(fileName);
    if (!stats) return;

    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.id = 'statisticsModal';
    modal.innerHTML = `
        <div class="history-modal-content" style="max-width: 600px;">
            <div class="history-modal-header">
                <h3>ğŸ“Š í†µê³„ - ${escHtml(stats.displayName)}</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body" style="padding: 20px;">
                <!-- íƒ­ -->
                <div class="stats-tabs">
                    <button class="stats-tab active" onclick="switchStatsTab('overview', this)">ê°œìš”</button>
                    <button class="stats-tab" onclick="switchStatsTab('sheets', this)">ì‹œíŠ¸ë³„</button>
                    <button class="stats-tab" onclick="switchStatsTab('columns', this)">ì—´ë³„</button>
                </div>

                <!-- ê°œìš” íƒ­ -->
                <div class="stats-content" id="statsOverview">
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ“‘</div>
                            <div class="stat-value">${stats.totalSheets}</div>
                            <div class="stat-label">ì‹œíŠ¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ“</div>
                            <div class="stat-value">${stats.totalRows.toLocaleString()}</div>
                            <div class="stat-label">ì´ í–‰</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ“Š</div>
                            <div class="stat-value">${stats.totalColumns}</div>
                            <div class="stat-label">ì´ ì—´</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">âœ…</div>
                            <div class="stat-value">${stats.fillRate}%</div>
                            <div class="stat-label">ë°ì´í„° ì¶©ì¡±ë¥ </div>
                        </div>
                    </div>
                    <div class="stats-detail">
                        <div class="detail-row">
                            <span>ì´ ì…€ ìˆ˜</span>
                            <span>${stats.totalCells.toLocaleString()}</span>
                        </div>
                        <div class="detail-row">
                            <span>ë¹ˆ ì…€ ìˆ˜</span>
                            <span>${stats.emptyCells.toLocaleString()}</span>
                        </div>
                        <div class="detail-row">
                            <span>ì—…ë¡œë“œ íšŸìˆ˜</span>
                            <span>${stats.uploadCount}íšŒ</span>
                        </div>
                        <div class="detail-row">
                            <span>ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸</span>
                            <span>${stats.lastUpdated ? new Date(stats.lastUpdated).toLocaleString('ko-KR') : '-'}</span>
                        </div>
                    </div>
                </div>

                <!-- ì‹œíŠ¸ë³„ íƒ­ -->
                <div class="stats-content" id="statsSheets" style="display: none;">
                    <div class="sheet-stats-list">
                        ${stats.sheetStats.map(s => `
                            <div class="sheet-stat-item">
                                <div class="sheet-stat-name">ğŸ“„ ${escHtml(s.name)}</div>
                                <div class="sheet-stat-meta">
                                    <span>${s.rows.toLocaleString()}í–‰</span>
                                    <span>${s.columns}ì—´</span>
                                    <span class="fill-badge" style="background: ${getFillRateColor(s.fillRate)}">${s.fillRate}%</span>
                                </div>
                                <div class="sheet-stat-bar">
                                    <div class="fill-bar" style="width: ${s.fillRate}%; background: ${getFillRateColor(s.fillRate)}"></div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <!-- ì—´ë³„ íƒ­ -->
                <div class="stats-content" id="statsColumns" style="display: none;">
                    <div class="column-stats-controls">
                        <select id="columnStatsSheetSelect" onchange="updateColumnStats('${escHtml(fileName)}')">
                            ${Object.keys(rawFiles[fileName].sheets).map(sn => `<option value="${escHtml(sn)}">${escHtml(sn)}</option>`).join('')}
                        </select>
                    </div>
                    <div class="column-stats-list" id="columnStatsList">
                        <!-- ì—´ í†µê³„ê°€ ì—¬ê¸° í‘œì‹œë¨ -->
                    </div>
                </div>
            </div>
        </div>
    `;

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);

    // ì´ˆê¸° ì—´ í†µê³„ ë¡œë“œ
    updateColumnStats(fileName);
}

// íƒ­ ì „í™˜
function switchStatsTab(tabName, btn) {
    document.querySelectorAll('.stats-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.stats-content').forEach(c => c.style.display = 'none');

    btn.classList.add('active');
    const tabId = tabName === 'overview' ? 'statsOverview' : tabName === 'sheets' ? 'statsSheets' : 'statsColumns';
    document.getElementById(tabId).style.display = 'block';
}

// ì—´ í†µê³„ ì—…ë°ì´íŠ¸
function updateColumnStats(fileName) {
    const sheetSelect = document.getElementById('columnStatsSheetSelect');
    const sheetName = sheetSelect?.value;
    const listEl = document.getElementById('columnStatsList');

    if (!sheetName || !listEl) return;

    const colStats = calculateColumnStatistics(fileName, sheetName);

    listEl.innerHTML = colStats.map(col => `
        <div class="col-stat-item">
            <div class="col-stat-header">
                <span class="col-stat-name">${escHtml(col.header)}</span>
                <span class="col-stat-type">${col.dataType}</span>
            </div>
            <div class="col-stat-details">
                <span>ê°’: ${col.nonEmptyCount}/${col.totalCount}</span>
                <span>ê³ ìœ : ${col.uniqueCount}</span>
                <span class="fill-badge" style="background: ${getFillRateColor(col.fillRate)}">${col.fillRate}%</span>
            </div>
            ${col.dataType === 'ìˆ«ì' && col.min !== null ? `
                <div class="col-stat-numeric">
                    <span>ìµœì†Œ: ${col.min}</span>
                    <span>ìµœëŒ€: ${col.max}</span>
                    <span>í‰ê· : ${col.avg}</span>
                </div>
            ` : ''}
        </div>
    `).join('');
}

// ì¶©ì¡±ë¥ ì— ë”°ë¥¸ ìƒ‰ìƒ
function getFillRateColor(rate) {
    rate = parseFloat(rate);
    if (rate >= 90) return '#4CAF50';
    if (rate >= 70) return '#8BC34A';
    if (rate >= 50) return '#FFC107';
    if (rate >= 30) return '#FF9800';
    return '#F44336';
}

// ========== ë°ì´í„° ì •ì œ ë„êµ¬ (Phase 3) ==========

// ë°ì´í„° ì •ì œ ëª¨ë‹¬ í‘œì‹œ
function showDataCleaningModal(fileName) {
    if (!rawFiles[fileName]) {
        showToast('íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    const file = rawFiles[fileName];
    const sheetNames = Object.keys(file.sheets);

    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.id = 'dataCleaningModal';
    modal.innerHTML = `
        <div class="history-modal-content" style="max-width: 500px;">
            <div class="history-modal-header">
                <h3>ğŸ§¹ ë°ì´í„° ì •ì œ - ${escHtml(file.displayName || fileName)}</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body" style="padding: 20px;">
                <div class="cleaning-options">
                    <div class="option-group">
                        <label>ì‹œíŠ¸ ì„ íƒ:</label>
                        <select id="cleanSheetSelect">
                            <option value="__all__">ëª¨ë“  ì‹œíŠ¸</option>
                            ${sheetNames.map(sn => `<option value="${escHtml(sn)}">${escHtml(sn)}</option>`).join('')}
                        </select>
                    </div>
                    <div class="cleaning-tools">
                        <div class="cleaning-tool" onclick="runCleaningTool('${escHtml(fileName)}', 'trim')">
                            <div class="tool-icon">âœ‚ï¸</div>
                            <div class="tool-info">
                                <div class="tool-name">ê³µë°± ì œê±° (Trim)</div>
                                <div class="tool-desc">ì•ë’¤ ê³µë°± ì œê±°</div>
                            </div>
                        </div>
                        <div class="cleaning-tool" onclick="runCleaningTool('${escHtml(fileName)}', 'emptyRows')">
                            <div class="tool-icon">ğŸ—‘ï¸</div>
                            <div class="tool-info">
                                <div class="tool-name">ë¹ˆ í–‰ ì œê±°</div>
                                <div class="tool-desc">ëª¨ë“  ì…€ì´ ë¹„ì–´ìˆëŠ” í–‰ ì‚­ì œ</div>
                            </div>
                        </div>
                        <div class="cleaning-tool" onclick="runCleaningTool('${escHtml(fileName)}', 'normalizeDate')">
                            <div class="tool-icon">ğŸ“…</div>
                            <div class="tool-info">
                                <div class="tool-name">ë‚ ì§œ í˜•ì‹ í†µì¼</div>
                                <div class="tool-desc">YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ ë³€í™˜</div>
                            </div>
                        </div>
                        <div class="cleaning-tool" onclick="runCleaningTool('${escHtml(fileName)}', 'normalizeNumber')">
                            <div class="tool-icon">ğŸ”¢</div>
                            <div class="tool-info">
                                <div class="tool-name">ìˆ«ì í˜•ì‹ ì •ë¦¬</div>
                                <div class="tool-desc">ì‰¼í‘œ/ê³µë°± ì œê±°, ìˆ«ìë¡œ ë³€í™˜</div>
                            </div>
                        </div>
                        <div class="cleaning-tool" onclick="runCleaningTool('${escHtml(fileName)}', 'lowercase')">
                            <div class="tool-icon">ğŸ”¡</div>
                            <div class="tool-info">
                                <div class="tool-name">ì†Œë¬¸ì ë³€í™˜</div>
                                <div class="tool-desc">ì˜ë¬¸ í…ìŠ¤íŠ¸ë¥¼ ì†Œë¬¸ìë¡œ</div>
                            </div>
                        </div>
                        <div class="cleaning-tool" onclick="runCleaningTool('${escHtml(fileName)}', 'uppercase')">
                            <div class="tool-icon">ğŸ” </div>
                            <div class="tool-info">
                                <div class="tool-name">ëŒ€ë¬¸ì ë³€í™˜</div>
                                <div class="tool-desc">ì˜ë¬¸ í…ìŠ¤íŠ¸ë¥¼ ëŒ€ë¬¸ìë¡œ</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="cleaningResultArea" style="margin-top: 15px; display: none;">
                    <!-- ê²°ê³¼ê°€ ì—¬ê¸° í‘œì‹œ -->
                </div>
            </div>
        </div>
    `;

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);
}

// ì •ì œ ë„êµ¬ ì‹¤í–‰
function runCleaningTool(fileName, toolType) {
    const sheetSelect = document.getElementById('cleanSheetSelect');
    const selectedSheet = sheetSelect?.value;

    if (!rawFiles[fileName]) {
        showToast('íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    const sheetsToClean = selectedSheet === '__all__'
        ? Object.keys(rawFiles[fileName].sheets)
        : [selectedSheet];

    let totalChanges = 0;

    sheetsToClean.forEach(sheetName => {
        const sheet = rawFiles[fileName].sheets[sheetName];
        if (!sheet || !sheet.data) return;

        const result = applyCleaningTool(sheet.data, toolType);
        sheet.data = result.data;
        totalChanges += result.changes;
    });

    // ì €ì¥
    saveRawFilesToLocalStorage();

    // ê²°ê³¼ í‘œì‹œ
    const resultArea = document.getElementById('cleaningResultArea');
    if (resultArea) {
        resultArea.innerHTML = `
            <div class="cleaning-result ${totalChanges > 0 ? 'success' : 'no-change'}">
                ${totalChanges > 0
                    ? `âœ… ${totalChanges}ê°œ ì…€ì´ ì •ì œë˜ì—ˆìŠµë‹ˆë‹¤.`
                    : `â„¹ï¸ ë³€ê²½í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.`
                }
            </div>
        `;
        resultArea.style.display = 'block';
    }

    if (totalChanges > 0) {
        showToast(`${totalChanges}ê°œ ì…€ ì •ì œ ì™„ë£Œ`, 'success');
        renderRawFilesList();
    }
}

// ì •ì œ ë„êµ¬ ì ìš©
function applyCleaningTool(data, toolType) {
    let changes = 0;

    const newData = data.map((row, rowIdx) => {
        if (!row) return row;

        // ë¹ˆ í–‰ ì œê±°
        if (toolType === 'emptyRows') {
            const isEmpty = row.every(cell => cell === null || cell === undefined || cell === '');
            if (isEmpty) {
                changes++;
                return null; // ë‚˜ì¤‘ì— í•„í„°ë§
            }
            return row;
        }

        return row.map((cell, colIdx) => {
            if (cell === null || cell === undefined) return cell;

            const original = cell;
            let processed = cell;

            switch (toolType) {
                case 'trim':
                    if (typeof processed === 'string') {
                        processed = processed.trim();
                    }
                    break;

                case 'normalizeDate':
                    processed = normalizeDate(processed);
                    break;

                case 'normalizeNumber':
                    processed = normalizeNumber(processed);
                    break;

                case 'lowercase':
                    if (typeof processed === 'string') {
                        processed = processed.toLowerCase();
                    }
                    break;

                case 'uppercase':
                    if (typeof processed === 'string') {
                        processed = processed.toUpperCase();
                    }
                    break;
            }

            if (processed !== original) {
                changes++;
            }

            return processed;
        });
    });

    // ë¹ˆ í–‰ í•„í„°ë§ (emptyRows ë„êµ¬)
    const filteredData = toolType === 'emptyRows'
        ? newData.filter(row => row !== null)
        : newData;

    return { data: filteredData, changes };
}

// ë‚ ì§œ ì •ê·œí™”
function normalizeDate(value) {
    if (!value) return value;
    const str = String(value);

    // ì´ë¯¸ YYYY-MM-DD í˜•ì‹ì´ë©´ ê·¸ëŒ€ë¡œ
    if (/^\d{4}-\d{2}-\d{2}$/.test(str)) return str;

    // ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ íŒŒì‹± ì‹œë„
    const patterns = [
        /(\d{4})[./-](\d{1,2})[./-](\d{1,2})/,  // YYYY.MM.DD, YYYY/MM/DD
        /(\d{1,2})[./-](\d{1,2})[./-](\d{4})/,  // MM/DD/YYYY, DD.MM.YYYY
        /(\d{4})(\d{2})(\d{2})/,                 // YYYYMMDD
    ];

    for (const pattern of patterns) {
        const match = str.match(pattern);
        if (match) {
            let year, month, day;
            if (pattern === patterns[0] || pattern === patterns[2]) {
                [, year, month, day] = match;
            } else {
                // MM/DD/YYYY ê°€ì •
                [, month, day, year] = match;
            }
            year = String(year).padStart(4, '20');
            month = String(month).padStart(2, '0');
            day = String(day).padStart(2, '0');

            if (parseInt(month) <= 12 && parseInt(day) <= 31) {
                return `${year}-${month}-${day}`;
            }
        }
    }

    return value;
}

// ìˆ«ì ì •ê·œí™”
function normalizeNumber(value) {
    if (!value) return value;
    const str = String(value).trim();

    // ìˆ«ìê°€ ì•„ë‹Œ ê²ƒ ê°™ìœ¼ë©´ ê·¸ëŒ€ë¡œ
    if (!/[\d.,]+/.test(str)) return value;

    // ì‰¼í‘œ, ê³µë°± ì œê±°
    const cleaned = str.replace(/[,\s]/g, '');

    // ìˆ«ìë¡œ ë³€í™˜ ê°€ëŠ¥í•˜ë©´ ë³€í™˜
    const num = parseFloat(cleaned);
    if (!isNaN(num)) {
        return num;
    }

    return value;
}

// ========== ì—…ë¡œë“œ ì¶”ì„¸ ë¶„ì„ (Phase 3) ==========

// ì „ì²´ ì›ë³¸ íŒŒì¼ ë¶„ì„ ëŒ€ì‹œë³´ë“œ
function showAnalyticsDashboard() {
    const fileNames = Object.keys(rawFiles);

    if (fileNames.length === 0) {
        showToast('ë¶„ì„í•  íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.', 'error');
        return;
    }

    // ì „ì²´ í†µê³„ ê³„ì‚°
    let totalFiles = fileNames.length;
    let totalSheets = 0;
    let totalRows = 0;
    let uploadHistory = [];

    fileNames.forEach(fileName => {
        const file = rawFiles[fileName];
        const sheets = file.sheets || {};
        totalSheets += Object.keys(sheets).length;
        totalRows += file.totalRows || 0;

        // ì—…ë¡œë“œ ì´ë ¥ ìˆ˜ì§‘
        Object.keys(sheets).forEach(sheetName => {
            const sheet = sheets[sheetName];
            if (sheet.uploadHistory) {
                sheet.uploadHistory.forEach(h => {
                    uploadHistory.push({
                        ...h,
                        fileName,
                        sheetName
                    });
                });
            }
        });

        // ê¸°ë³¸ ì´ë ¥ ì¶”ê°€ (uploadHistoryê°€ ì—†ëŠ” ê²½ìš°)
        if (file.lastUpdated && uploadHistory.filter(h => h.fileName === fileName).length === 0) {
            uploadHistory.push({
                date: file.lastUpdated,
                fileName,
                rowCount: file.totalRows || 0
            });
        }
    });

    // ë‚ ì§œìˆœ ì •ë ¬
    uploadHistory.sort((a, b) => new Date(a.date) - new Date(b.date));

    // ì›”ë³„ ì—…ë¡œë“œ í†µê³„
    const monthlyStats = {};
    uploadHistory.forEach(h => {
        const date = new Date(h.date);
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        if (!monthlyStats[monthKey]) {
            monthlyStats[monthKey] = { uploads: 0, rows: 0 };
        }
        monthlyStats[monthKey].uploads++;
        monthlyStats[monthKey].rows += h.rowCount || 0;
    });

    // ìµœê·¼ 6ê°œì›” ë°ì´í„°
    const monthKeys = Object.keys(monthlyStats).sort().slice(-6);

    // ê°€ì¥ ë§ì´ ì—…ë¡œë“œëœ íŒŒì¼
    const fileUploadCounts = {};
    uploadHistory.forEach(h => {
        fileUploadCounts[h.fileName] = (fileUploadCounts[h.fileName] || 0) + 1;
    });
    const topFiles = Object.entries(fileUploadCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.innerHTML = `
        <div class="history-modal-content" style="max-width: 650px;">
            <div class="history-modal-header">
                <h3>ğŸ“ˆ ì›ë³¸ íŒŒì¼ ë¶„ì„ ëŒ€ì‹œë³´ë“œ</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body" style="padding: 20px;">
                <!-- ì „ì²´ í†µê³„ -->
                <div class="stats-grid" style="margin-bottom: 20px;">
                    <div class="stat-card">
                        <div class="stat-icon">ğŸ“</div>
                        <div class="stat-value">${totalFiles}</div>
                        <div class="stat-label">ì´ íŒŒì¼</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">ğŸ“‘</div>
                        <div class="stat-value">${totalSheets}</div>
                        <div class="stat-label">ì´ ì‹œíŠ¸</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">ğŸ“</div>
                        <div class="stat-value">${totalRows.toLocaleString()}</div>
                        <div class="stat-label">ì´ í–‰</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">ğŸ“¤</div>
                        <div class="stat-value">${uploadHistory.length}</div>
                        <div class="stat-label">ì´ ì—…ë¡œë“œ</div>
                    </div>
                </div>

                <!-- ì›”ë³„ ì¶”ì„¸ -->
                <div class="analytics-section">
                    <h4>ğŸ“… ì›”ë³„ ì—…ë¡œë“œ ì¶”ì„¸</h4>
                    <div class="monthly-chart">
                        ${monthKeys.length > 0 ? monthKeys.map(month => {
                            const data = monthlyStats[month];
                            const maxUploads = Math.max(...monthKeys.map(k => monthlyStats[k].uploads));
                            const heightPercent = maxUploads > 0 ? (data.uploads / maxUploads * 100) : 0;
                            return `
                                <div class="chart-bar-container">
                                    <div class="chart-bar" style="height: ${heightPercent}%" title="${data.uploads}ê±´, ${data.rows.toLocaleString()}í–‰">
                                        <span class="chart-value">${data.uploads}</span>
                                    </div>
                                    <div class="chart-label">${month.substring(5)}ì›”</div>
                                </div>
                            `;
                        }).join('') : '<div class="no-data">ë°ì´í„° ì—†ìŒ</div>'}
                    </div>
                </div>

                <!-- ìì£¼ ì—…ë¡œë“œëœ íŒŒì¼ -->
                <div class="analytics-section">
                    <h4>ğŸ”¥ ìì£¼ ì—…ë¡œë“œëœ íŒŒì¼ TOP 5</h4>
                    <div class="top-files-list">
                        ${topFiles.length > 0 ? topFiles.map(([name, count], idx) => `
                            <div class="top-file-item">
                                <span class="top-file-rank">#${idx + 1}</span>
                                <span class="top-file-name">${escHtml(rawFiles[name]?.displayName || name)}</span>
                                <span class="top-file-count">${count}íšŒ</span>
                            </div>
                        `).join('') : '<div class="no-data">ë°ì´í„° ì—†ìŒ</div>'}
                    </div>
                </div>

                <!-- ìµœê·¼ í™œë™ -->
                <div class="analytics-section">
                    <h4>ğŸ• ìµœê·¼ ì—…ë¡œë“œ</h4>
                    <div class="recent-uploads-list">
                        ${uploadHistory.slice(-5).reverse().map(h => `
                            <div class="recent-upload-item">
                                <span class="upload-date">${new Date(h.date).toLocaleDateString('ko-KR')}</span>
                                <span class="upload-file">${escHtml(h.fileName?.substring(0, 20) || '-')}</span>
                                <span class="upload-rows">+${(h.rowCount || 0).toLocaleString()}í–‰</span>
                            </div>
                        `).join('') || '<div class="no-data">ë°ì´í„° ì—†ìŒ</div>'}
                    </div>
                </div>
            </div>
        </div>
    `;

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);
}

// ì„ íƒëœ íŒŒì¼ë“¤ì„ í´ë”ë¡œ ì´ë™í•˜ëŠ” ëª¨ë‹¬
function showMoveSelectedToFolderModal() {
    if (selectedRawFiles.size === 0) {
        showToast('ì´ë™í•  íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
        return;
    }

    const folders = Object.entries(rawFileFolders);

    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.innerHTML = `
        <div class="history-modal-content copy-sheet-modal">
            <div class="history-modal-header">
                <h3>ğŸ“ ${selectedRawFiles.size}ê°œ íŒŒì¼ ì´ë™</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body">
                <p style="margin-bottom: 15px; color: #666;">ì´ë™í•  í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”:</p>
                <div class="copy-sheet-list">
                    <div class="copy-sheet-item" onclick="moveSelectedRawFilesToFolder(null); this.closest('.raw-file-history-modal').remove();">
                        <span class="copy-sheet-name">ğŸ“‚ ë£¨íŠ¸ (ìµœìƒìœ„)</span>
                    </div>
                    ${folders.map(([id, folder]) => `
                        <div class="copy-sheet-item" onclick="moveSelectedRawFilesToFolder('${id}'); this.closest('.raw-file-history-modal').remove();">
                            <span class="copy-sheet-name" style="color: ${folder.color}">ğŸ“ ${escHtml(folder.name)}</span>
                            <span class="copy-sheet-rows">${getRawFileFolderCount(id)}ê°œ íŒŒì¼</span>
                        </div>
                    `).join('')}
                </div>
                ${folders.length === 0 ? '<p style="text-align: center; color: #999; padding: 20px;">í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤.<br>ë¨¼ì € í´ë”ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.</p>' : ''}
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                    <button class="btn-copy-all" onclick="createRawFileFolder(); this.closest('.raw-file-history-modal').remove();">
                        ğŸ“+ ìƒˆ í´ë” ë§Œë“¤ê¸°
                    </button>
                </div>
            </div>
        </div>
    `;

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);
}

// ì›ë³¸ íŒŒì¼ ì„ íƒ
function selectRawFile(fileName) {
    if (!rawFiles[fileName]) return;

    currentRawFile = fileName;
    const sheetNames = Object.keys(rawFiles[fileName].sheets);

    // ì²« ë²ˆì§¸ ì‹œíŠ¸ ì„ íƒ
    if (sheetNames.length > 0) {
        selectRawFileSheet(fileName, sheetNames[0]);
    }

    renderRawFilesList();
}

// ì›ë³¸ íŒŒì¼ì˜ íŠ¹ì • ì‹œíŠ¸ ì„ íƒ â†’ ì‹œíŠ¸ ëª©ë¡(detailScreen)ê³¼ ë™ì¼í•˜ê²Œ ì—´ê¸°
function selectRawFileSheet(fileName, sheetName) {
    if (!rawFiles[fileName] || !rawFiles[fileName].sheets[sheetName]) return;

    currentRawFile = fileName;
    currentRawSheet = sheetName;

    const sheetData = rawFiles[fileName].sheets[sheetName];

    // displayName ì‚¬ìš© (ë‚ ì§œ ì œê±°ëœ íŒŒì¼ëª…)
    const displayName = rawFiles[fileName].displayName || fileName.replace(/\s*\d{4}\.\d{2}\.\d{2}/g, '').replace(/\.xlsx?$/i, '').trim() || fileName;
    const tempSheetName = `[ì›ë³¸] ${displayName} - ${sheetName}`;

    // ë‚ ì§œ ë³€í™˜ ë¡œì§ - ì‹œíŠ¸ ëª©ë¡ê³¼ ë™ì¼
    const headers = sheetData.headers || [];
    const rawData = sheetData.data || [];

    // ë‚ ì§œ ì—´ ì¸ë±ìŠ¤ ì°¾ê¸°
    const dateColIndices = new Set();
    headers.forEach((h, idx) => {
        if (h && (h.includes('ë‚ ì§œ') || h.includes('ì¼ì') || h.includes('ì¼ì‹œ') ||
                  h.includes('Date') || h.includes('date') || h.includes('DATE') ||
                  h === 'ì‘ì„±ì¼' || h === 'ì…ê¸ˆì¼' || h === 'í‡´ì‚¬ë‚ ì§œ' || h === 'ì…ì‚¬ì¼' ||
                  h === 'ì™„ë£Œì˜ˆì •ì¼' || h === 'ì˜ˆì•½ì¼ì •' || h.includes('ì˜ˆì •ì¼'))) {
            dateColIndices.add(idx);
        }
    });

    // ë°ì´í„° ì²˜ë¦¬ - ë‚ ì§œ ë³€í™˜ ì ìš©
    const processedData = rawData.map(row => {
        if (!row) return row;
        return row.map((cell, idx) => {
            // ì²« ë²ˆì§¸ ì—´ ë˜ëŠ” ë‚ ì§œ ì—´ì¸ ê²½ìš° ë³€í™˜
            if ((idx === 0 || dateColIndices.has(idx)) && cell !== '' && cell !== null && cell !== undefined) {
                return convertToKoreanDate(cell);
            }
            return cell;
        });
    });

    // WBì— ì‹œíŠ¸ ì¶”ê°€ (ê¸°ì¡´ ì‹œíŠ¸ê°€ ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸)
    if (WB[tempSheetName] && WB[tempSheetName].headers) {
        // ê¸°ì¡´ ì‹œíŠ¸ ì—…ë°ì´íŠ¸ (ë°ì´í„° êµì²´)
        WB[tempSheetName].data = processedData;
    } else {
        // ìƒˆ ì‹œíŠ¸ ìƒì„±
        WB[tempSheetName] = {
            headers: headers,
            data: processedData
        };
        COL_ORDER[tempSheetName] = headers.map((_, i) => i);
        HIDDEN_COLS[tempSheetName] = new Set();
        autoFitColumnWidths(tempSheetName);
    }

    SHEET = tempSheetName;
    CURRENT_PAGE = 0;

    // í™”ë©´ ì „í™˜ - detailScreen ì‚¬ìš©
    document.getElementById('currentSheetName').textContent = tempSheetName;
    document.getElementById('mainScreen').style.display = 'none';
    document.getElementById('detailScreen').style.display = 'flex';

    renderSheetTabs();
    renderSpreadsheet();

    toast(`ì›ë³¸ íŒŒì¼: ${fileName} - ${sheetName} (${processedData.length}í–‰)`);
}


// ì…€ ìŠ¤íƒ€ì¼ ë¬¸ìì—´ ìƒì„±
function buildCellStyle(style, colWidth) {
    let css = '';

    // ì—´ ë„ˆë¹„ (ê¸°ë³¸ 80px)
    const width = colWidth || 80;
    css += `width: ${width}px; min-width: ${width}px; max-width: ${width}px;`;

    if (style.bgColor) css += `background-color: ${style.bgColor};`;
    if (style.color) css += `color: ${style.color};`;
    if (style.bold) css += `font-weight: bold;`;
    if (style.textAlign) css += `text-align: ${style.textAlign};`;
    if (style.verticalAlign) css += `vertical-align: ${style.verticalAlign};`;

    // í…Œë‘ë¦¬
    if (style.border) {
        const b = style.border;
        if (b.top) css += `border-top: 1px solid #000;`;
        if (b.bottom) css += `border-bottom: 1px solid #000;`;
        if (b.left) css += `border-left: 1px solid #000;`;
        if (b.right) css += `border-right: 1px solid #000;`;
    }

    return css;
}

// HTML ì´ìŠ¤ì¼€ì´í”„
function escapeHtml(text) {
    if (text === null || text === undefined) return '';
    return String(text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

// ì›ë³¸ íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬
async function handleRawFileUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    e.target.value = '';

    const ext = getFileExtension(file.name);
    const excelTypes = ['xlsx', 'xls', 'csv'];

    if (!excelTypes.includes(ext)) {
        toast('ì—‘ì…€ íŒŒì¼(.xlsx, .xls, .csv)ë§Œ ì—…ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤');
        return;
    }

    showLoading('ì›ë³¸ íŒŒì¼ ì²˜ë¦¬ ì¤‘...');

    try {
        const fileName = file.name;
        let parsedSheets = {};

        if (ext === 'csv') {
            // CSV íŒŒì¼ ì²˜ë¦¬
            const text = await readFileAsText(file);
            const lines = text.split(/\r?\n/).filter(l => l.trim());
            if (lines.length === 0) {
                hideLoading();
                toast('ë¹ˆ íŒŒì¼ì…ë‹ˆë‹¤');
                return;
            }

            const headers = parseCSVLine(lines[0]);
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const row = parseCSVLine(lines[i]);
                if (row.some(cell => cell.trim())) {
                    data.push(row);
                }
            }

            parsedSheets['Sheet1'] = { headers, data };
        } else {
            // Excel íŒŒì¼ ì²˜ë¦¬ (ìŠ¤íƒ€ì¼ ì •ë³´ í¬í•¨)
            const arrayBuffer = await readFile(file);

            // JSZipìœ¼ë¡œ xlsx ë‚´ë¶€ ìŠ¤íƒ€ì¼ ì¶”ì¶œ
            const styleInfo = await extractXlsxStyles(arrayBuffer);

            const workbook = XLSX.read(arrayBuffer, { type: 'array' });

            workbook.SheetNames.forEach(sheetName => {
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

                if (jsonData.length > 0) {
                    const headers = jsonData[0].map((h, i) => String(h || '') || `ì—´${i+1}`);
                    const data = jsonData.slice(1).filter(row => row.some(cell => cell !== ''));

                    // ì‹œíŠ¸ë³„ ìŠ¤íƒ€ì¼ ì •ë³´ (JSZipì—ì„œ ì¶”ì¶œí•œ ê²ƒ)
                    const sheetStyleInfo = styleInfo.sheetStyles[sheetName] || {};

                    parsedSheets[sheetName] = {
                        headers,
                        data: data.map(row => row.map(cell => String(cell || ''))),
                        styles: sheetStyleInfo.cellStyles || {},
                        merges: sheetStyleInfo.merges || [],
                        colWidths: sheetStyleInfo.colWidths || [],
                        rowHeights: sheetStyleInfo.rowHeights || {},
                        fills: styleInfo.fills,
                        fonts: styleInfo.fonts
                    };
                }
            });
        }

        // ë°ì´í„° ëˆ„ì  ì²˜ë¦¬
        accumulateRawFileData(fileName, parsedSheets);

        hideLoading();
        renderRawFilesList();
        saveRawFilesToLocalStorage();
        toast(`ì›ë³¸ íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: ${fileName}`);

    } catch (err) {
        console.error('ì›ë³¸ íŒŒì¼ ì—…ë¡œë“œ ì˜¤ë¥˜:', err);
        hideLoading();
        toast('íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ');
    }
}

// ë°ì´í„° ëˆ„ì  ì²˜ë¦¬ - displayName ê¸°ë°˜ ìŠ¤ë§ˆíŠ¸ ë³‘í•©
function accumulateRawFileData(fileName, newSheets) {
    const now = new Date().toISOString();

    // 1. ìƒˆ íŒŒì¼ì˜ displayName ì¶”ì¶œ (ë‚ ì§œ/í™•ì¥ì ì œê±°)
    const newDisplayName = fileName
        .replace(/\s*\d{4}\.\d{2}\.\d{2}/g, '')  // ë‚ ì§œ ì œê±°
        .replace(/\s*\(\d+\)/g, '')               // (1), (2) ë“± ì œê±°
        .replace(/\.xlsx?$/i, '')                 // í™•ì¥ì ì œê±°
        .replace(/\.csv$/i, '')
        .trim() || fileName;

    // 2. displayNameì´ ê°™ì€ ê¸°ì¡´ íŒŒì¼ ì°¾ê¸° (í•µì‹¬!)
    let targetFileName = null;
    for (const existingFileName of Object.keys(rawFiles)) {
        if (rawFiles[existingFileName].displayName === newDisplayName) {
            targetFileName = existingFileName;
            break;
        }
    }

    // 3. ë³‘í•© ê²°ê³¼ ìˆ˜ì§‘ìš©
    const mergeResult = {
        isNewFile: !targetFileName,
        displayName: newDisplayName,
        targetFileName: targetFileName || fileName,
        sheetResults: []
    };

    // 4. ëŒ€ìƒ íŒŒì¼ì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
    if (!targetFileName) {
        targetFileName = fileName;
        rawFiles[targetFileName] = {
            name: targetFileName,
            displayName: newDisplayName,
            sheets: {},
            lastUpdated: now,
            totalRows: 0,
            sourceFiles: [fileName]
        };
    } else {
        // ì›ë³¸ íŒŒì¼ëª… ê¸°ë¡
        if (!rawFiles[targetFileName].sourceFiles) {
            rawFiles[targetFileName].sourceFiles = [];
        }
        if (!rawFiles[targetFileName].sourceFiles.includes(fileName)) {
            rawFiles[targetFileName].sourceFiles.push(fileName);
        }
    }

    // 5. ì‹œíŠ¸ëª…ì—ì„œ ë‚ ì§œ ì œê±°í•˜ëŠ” í•¨ìˆ˜
    const getSheetBaseName = (name) => {
        return name
            .replace(/\s*\d{4}\.\d{2}\.\d{2}/g, '')  // 2026.01.15 í˜•ì‹ ì œê±°
            .replace(/\s*\d{4}-\d{2}-\d{2}/g, '')    // 2026-01-15 í˜•ì‹ ì œê±°
            .trim() || name;
    };

    // 6. ì‹œíŠ¸ë³„ ë³‘í•© (ì‹œíŠ¸ ê¸°ë³¸ëª… + í—¤ë” ë§¤ì¹­)
    Object.keys(newSheets).forEach(sheetName => {
        const newSheet = newSheets[sheetName];
        const newSheetBaseName = getSheetBaseName(sheetName);

        const sheetResult = {
            sheetName: sheetName,
            isNewSheet: false,
            totalNewRows: (newSheet.data || []).length,
            addedRows: 0,
            duplicateRows: 0,
            headerMapped: false,
            mergedTo: null
        };

        // ê¸°ì¡´ ì‹œíŠ¸ ì¤‘ ê¸°ë³¸ëª…ì´ ê°™ê³  í—¤ë”ë„ ê°™ì€ ì‹œíŠ¸ ì°¾ê¸°
        let matchedSheetName = null;
        for (const existingSheetName of Object.keys(rawFiles[targetFileName].sheets)) {
            const existingBaseName = getSheetBaseName(existingSheetName);
            const existingSheet = rawFiles[targetFileName].sheets[existingSheetName];

            // ê¸°ë³¸ëª…ì´ ê°™ê³  í—¤ë”ë„ ê°™ìœ¼ë©´ ë§¤ì¹­
            if (existingBaseName === newSheetBaseName &&
                JSON.stringify(existingSheet.headers) === JSON.stringify(newSheet.headers)) {
                matchedSheetName = existingSheetName;
                break;
            }
        }

        if (!matchedSheetName) {
            // ë§¤ì¹­ë˜ëŠ” ì‹œíŠ¸ ì—†ìŒ â†’ ìƒˆ ì‹œíŠ¸ ìƒì„±
            rawFiles[targetFileName].sheets[sheetName] = {
                headers: newSheet.headers,
                data: newSheet.data || [],
                styles: newSheet.styles || {},
                merges: newSheet.merges || [],
                colWidths: newSheet.colWidths || [],
                rowHeights: newSheet.rowHeights || [],
                fills: newSheet.fills || [],
                fonts: newSheet.fonts || [],
                uploadHistory: [{
                    date: now,
                    rowCount: (newSheet.data || []).length,
                    sourceFile: fileName
                }]
            };
            sheetResult.isNewSheet = true;
            sheetResult.addedRows = (newSheet.data || []).length;
        } else {
            // ê¸°ì¡´ ì‹œíŠ¸ì— ë³‘í•©
            const existingSheet = rawFiles[targetFileName].sheets[matchedSheetName];
            sheetResult.mergedTo = matchedSheetName;

            // ì¤‘ë³µ ì œê±° (JSON.stringify ë¹„êµ)
            const existingDataSet = new Set(existingSheet.data.map(row => JSON.stringify(row)));
            const uniqueNewRows = (newSheet.data || []).filter(row => !existingDataSet.has(JSON.stringify(row)));

            sheetResult.duplicateRows = (newSheet.data || []).length - uniqueNewRows.length;
            sheetResult.addedRows = uniqueNewRows.length;

            if (uniqueNewRows.length > 0) {
                existingSheet.data = [...existingSheet.data, ...uniqueNewRows];
                existingSheet.uploadHistory = existingSheet.uploadHistory || [];
                existingSheet.uploadHistory.push({
                    date: now,
                    rowCount: uniqueNewRows.length,
                    sourceFile: fileName,
                    mergedFrom: sheetName !== matchedSheetName ? sheetName : null
                });
            }

            // ì‹œíŠ¸ëª…ì—ì„œ ë‚ ì§œ ì¶”ì¶œ í•¨ìˆ˜
            const extractDate = (name) => {
                const match = name.match(/(\d{4})\.(\d{2})\.(\d{2})/);
                if (match) return new Date(match[1], match[2] - 1, match[3]);
                const match2 = name.match(/(\d{4})-(\d{2})-(\d{2})/);
                if (match2) return new Date(match2[1], match2[2] - 1, match2[3]);
                return null;
            };

            // ìƒˆ ì‹œíŠ¸ ë‚ ì§œê°€ ë” ìµœì‹ ì´ë©´ ì‹œíŠ¸ëª… ë³€ê²½
            const existingDate = extractDate(matchedSheetName);
            const newDate = extractDate(sheetName);
            if (newDate && existingDate && newDate > existingDate && sheetName !== matchedSheetName) {
                rawFiles[targetFileName].sheets[sheetName] = existingSheet;
                delete rawFiles[targetFileName].sheets[matchedSheetName];
                sheetResult.renamedFrom = matchedSheetName;
                sheetResult.mergedTo = sheetName;
            }
        }

        mergeResult.sheetResults.push(sheetResult);
    });

    // 7. ì´ í–‰ ìˆ˜ ì—…ë°ì´íŠ¸
    rawFiles[targetFileName].totalRows = Object.values(rawFiles[targetFileName].sheets)
        .reduce((sum, sheet) => sum + (sheet.data ? sheet.data.length : 0), 0);
    rawFiles[targetFileName].lastUpdated = now;

    // 8. ë³‘í•© ê²°ê³¼ í‘œì‹œ
    mergeResult.targetFileName = targetFileName;
    showSmartMergeResult(mergeResult, fileName);
}

// ìŠ¤ë§ˆíŠ¸ ë³‘í•© ê²°ê³¼ í‘œì‹œ
function showSmartMergeResult(mergeResult, sourceFileName) {
    const { isNewFile, displayName, sheetResults, targetFileName } = mergeResult;

    // ì „ì²´ í†µê³„
    const totalAdded = sheetResults.reduce((sum, r) => sum + r.addedRows, 0);
    const totalDuplicates = sheetResults.reduce((sum, r) => sum + r.duplicateRows, 0);
    const newSheetCount = sheetResults.filter(r => r.isNewSheet).length;
    const mergedSheetCount = sheetResults.filter(r => !r.isNewSheet && r.addedRows > 0).length;

    // ìƒˆ íŒŒì¼ì´ê±°ë‚˜ ì‹œíŠ¸ê°€ 1ê°œë¿ì´ë©´ ê°„ë‹¨í•œ toast
    if (isNewFile) {
        toast(`ìƒˆ íŒŒì¼ ë“±ë¡: ${displayName} (${totalAdded}í–‰)`);
        return;
    }

    if (sheetResults.length === 1) {
        const r = sheetResults[0];
        if (r.addedRows === 0) {
            toast(`'${displayName}' ì¤‘ë³µ ë°ì´í„° (ìƒˆ í–‰ ì—†ìŒ)`);
        } else {
            toast(`'${displayName} - ${r.sheetName}' +${r.addedRows}í–‰ (ì¤‘ë³µ ${r.duplicateRows}ê±´ ì œì™¸)`);
        }
        return;
    }

    // ì—¬ëŸ¬ ì‹œíŠ¸ë©´ ìƒì„¸ ëª¨ë‹¬ í‘œì‹œ
    const modal = document.createElement('div');
    modal.className = 'raw-file-history-modal';
    modal.id = 'smartMergeResultModal';
    modal.innerHTML = `
        <div class="history-modal-content" style="max-width: 500px;">
            <div class="history-modal-header">
                <h3>ğŸ“Š ìŠ¤ë§ˆíŠ¸ ë³‘í•© ì™„ë£Œ</h3>
                <button class="history-modal-close" onclick="this.closest('.raw-file-history-modal').remove()">&times;</button>
            </div>
            <div class="history-modal-body" style="padding: 20px;">
                <div class="merge-file-info">
                    <strong>${escHtml(displayName)}</strong>
                    <span style="color: #666; font-size: 12px;">â† ${escHtml(sourceFileName)}</span>
                </div>
                <div class="merge-result-summary">
                    <div class="merge-stat">
                        <span class="merge-stat-value">+${totalAdded}</span>
                        <span class="merge-stat-label">ì¶”ê°€ëœ í–‰</span>
                    </div>
                    <div class="merge-stat">
                        <span class="merge-stat-value">${totalDuplicates}</span>
                        <span class="merge-stat-label">ì¤‘ë³µ ì œì™¸</span>
                    </div>
                    <div class="merge-stat">
                        <span class="merge-stat-value">${newSheetCount}</span>
                        <span class="merge-stat-label">ìƒˆ ì‹œíŠ¸</span>
                    </div>
                </div>
                <div class="merge-sheet-results">
                    <h4>ì‹œíŠ¸ë³„ ê²°ê³¼</h4>
                    <table class="merge-result-table">
                        <thead>
                            <tr><th>ì‹œíŠ¸ëª…</th><th>ìƒíƒœ</th><th>ì¶”ê°€</th><th>ì¤‘ë³µ</th></tr>
                        </thead>
                        <tbody>
                            ${sheetResults.map(r => `
                                <tr class="${r.addedRows > 0 ? 'has-new' : 'no-change'}">
                                    <td title="${escHtml(r.sheetName)}">${escHtml(r.sheetName.length > 20 ? r.sheetName.substring(0, 20) + '...' : r.sheetName)}</td>
                                    <td>${r.isNewSheet ? 'ğŸ†• ìƒˆ ì‹œíŠ¸' : r.addedRows > 0 ? 'âœ… ë³‘í•©ë¨' : 'âšª ë³€ê²½ì—†ìŒ'}</td>
                                    <td class="num">${r.addedRows > 0 ? '+' + r.addedRows : '-'}</td>
                                    <td class="num">${r.duplicateRows > 0 ? r.duplicateRows : '-'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    `;

    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });

    document.body.appendChild(modal);
}

// ì—´ ë§¤í•‘ í•¨ìˆ˜ (í—¤ë”ê°€ ë‹¤ë¥¼ ë•Œ)
function mapColumnsToExistingHeaders(existingHeaders, newHeaders, newData) {
    // ê¸°ì¡´ í—¤ë” ê¸°ì¤€ìœ¼ë¡œ ìƒˆ ë°ì´í„° ë§¤í•‘
    const columnMap = {};
    existingHeaders.forEach((header, idx) => {
        const newIdx = newHeaders.indexOf(header);
        if (newIdx !== -1) {
            columnMap[idx] = newIdx;
        }
    });

    return (newData || []).map(row => {
        const mappedRow = existingHeaders.map((_, idx) => {
            if (columnMap[idx] !== undefined && row[columnMap[idx]] !== undefined) {
                return String(row[columnMap[idx]]);
            }
            return '';
        });
        return mappedRow;
    });
}

// xlsx íŒŒì¼ì—ì„œ ìŠ¤íƒ€ì¼ ì§ì ‘ ì¶”ì¶œ (JSZip ì‚¬ìš©)
async function extractXlsxStyles(arrayBuffer) {
    const result = {
        fills: [],
        fonts: [],
        cellXfs: [],
        sheetStyles: {}
    };

    try {
        const zip = await JSZip.loadAsync(arrayBuffer);

        // styles.xml íŒŒì‹±
        const stylesXml = await zip.file('xl/styles.xml')?.async('string');
        if (stylesXml) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(stylesXml, 'text/xml');

            // fills ì¶”ì¶œ
            const fills = doc.querySelectorAll('fills > fill');
            fills.forEach((fill, idx) => {
                const patternFill = fill.querySelector('patternFill');
                if (patternFill) {
                    const fgColor = patternFill.querySelector('fgColor');
                    const bgColor = patternFill.querySelector('bgColor');
                    let color = null;

                    if (fgColor) {
                        color = fgColor.getAttribute('rgb') || fgColor.getAttribute('indexed');
                        if (color && color.length === 8) color = '#' + color.substring(2);
                        else if (color) color = getIndexedColor(parseInt(color));
                    }
                    if (!color && bgColor) {
                        color = bgColor.getAttribute('rgb') || bgColor.getAttribute('indexed');
                        if (color && color.length === 8) color = '#' + color.substring(2);
                        else if (color) color = getIndexedColor(parseInt(color));
                    }

                    result.fills.push({ color });
                } else {
                    result.fills.push({ color: null });
                }
            });

            // fonts ì¶”ì¶œ
            const fonts = doc.querySelectorAll('fonts > font');
            fonts.forEach(font => {
                const fontObj = {};
                const bold = font.querySelector('b');
                const color = font.querySelector('color');
                const sz = font.querySelector('sz');

                if (bold) fontObj.bold = true;
                if (color) {
                    const rgb = color.getAttribute('rgb');
                    if (rgb && rgb.length === 8) fontObj.color = '#' + rgb.substring(2);
                }
                if (sz) fontObj.size = parseFloat(sz.getAttribute('val'));

                result.fonts.push(fontObj);
            });

            // cellXfs ì¶”ì¶œ (ì…€ ìŠ¤íƒ€ì¼ ì°¸ì¡°)
            const cellXfs = doc.querySelectorAll('cellXfs > xf');
            cellXfs.forEach(xf => {
                result.cellXfs.push({
                    fillId: parseInt(xf.getAttribute('fillId') || 0),
                    fontId: parseInt(xf.getAttribute('fontId') || 0),
                    borderId: parseInt(xf.getAttribute('borderId') || 0)
                });
            });
        }

        // ê° ì‹œíŠ¸ì˜ ì…€ ìŠ¤íƒ€ì¼ ë§¤í•‘
        const workbookXml = await zip.file('xl/workbook.xml')?.async('string');
        if (workbookXml) {
            const parser = new DOMParser();
            const wbDoc = parser.parseFromString(workbookXml, 'text/xml');
            const sheets = wbDoc.querySelectorAll('sheet');

            for (let i = 0; i < sheets.length; i++) {
                const sheetName = sheets[i].getAttribute('name');
                const sheetFile = `xl/worksheets/sheet${i + 1}.xml`;
                const sheetXml = await zip.file(sheetFile)?.async('string');

                if (sheetXml) {
                    const sheetDoc = parser.parseFromString(sheetXml, 'text/xml');
                    const rows = sheetDoc.querySelectorAll('sheetData > row');
                    const sheetStyles = {};
                    const sheetColWidths = [];
                    const sheetRowHeights = {};
                    const sheetMerges = [];

                    // ì—´ ë„ˆë¹„ ì¶”ì¶œ
                    const cols = sheetDoc.querySelectorAll('cols > col');
                    cols.forEach(col => {
                        const min = parseInt(col.getAttribute('min') || 1) - 1;
                        const max = parseInt(col.getAttribute('max') || 1) - 1;
                        const width = parseFloat(col.getAttribute('width') || 8.43);
                        const widthPx = Math.round(width * 7); // ëŒ€ëµì  ë³€í™˜
                        for (let c = min; c <= max; c++) {
                            sheetColWidths[c] = widthPx;
                        }
                    });

                    // ë³‘í•© ì…€ ì¶”ì¶œ
                    const mergeCells = sheetDoc.querySelectorAll('mergeCells > mergeCell');
                    mergeCells.forEach(merge => {
                        const ref = merge.getAttribute('ref');
                        if (ref) {
                            const [start, end] = ref.split(':');
                            const startCol = cellRefToColIdx(start);
                            const startRow = parseInt(start.match(/\d+/)[0]) - 1;
                            const endCol = cellRefToColIdx(end);
                            const endRow = parseInt(end.match(/\d+/)[0]) - 1;
                            sheetMerges.push({
                                startRow, startCol, endRow, endCol
                            });
                        }
                    });

                    // í–‰ ë†’ì´ ë° ì…€ ìŠ¤íƒ€ì¼ ì¶”ì¶œ
                    rows.forEach(row => {
                        const rowIdx = parseInt(row.getAttribute('r')) - 1;
                        const ht = row.getAttribute('ht');
                        if (ht) {
                            sheetRowHeights[rowIdx] = Math.round(parseFloat(ht));
                        }

                        const cells = row.querySelectorAll('c');
                        cells.forEach(cell => {
                            const cellRef = cell.getAttribute('r');
                            const styleIdx = parseInt(cell.getAttribute('s') || 0);
                            const colIdx = cellRefToColIdx(cellRef);

                            // ëª¨ë“  ìŠ¤íƒ€ì¼ ì¸ë±ìŠ¤ ì²˜ë¦¬ (0 í¬í•¨)
                            if (result.cellXfs[styleIdx]) {
                                const xf = result.cellXfs[styleIdx];
                                const styleObj = {};

                                // ë°°ê²½ìƒ‰ (fillId 0, 1ì€ ê¸°ë³¸ê°’ì´ë¯€ë¡œ 2ë¶€í„°)
                                if (xf.fillId >= 2 && result.fills[xf.fillId]) {
                                    const fillColor = result.fills[xf.fillId].color;
                                    if (fillColor) styleObj.bgColor = fillColor;
                                }

                                // í°íŠ¸
                                if (result.fonts[xf.fontId]) {
                                    const font = result.fonts[xf.fontId];
                                    if (font.bold) styleObj.bold = true;
                                    if (font.color) styleObj.color = font.color;
                                }

                                if (Object.keys(styleObj).length > 0) {
                                    sheetStyles[`${rowIdx},${colIdx}`] = styleObj;
                                }
                            }
                        });
                    });

                    result.sheetStyles[sheetName] = {
                        cellStyles: sheetStyles,
                        colWidths: sheetColWidths,
                        rowHeights: sheetRowHeights,
                        merges: sheetMerges
                    };
                }
            }
        }
    } catch (e) {
        console.error('ìŠ¤íƒ€ì¼ ì¶”ì¶œ ì˜¤ë¥˜:', e);
    }

    return result;
}

// ì…€ ì°¸ì¡°ë¥¼ ì—´ ì¸ë±ìŠ¤ë¡œ ë³€í™˜ (A1 -> 0, B1 -> 1, ...)
function cellRefToColIdx(ref) {
    const match = ref.match(/^([A-Z]+)/);
    if (!match) return 0;
    const col = match[1];
    let idx = 0;
    for (let i = 0; i < col.length; i++) {
        idx = idx * 26 + (col.charCodeAt(i) - 64);
    }
    return idx - 1;
}

// Excel ì¸ë±ìŠ¤ ìƒ‰ìƒ
function getIndexedColor(idx) {
    const indexedColors = [
        '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
        '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
        '#800000', '#008000', '#000080', '#808000', '#800080', '#008080', '#C0C0C0', '#808080',
        '#9999FF', '#993366', '#FFFFCC', '#CCFFFF', '#660066', '#FF8080', '#0066CC', '#CCCCFF',
        '#000080', '#FF00FF', '#FFFF00', '#00FFFF', '#800080', '#800000', '#008080', '#0000FF',
        '#00CCFF', '#CCFFFF', '#CCFFCC', '#FFFF99', '#99CCFF', '#FF99CC', '#CC99FF', '#FFCC99',
        '#3366FF', '#33CCCC', '#99CC00', '#FFCC00', '#FF9900', '#FF6600', '#666699', '#969696',
        '#003366', '#339966', '#003300', '#333300', '#993300', '#993366', '#333399', '#333333'
    ];
    return indexedColors[idx] || '#FFFFFF';
}

// ì—‘ì…€ ì‹œíŠ¸ ìŠ¤íƒ€ì¼ ì¶”ì¶œ (ê¸°ì¡´ - ì‚¬ìš© ì•ˆ í•¨)
function extractSheetStyles(worksheet) {
    const styles = {};
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');

    for (let r = range.s.r; r <= range.e.r; r++) {
        for (let c = range.s.c; c <= range.e.c; c++) {
            const cellAddr = XLSX.utils.encode_cell({ r, c });
            const cell = worksheet[cellAddr];

            if (cell && cell.s) {
                const s = cell.s;
                const styleObj = {};

                // ë°°ê²½ìƒ‰
                if (s.fill && s.fill.fgColor) {
                    if (s.fill.fgColor.rgb) {
                        styleObj.bgColor = '#' + s.fill.fgColor.rgb;
                    } else if (s.fill.fgColor.theme !== undefined) {
                        styleObj.bgColor = getThemeColor(s.fill.fgColor.theme, s.fill.fgColor.tint);
                    }
                }

                // ê¸€ììƒ‰
                if (s.font && s.font.color) {
                    if (s.font.color.rgb) {
                        styleObj.color = '#' + s.font.color.rgb;
                    }
                }

                // ê¸€ì êµµê¸°
                if (s.font && s.font.bold) {
                    styleObj.bold = true;
                }

                // ì •ë ¬
                if (s.alignment) {
                    if (s.alignment.horizontal) styleObj.textAlign = s.alignment.horizontal;
                    if (s.alignment.vertical) styleObj.verticalAlign = s.alignment.vertical;
                }

                // í…Œë‘ë¦¬
                if (s.border) {
                    styleObj.border = s.border;
                }

                if (Object.keys(styleObj).length > 0) {
                    styles[`${r},${c}`] = styleObj;
                }
            }
        }
    }

    return styles;
}

// í…Œë§ˆ ìƒ‰ìƒ ë³€í™˜ (Excel í…Œë§ˆ)
function getThemeColor(theme, tint) {
    const themeColors = [
        '#FFFFFF', '#000000', '#E7E6E6', '#44546A',
        '#4472C4', '#ED7D31', '#A5A5A5', '#FFC000',
        '#5B9BD5', '#70AD47'
    ];
    let color = themeColors[theme] || '#FFFFFF';

    if (tint) {
        // tint ì ìš© (ê°„ë‹¨í•œ êµ¬í˜„)
        color = applyTint(color, tint);
    }

    return color;
}

// tint ì ìš©
function applyTint(hexColor, tint) {
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);

    let newR, newG, newB;
    if (tint < 0) {
        newR = Math.round(r * (1 + tint));
        newG = Math.round(g * (1 + tint));
        newB = Math.round(b * (1 + tint));
    } else {
        newR = Math.round(r + (255 - r) * tint);
        newG = Math.round(g + (255 - g) * tint);
        newB = Math.round(b + (255 - b) * tint);
    }

    return '#' + [newR, newG, newB].map(x => x.toString(16).padStart(2, '0')).join('');
}

// CSV ë¼ì¸ íŒŒì‹±
function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
                current += '"';
                i++;
            } else {
                inQuotes = !inQuotes;
            }
        } else if (char === ',' && !inQuotes) {
            result.push(current);
            current = '';
        } else {
            current += char;
        }
    }
    result.push(current);
    return result;
}

// ì›ë³¸ íŒŒì¼ ì‚­ì œ
function deleteRawFile(fileName) {
    if (!confirm(`'${fileName}' ì›ë³¸ íŒŒì¼ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nëˆ„ì ëœ ëª¨ë“  ë°ì´í„°ê°€ ì‚­ì œë©ë‹ˆë‹¤.`)) return;

    delete rawFiles[fileName];

    if (currentRawFile === fileName) {
        currentRawFile = null;
        currentRawSheet = null;
    }

    renderRawFilesList();
    saveRawFilesToLocalStorage();
    toast(`ì›ë³¸ íŒŒì¼ ì‚­ì œë¨: ${fileName}`);
}

// ì›ë³¸ íŒŒì¼ ë‹¤ìš´ë¡œë“œ
function downloadRawFile(fileName) {
    if (!rawFiles[fileName]) return;

    const fileData = rawFiles[fileName];
    const wb = XLSX.utils.book_new();

    Object.keys(fileData.sheets).forEach(sheetName => {
        const sheet = fileData.sheets[sheetName];
        const wsData = [sheet.headers, ...sheet.data];
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        XLSX.utils.book_append_sheet(wb, ws, sheetName.substring(0, 31));
    });

    XLSX.writeFile(wb, fileName);
    toast(`ë‹¤ìš´ë¡œë“œ: ${fileName}`);
}

// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì €ì¥
function saveRawFilesToLocalStorage() {
    try {
        localStorage.setItem('excelmaster_rawfiles', JSON.stringify(rawFiles));
    } catch (e) {
        console.error('ì›ë³¸ íŒŒì¼ ë¡œì»¬ ì €ì¥ ì˜¤ë¥˜:', e);
    }
}

// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°
function loadRawFilesFromLocalStorage() {
    try {
        const saved = localStorage.getItem('excelmaster_rawfiles');
        if (saved) {
            rawFiles = JSON.parse(saved);
            console.log('ì›ë³¸ íŒŒì¼ ë¡œë“œë¨:', Object.keys(rawFiles).length, 'ê°œ');
        }
    } catch (e) {
        console.error('ì›ë³¸ íŒŒì¼ ë¡œì»¬ ë¡œë“œ ì˜¤ë¥˜:', e);
        rawFiles = {};
    }
}

// ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„¤ì •
function setupRawFilesDragDrop() {
    const uploadArea = document.getElementById('rawFilesUploadArea');
    if (!uploadArea) return;

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
        });
    });

    ['dragenter', 'dragover'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.add('dragover');
        });
    });

    ['dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, () => {
            uploadArea.classList.remove('dragover');
        });
    });

    uploadArea.addEventListener('drop', (e) => {
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            // ì²« ë²ˆì§¸ íŒŒì¼ë§Œ ì²˜ë¦¬
            const file = files[0];
            const input = document.getElementById('rawFileInput');
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            input.files = dataTransfer.files;
            handleRawFileUpload({ target: input });
        }
    });
}

// ===== íŒŒì¼ ì—…ë¡œë“œ í•¸ë“¤ëŸ¬ ìˆ˜ì • =====
function handleDocumentUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    e.target.value = '';
    
    const ext = getFileExtension(file.name);
    
    const excelTypes = ['xlsx', 'xls', 'csv', 'tsv'];
    const docTypes = ['pdf', 'pptx', 'ppt', 'docx', 'doc', 'txt', 'html', 'htm'];
    
    if (excelTypes.includes(ext)) {
        // ì—‘ì…€/CSV íŒŒì¼ â†’ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬
        handleMainUploadOriginal(file);
    } else if (docTypes.includes(ext)) {
        // ë¬¸ì„œ íŒŒì¼ â†’ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ (ì›ë³¸ ì €ì¥ / ì‹œíŠ¸ ë³€í™˜ / ë‘˜ë‹¤)
        showUploadChoiceModal(file);
    } else {
        toast('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤: ' + ext);
    }
}

// ê¸°ì¡´ handleMainUploadë¥¼ ë°±ì—…í•˜ê³  ìƒˆ í•¨ìˆ˜ë¡œ ëŒ€ì²´
const handleMainUploadOriginal = async function(file) {
    if (!file) return;

    if (file.size > MAX_FILE_SIZE) {
        toast(`íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤ (${(file.size/1024/1024).toFixed(1)}MB). ìµœëŒ€ 100MBê¹Œì§€ ì§€ì›í•©ë‹ˆë‹¤.`);
        return;
    }

    isLargeFile = file.size > 50 * 1024 * 1024;
    if (isLargeFile) {
        console.log('ëŒ€ìš©ëŸ‰ íŒŒì¼ ëª¨ë“œ í™œì„±í™”');
        startMemoryManagement();
    }

    const sizeMB = (file.size / 1024 / 1024).toFixed(1);
    const fileName = file.name.toLowerCase();

    // íŒŒì¼ ê·¸ë£¹ ì‹œìŠ¤í…œìš© íŒŒì¼ëª… ì €ì¥
    currentUploadFileName = file.name;

    showLoading(`íŒŒì¼ ì½ëŠ” ì¤‘... (${sizeMB}MB)`);

    try {
        if (fileName.endsWith('.csv') || fileName.endsWith('.tsv') || fileName.endsWith('.txt')) {
            const text = await readFileAsText(file);
            updateLoadingText('í…ìŠ¤íŠ¸ ë°ì´í„° ë¶„ì„ ì¤‘...');
            await parseTextFile(text, file.name);
        } else {
            const data = await readFile(file);
            updateLoadingText('ë°ì´í„° ë¶„ì„ ì¤‘...');
            await parseExcelOptimized(data);
        }
        hideLoading();
        saveToLocalStorage(); // ë¡œì»¬ ì €ì¥ì†Œì— ì €ì¥
        saveFileGroupsToStorage(); // íŒŒì¼ ê·¸ë£¹ ì €ì¥

        // ì‹œíŠ¸ ëª©ë¡ íƒ­ìœ¼ë¡œ ì „í™˜ ë° ë Œë”ë§
        switchMainTab('sheets');
        renderMainScreen();
        toast('íŒŒì¼ ë¡œë“œ ì™„ë£Œ!');
    } catch (err) {
        console.error(err);
        hideLoading();
        toast('íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜');
    } finally {
        currentUploadFileName = ''; // ì´ˆê¸°í™”
    }
};

// ===================================================================
// ì—´/í–‰ í¬ê¸° ì¡°ì ˆ ê¸°ëŠ¥ (ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œ)
// ===================================================================

// ì—´/í–‰ í¬ê¸° ì €ì¥ ê°ì²´
let COL_WIDTHS = {};  // { sheetName: { colIndex: width } }
let ROW_HEIGHTS = {}; // { sheetName: { rowIndex: height } }

// ê¸€ì í¬ê¸° ì¡°ì ˆ
let currentFontSize = 100; // í¼ì„¼íŠ¸ (ê¸°ë³¸ 100%)
const FONT_SIZE_STEP = 10; // ì¦ê° ë‹¨ìœ„
const FONT_SIZE_MIN = 70;  // ìµœì†Œ 70%
const FONT_SIZE_MAX = 150; // ìµœëŒ€ 150%

// ê¸€ì í¬ê¸° ì¦ê°€
function increaseFontSize() {
    if (currentFontSize >= FONT_SIZE_MAX) {
        toast('ìµœëŒ€ í¬ê¸°ì…ë‹ˆë‹¤');
        return;
    }
    currentFontSize += FONT_SIZE_STEP;
    applyFontSize();
    saveFontSizeToStorage();
    toast(`ê¸€ì í¬ê¸°: ${currentFontSize}%`);
}

// ê¸€ì í¬ê¸° ê°ì†Œ
function decreaseFontSize() {
    if (currentFontSize <= FONT_SIZE_MIN) {
        toast('ìµœì†Œ í¬ê¸°ì…ë‹ˆë‹¤');
        return;
    }
    currentFontSize -= FONT_SIZE_STEP;
    applyFontSize();
    saveFontSizeToStorage();
    toast(`ê¸€ì í¬ê¸°: ${currentFontSize}%`);
}

// ê¸€ì í¬ê¸° ì ìš©
function applyFontSize() {
    const spreadsheet = document.getElementById('spreadsheet');
    if (!spreadsheet) return;
    
    // ê¸°ë³¸ í°íŠ¸ ì‚¬ì´ì¦ˆ 13px ê¸°ì¤€
    const baseFontSize = 13;
    const newFontSize = baseFontSize * (currentFontSize / 100);
    
    // í–‰ ë†’ì´ë„ ë¹„ë¡€ ì¡°ì •
    const baseRowHeight = 26;
    const newRowHeight = baseRowHeight * (currentFontSize / 100);
    
    // CSS ë³€ìˆ˜ë¡œ í•œ ë²ˆì— ì ìš© (ì„±ëŠ¥ ìµœì í™”)
    spreadsheet.style.setProperty('--cell-font-size', newFontSize + 'px');
    spreadsheet.style.setProperty('--cell-row-height', newRowHeight + 'px');
    spreadsheet.style.fontSize = newFontSize + 'px';
    
    // í–‰ í—¤ë” ì œì™¸í•˜ê³  ì…€ë§Œ ì„ íƒ (ì„±ëŠ¥ ìµœì í™”)
    const cells = spreadsheet.querySelectorAll('td.cell, th.col-header');
    cells.forEach(cell => {
        cell.style.fontSize = newFontSize + 'px';
    });
    
    // í–‰ ë†’ì´ ì¡°ì • (tr ë‹¨ìœ„ë¡œ)
    const rows = spreadsheet.querySelectorAll('tbody tr');
    rows.forEach(row => {
        row.style.height = newRowHeight + 'px';
    });
    
    // í‘œì‹œ ì—…ë°ì´íŠ¸
    const display = document.getElementById('fontSizeDisplay');
    if (display) {
        display.textContent = currentFontSize + '%';
    }
}

// ê¸€ì í¬ê¸° ë¡œì»¬ ì €ì¥
function saveFontSizeToStorage() {
    try {
        localStorage.setItem('excelmaster_fontSize', currentFontSize.toString());
    } catch (e) {
        console.error('ê¸€ì í¬ê¸° ì €ì¥ ì‹¤íŒ¨:', e);
    }
}

// ê¸€ì í¬ê¸° ë¡œì»¬ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°
function loadFontSizeFromStorage() {
    try {
        const saved = localStorage.getItem('excelmaster_fontSize');
        if (saved) {
            const size = parseInt(saved);
            if (size >= FONT_SIZE_MIN && size <= FONT_SIZE_MAX) {
                currentFontSize = size;
            }
        }
    } catch (e) {
        console.error('ê¸€ì í¬ê¸° ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
    }
}

// ë¦¬ì‚¬ì´ì¦ˆ ìƒíƒœ
let isResizing = false;
let resizeType = null; // 'col' or 'row'
let resizeIndex = null;
let resizeStartPos = 0;
let resizeStartSize = 0;
let resizeGuide = null;
let resizeIndicator = null;

// ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œ í† ê¸€
function toggleResizeMode() {
    RESIZE_MODE = !RESIZE_MODE;
    const btn = document.getElementById('resizeModeBtn');
    const container = document.getElementById('spreadsheetContainer');
    
    if (RESIZE_MODE) {
        btn.classList.add('active');
        btn.style.background = 'var(--retro-coral)';
        btn.style.color = 'white';
        btn.textContent = 'í¬ê¸° ì¡°ì ˆ âœ“';
        container.classList.add('resize-mode');
        
        // ì—´ í—¤ë” ë“œë˜ê·¸ ë¹„í™œì„±í™”
        document.querySelectorAll('.col-header').forEach(el => {
            el.setAttribute('draggable', 'false');
        });
        
        // ì¸ë””ì¼€ì´í„° í‘œì‹œ
        showResizeIndicator();
        
        toast('í¬ê¸° ì¡°ì ˆ ëª¨ë“œ: ì—´/í–‰ í—¤ë”ë¥¼ ë“œë˜ê·¸í•˜ì„¸ìš”');
    } else {
        btn.classList.remove('active');
        btn.style.background = '';
        btn.style.color = '';
        btn.textContent = 'í¬ê¸° ì¡°ì ˆ';
        container.classList.remove('resize-mode');
        
        // ì—´ í—¤ë” ë“œë˜ê·¸ ë‹¤ì‹œ í™œì„±í™”
        document.querySelectorAll('.col-header').forEach(el => {
            el.setAttribute('draggable', 'true');
        });
        
        // ì¸ë””ì¼€ì´í„° ìˆ¨ê¸°ê¸°
        hideResizeIndicator();
        
        toast('í¬ê¸° ì¡°ì ˆ ëª¨ë“œ ì¢…ë£Œ');
    }
}

// ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œ ì¸ë””ì¼€ì´í„° í‘œì‹œ
function showResizeIndicator() {
    if (resizeIndicator) return;
    resizeIndicator = document.createElement('div');
    resizeIndicator.className = 'resize-mode-indicator';
    resizeIndicator.innerHTML = 'ğŸ“ í¬ê¸° ì¡°ì ˆ ëª¨ë“œ - ì—´/í–‰ í—¤ë”ë¥¼ ë“œë˜ê·¸ | ESCë¡œ ì¢…ë£Œ';
    document.body.appendChild(resizeIndicator);
}

// ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œ ì¸ë””ì¼€ì´í„° ìˆ¨ê¸°ê¸°
function hideResizeIndicator() {
    if (resizeIndicator) {
        resizeIndicator.remove();
        resizeIndicator = null;
    }
}

// ìŠ¤í”„ë ˆë“œì‹œíŠ¸ì— ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œ ì´ë²¤íŠ¸ ì¶”ê°€
function setupResizeEvents() {
    const container = document.getElementById('spreadsheetContainer');
    if (!container) return;
    
    // ìº¡ì²˜ ë‹¨ê³„ì—ì„œ ë“±ë¡í•˜ì—¬ draggableë³´ë‹¤ ë¨¼ì € ì´ë²¤íŠ¸ ì²˜ë¦¬
    container.addEventListener('mousedown', handleResizeModeStart, true);
    
    // ESC í‚¤ë¡œ ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œ ì¢…ë£Œ
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && RESIZE_MODE) {
            toggleResizeMode();
        }
    });
}

// ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œì—ì„œ ë“œë˜ê·¸ ì‹œì‘
function handleResizeModeStart(e) {
    if (!RESIZE_MODE) return;
    
    const colHeader = e.target.closest('.col-header');
    const rowHeader = e.target.closest('.row-header');
    
    if (colHeader) {
        e.preventDefault();
        e.stopPropagation();
        saveState('ì—´ ë„ˆë¹„ ë³€ê²½');
        const realCol = parseInt(colHeader.dataset.realcol);
        startColResizeMode(e, realCol, colHeader);
        return;
    }
    
    if (rowHeader) {
        e.preventDefault();
        e.stopPropagation();
        saveState('í–‰ ë†’ì´ ë³€ê²½');
        const rowIndex = parseInt(rowHeader.dataset.row);
        startRowResizeMode(e, rowIndex, rowHeader);
        return;
    }
}

// ì—´ í¬ê¸° ì¡°ì ˆ ì‹œì‘ (ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œ)
function startColResizeMode(e, colIndex, targetEl) {
    isResizing = true;
    resizeType = 'col';
    resizeIndex = colIndex;
    resizeStartPos = e.clientX;
    
    const table = document.getElementById('spreadsheet');
    const col = table.querySelector(`col[data-realcol="${colIndex}"]`);
    resizeStartSize = col ? parseInt(col.style.width) || 100 : targetEl.offsetWidth;
    
    // ê°€ì´ë“œ ë¼ì¸ ìƒì„±
    resizeGuide = document.createElement('div');
    resizeGuide.className = 'resize-guide col';
    resizeGuide.style.left = e.clientX + 'px';
    document.body.appendChild(resizeGuide);
    
    // íƒ€ê²Ÿ í•˜ì´ë¼ì´íŠ¸
    targetEl.style.background = 'var(--retro-coral)';
    targetEl.style.color = 'white';
    
    // ì „ì—­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
    document.addEventListener('mousemove', handleResizeModeMove);
    document.addEventListener('mouseup', handleResizeModeEnd);
    
    // ë“œë˜ê·¸ ì¤‘ ì„ íƒ ë°©ì§€
    document.body.style.userSelect = 'none';
    document.body.style.cursor = 'col-resize';
}

// í–‰ í¬ê¸° ì¡°ì ˆ ì‹œì‘ (ë¦¬ì‚¬ì´ì¦ˆ ëª¨ë“œ)
function startRowResizeMode(e, rowIndex, targetEl) {
    isResizing = true;
    resizeType = 'row';
    resizeIndex = rowIndex;
    resizeStartPos = e.clientY;
    
    // í˜„ì¬ í–‰ ë†’ì´ ê°€ì ¸ì˜¤ê¸°
    const tr = targetEl.closest('tr');
    resizeStartSize = tr ? tr.offsetHeight : 26;
    
    // ê°€ì´ë“œ ë¼ì¸ ìƒì„±
    resizeGuide = document.createElement('div');
    resizeGuide.className = 'resize-guide row';
    resizeGuide.style.top = e.clientY + 'px';
    document.body.appendChild(resizeGuide);
    
    // íƒ€ê²Ÿ í•˜ì´ë¼ì´íŠ¸
    targetEl.style.background = 'var(--retro-coral)';
    targetEl.style.color = 'white';
    
    // ì „ì—­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
    document.addEventListener('mousemove', handleResizeModeMove);
    document.addEventListener('mouseup', handleResizeModeEnd);
    
    // ë“œë˜ê·¸ ì¤‘ ì„ íƒ ë°©ì§€
    document.body.style.userSelect = 'none';
    document.body.style.cursor = 'row-resize';
}

// ë¦¬ì‚¬ì´ì¦ˆ ë“œë˜ê·¸ ì¤‘
function handleResizeModeMove(e) {
    if (!isResizing) return;
    
    if (resizeType === 'col') {
        resizeGuide.style.left = e.clientX + 'px';
        const delta = e.clientX - resizeStartPos;
        const newWidth = Math.max(30, resizeStartSize + delta);
        if (resizeIndicator) resizeIndicator.innerHTML = `ğŸ“ ì—´ ë„ˆë¹„: ${Math.round(newWidth)}px`;
    } else {
        resizeGuide.style.top = e.clientY + 'px';
        const delta = e.clientY - resizeStartPos;
        const newHeight = Math.max(20, resizeStartSize + delta);
        if (resizeIndicator) resizeIndicator.innerHTML = `ğŸ“ í–‰ ë†’ì´: ${Math.round(newHeight)}px`;
    }
}

// ë¦¬ì‚¬ì´ì¦ˆ ì¢…ë£Œ
function handleResizeModeEnd(e) {
    if (!isResizing) return;
    
    let newSize;
    if (resizeType === 'col') {
        const delta = e.clientX - resizeStartPos;
        newSize = Math.max(30, resizeStartSize + delta);
        if (!COL_WIDTHS[SHEET]) COL_WIDTHS[SHEET] = {};
        COL_WIDTHS[SHEET][resizeIndex] = newSize;
    } else {
        const delta = e.clientY - resizeStartPos;
        newSize = Math.max(20, resizeStartSize + delta);
        if (!ROW_HEIGHTS[SHEET]) ROW_HEIGHTS[SHEET] = {};
        ROW_HEIGHTS[SHEET][resizeIndex] = newSize;
    }
    
    // ì •ë¦¬
    if (resizeGuide) {
        resizeGuide.remove();
        resizeGuide = null;
    }
    
    document.removeEventListener('mousemove', handleResizeModeMove);
    document.removeEventListener('mouseup', handleResizeModeEnd);
    
    document.body.style.userSelect = '';
    document.body.style.cursor = '';
    
    isResizing = false;
    resizeType = null;
    resizeIndex = null;
    
    // ì¸ë””ì¼€ì´í„° ë³µì›
    if (resizeIndicator) {
        resizeIndicator.innerHTML = 'ğŸ“ í¬ê¸° ì¡°ì ˆ ëª¨ë“œ - ì—´/í–‰ í—¤ë”ë¥¼ ë“œë˜ê·¸ | ESCë¡œ ì¢…ë£Œ';
    }
    
    // ìŠ¤í”„ë ˆë“œì‹œíŠ¸ ë‹¤ì‹œ ë Œë”ë§
    renderSpreadsheet();
    
    toast(`í¬ê¸° ë³€ê²½: ${Math.round(newSize)}px`);
}

// ì—´ ë„ˆë¹„ ê°€ì ¸ì˜¤ê¸°
function getColWidth(sheetName, colIndex) {
    if (COL_WIDTHS[sheetName] && COL_WIDTHS[sheetName][colIndex] !== undefined) {
        return COL_WIDTHS[sheetName][colIndex];
    }
    return 120; // ê¸°ë³¸ ë„ˆë¹„ ì¦ê°€ (100 â†’ 120)
}

// ì—´ ë„ˆë¹„ ìë™ ê³„ì‚° (ë‚´ìš© ê¸°ë°˜)
function autoFitColumnWidths(sheetName) {
    const sheet = WB[sheetName];
    if (!sheet) return;
    
    if (!COL_WIDTHS[sheetName]) {
        COL_WIDTHS[sheetName] = {};
    }
    
    const headers = sheet.headers;
    const data = sheet.data;
    
    // ìƒ˜í”Œ í–‰ ìˆ˜ (ì„±ëŠ¥ì„ ìœ„í•´ ì²˜ìŒ 100í–‰ë§Œ ê²€ì‚¬)
    const sampleRows = Math.min(data.length, 100);
    
    for (let colIdx = 0; colIdx < headers.length; colIdx++) {
        // ì´ë¯¸ ì‚¬ìš©ìê°€ ì„¤ì •í•œ ë„ˆë¹„ê°€ ìˆìœ¼ë©´ ê±´ë„ˆë›°ê¸°
        if (COL_WIDTHS[sheetName][colIdx] !== undefined) continue;
        
        let maxLen = 0;
        
        // í—¤ë” ê¸¸ì´
        const headerText = headers[colIdx] || '';
        maxLen = Math.max(maxLen, getTextWidth(headerText));
        
        // ë°ì´í„° ê¸¸ì´ (ìƒ˜í”Œ)
        for (let i = 0; i < sampleRows; i++) {
            const cellVal = data[i][colIdx];
            if (cellVal !== undefined && cellVal !== null) {
                const textLen = getTextWidth(String(cellVal));
                maxLen = Math.max(maxLen, textLen);
            }
        }
        
        // ìµœì†Œ 100, ìµœëŒ€ 400 (ê¸€ì ì•ˆ ì˜ë¦¬ê²Œ ë„‰ë„‰íˆ)
        const calculatedWidth = Math.min(400, Math.max(100, maxLen + 24));
        COL_WIDTHS[sheetName][colIdx] = calculatedWidth;
    }
}

// í…ìŠ¤íŠ¸ ë„ˆë¹„ ê³„ì‚° (ëŒ€ëµì )
function getTextWidth(text) {
    if (!text) return 0;
    
    let width = 0;
    for (let i = 0; i < text.length; i++) {
        const char = text.charCodeAt(i);
        // í•œê¸€, í•œì ë“± ì „ê° ë¬¸ì
        if (char >= 0x1100 && char <= 0x11FF ||  // í•œê¸€ ìëª¨
            char >= 0x3000 && char <= 0x9FFF ||  // CJK
            char >= 0xAC00 && char <= 0xD7AF) {  // í•œê¸€ ì™„ì„±í˜•
            width += 14; // ì „ê° ë¬¸ì
        } else {
            width += 8; // ë°˜ê° ë¬¸ì
        }
    }
    return width;
}

// í–‰ ë†’ì´ ê°€ì ¸ì˜¤ê¸°
function getRowHeight(sheetName, rowIndex) {
    if (ROW_HEIGHTS[sheetName] && ROW_HEIGHTS[sheetName][rowIndex]) {
        return ROW_HEIGHTS[sheetName][rowIndex];
    }
    return 26; // ê¸°ë³¸ ë†’ì´
}

// ì—´ ë„ˆë¹„ ì´ˆê¸°í™”
function resetColumnWidths() {
    if (SHEET && COL_WIDTHS[SHEET]) {
        delete COL_WIDTHS[SHEET];
        renderSpreadsheet();
        toast('ì—´ ë„ˆë¹„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
    }
}

// í–‰ ë†’ì´ ì´ˆê¸°í™”
function resetRowHeights() {
    if (SHEET && ROW_HEIGHTS[SHEET]) {
        delete ROW_HEIGHTS[SHEET];
        renderSpreadsheet();
        toast('í–‰ ë†’ì´ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
    }
}

// ëª¨ë“  í¬ê¸° ì´ˆê¸°í™”
function resetAllSizes() {
    if (SHEET) {
        delete COL_WIDTHS[SHEET];
        delete ROW_HEIGHTS[SHEET];
        renderSpreadsheet();
        toast('ì—´/í–‰ í¬ê¸°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
    }
}

// ì—´ ë„ˆë¹„ ìë™ ë§ì¶¤ (ë‚´ìš©ì— ë§ê²Œ)
function autoFitColumnWidth(colIndex) {
    if (!SHEET || !WB[SHEET]) return;
    
    const data = WB[SHEET].data;
    const headers = WB[SHEET].headers;
    
    // ì„ì‹œ spanìœ¼ë¡œ í…ìŠ¤íŠ¸ ë„ˆë¹„ ì¸¡ì •
    const measureSpan = document.createElement('span');
    measureSpan.style.cssText = 'position:absolute;visibility:hidden;font-size:12px;font-family:"Malgun Gothic",sans-serif;white-space:nowrap;';
    document.body.appendChild(measureSpan);
    
    let maxWidth = 50; // ìµœì†Œ ë„ˆë¹„
    
    // í—¤ë” ë„ˆë¹„
    if (headers[colIndex]) {
        measureSpan.textContent = headers[colIndex];
        maxWidth = Math.max(maxWidth, measureSpan.offsetWidth + 30);
    }
    
    // ë°ì´í„° ë„ˆë¹„ (ìµœëŒ€ 100í–‰ë§Œ ê²€ì‚¬)
    const checkRows = Math.min(data.length, 100);
    for (let i = 0; i < checkRows; i++) {
        if (data[i] && data[i][colIndex]) {
            measureSpan.textContent = String(data[i][colIndex]);
            maxWidth = Math.max(maxWidth, measureSpan.offsetWidth + 20);
        }
    }
    
    document.body.removeChild(measureSpan);
    
    // ìµœëŒ€ 300pxë¡œ ì œí•œ
    maxWidth = Math.min(maxWidth, 300);
    
    // ì €ì¥ ë° ì ìš©
    if (!COL_WIDTHS[SHEET]) COL_WIDTHS[SHEET] = {};
    COL_WIDTHS[SHEET][colIndex] = maxWidth;
    
    renderSpreadsheet();
}

// ì—´ í—¤ë” ë”ë¸”í´ë¦­ ì‹œ ìë™ ë§ì¶¤
function handleColHeaderDblClick(e, colIndex) {
    e.preventDefault();
    e.stopPropagation();
    autoFitColumnWidth(colIndex);
    toast('ì—´ ë„ˆë¹„ ìë™ ë§ì¶¤');
}

// ì„ íƒëœ ì—´ ìë™ ë§ì¶¤ (ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ìš©)
function autoFitSelectedCol() {
    if (SELECTED && SELECTED.col !== undefined) {
        const realCol = parseInt(document.querySelector(`td.cell[data-col="${SELECTED.col}"]`)?.dataset.realcol);
        if (!isNaN(realCol)) {
            autoFitColumnWidth(realCol);
        }
    }
    document.getElementById('colContextMenu')?.classList.remove('show');
}

// ì„ íƒëœ í–‰ ìë™ ë§ì¶¤ (ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ìš©)
function autoFitSelectedRow() {
    if (SELECTED && SELECTED.row !== undefined) {
        // í–‰ ë†’ì´ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹ (ë˜ëŠ” ë‚´ìš©ì— ë§ê²Œ ì¡°ì ˆ)
        if (ROW_HEIGHTS[SHEET]) {
            delete ROW_HEIGHTS[SHEET][SELECTED.row];
        }
        renderSpreadsheet();
        toast('í–‰ ë†’ì´ ì´ˆê¸°í™”');
    }
    document.getElementById('rowContextMenu')?.classList.remove('show');
}

// ===================================================================
// ì¸ì‡„ ê¸°ëŠ¥
// ===================================================================

// ì¸ì‡„ ë¯¸ë¦¬ë³´ê¸° í‘œì‹œ
function printSheet() {
    if (!SHEET || !WB[SHEET]) {
        toast('ì¸ì‡„í•  ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    
    showPrintPreviewModal();
}

// ì¸ì‡„ ì˜µì…˜
let printOptions = {
    orientation: 'portrait',    // portrait, landscape
    paperSize: 'A4',           // A4, A3, Letter
    includeHeader: true,       // í—¤ë” í¬í•¨
    includeRowNumbers: true,   // í–‰ ë²ˆí˜¸ í¬í•¨
    fontSize: 10,              // í°íŠ¸ í¬ê¸°
    title: ''                  // ì œëª©
};

// ì¸ì‡„ ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬
function showPrintPreviewModal() {
    const sheet = WB[SHEET];
    printOptions.title = SHEET;
    
    const modalHtml = `
        <div class="modal-overlay print-preview-modal show" id="printPreviewModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>ì¸ì‡„ ë¯¸ë¦¬ë³´ê¸°</h3>
                    <button class="modal-close" onclick="closePrintPreviewModal()">Ã—</button>
                </div>
                <div class="print-options">
                    <div class="print-option-group">
                        <label>ì œëª©:</label>
                        <input type="text" id="printTitle" value="${escHtml(SHEET)}" style="width:150px;" onchange="updatePrintPreview()">
                    </div>
                    <div class="print-option-group">
                        <label>ë°©í–¥:</label>
                        <select id="printOrientation" onchange="updatePrintPreview()">
                            <option value="portrait">ì„¸ë¡œ</option>
                            <option value="landscape">ê°€ë¡œ</option>
                        </select>
                    </div>
                    <div class="print-option-group">
                        <label>ìš©ì§€:</label>
                        <select id="printPaperSize" onchange="updatePrintPreview()">
                            <option value="A4">A4</option>
                            <option value="A3">A3</option>
                            <option value="Letter">Letter</option>
                        </select>
                    </div>
                    <div class="print-option-group">
                        <label>ê¸€ê¼´:</label>
                        <select id="printFontSize" onchange="updatePrintPreview()">
                            <option value="8">8pt</option>
                            <option value="9">9pt</option>
                            <option value="10" selected>10pt</option>
                            <option value="11">11pt</option>
                            <option value="12">12pt</option>
                        </select>
                    </div>
                    <div class="print-option-group">
                        <label><input type="checkbox" id="printIncludeRowNum" checked onchange="updatePrintPreview()"> í–‰ ë²ˆí˜¸</label>
                    </div>
                </div>
                <div class="print-preview-body">
                    <div class="print-preview-paper" id="printPreviewPaper">
                        ${generatePrintContent()}
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="modal-btn" onclick="closePrintPreviewModal()">ì·¨ì†Œ</button>
                    <button class="modal-btn primary" onclick="executePrint()">ì¸ì‡„</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

// ì¸ì‡„ ë‚´ìš© ìƒì„±
function generatePrintContent() {
    const sheet = WB[SHEET];
    if (!sheet) return '';
    
    const title = document.getElementById('printTitle')?.value || SHEET;
    const fontSize = document.getElementById('printFontSize')?.value || 10;
    const includeRowNum = document.getElementById('printIncludeRowNum')?.checked !== false;
    
    const now = new Date();
    const dateStr = now.toLocaleDateString('ko-KR') + ' ' + now.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'});
    
    let html = `
        <div class="print-container">
            <div class="print-title" style="font-size:${parseInt(fontSize) + 6}px;">${escHtml(title)}</div>
            <div class="print-info">ì¸ì‡„ì¼ì‹œ: ${dateStr} | ì´ ${sheet.data.length}ê±´</div>
            <table class="print-table" style="font-size:${fontSize}px;">
                <thead>
                    <tr>
    `;
    
    // í–‰ ë²ˆí˜¸ í—¤ë”
    if (includeRowNum) {
        html += '<th style="width:40px;text-align:center;">No.</th>';
    }
    
    // í—¤ë”
    const colOrder = COL_ORDER[SHEET] || sheet.headers.map((_, i) => i);
    const hiddenCols = HIDDEN_COLS[SHEET] || new Set();
    const visibleCols = colOrder.filter(c => !hiddenCols.has(c));
    
    for (const colIdx of visibleCols) {
        html += `<th>${escHtml(sheet.headers[colIdx] || '')}</th>`;
    }
    
    html += '</tr></thead><tbody>';
    
    // ë°ì´í„° í–‰
    for (let i = 0; i < sheet.data.length; i++) {
        const row = sheet.data[i];
        html += '<tr>';
        
        if (includeRowNum) {
            html += `<td style="text-align:center;color:#666;">${i + 1}</td>`;
        }
        
        for (const colIdx of visibleCols) {
            const cellVal = row[colIdx];
            html += `<td>${escHtml(cellVal !== undefined && cellVal !== null ? cellVal : '')}</td>`;
        }
        
        html += '</tr>';
    }
    
    html += '</tbody></table></div>';
    
    return html;
}

// ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
function updatePrintPreview() {
    const paper = document.getElementById('printPreviewPaper');
    if (paper) {
        paper.innerHTML = generatePrintContent();
    }
    
    // ë°©í–¥ì— ë”°ë¥¸ ë¯¸ë¦¬ë³´ê¸° í¬ê¸° ì¡°ì •
    const orientation = document.getElementById('printOrientation')?.value || 'portrait';
    if (paper) {
        if (orientation === 'landscape') {
            paper.style.minWidth = '700px';
        } else {
            paper.style.minWidth = 'auto';
        }
    }
}

// ì¸ì‡„ ë¯¸ë¦¬ë³´ê¸° ëª¨ë‹¬ ë‹«ê¸°
function closePrintPreviewModal() {
    const modal = document.getElementById('printPreviewModal');
    if (modal) modal.remove();
}

// ì‹¤ì œ ì¸ì‡„ ì‹¤í–‰
function executePrint() {
    const sheet = WB[SHEET];
    if (!sheet) return;
    
    // ì¸ì‡„ ì˜µì…˜ ê°€ì ¸ì˜¤ê¸°
    const title = document.getElementById('printTitle')?.value || SHEET;
    const orientation = document.getElementById('printOrientation')?.value || 'portrait';
    const paperSize = document.getElementById('printPaperSize')?.value || 'A4';
    const fontSize = document.getElementById('printFontSize')?.value || 10;
    const includeRowNum = document.getElementById('printIncludeRowNum')?.checked !== false;
    
    // ì¸ì‡„ìš© ìŠ¤íƒ€ì¼
    const printStyles = `
        <style>
            @page {
                size: ${paperSize} ${orientation};
                margin: 15mm;
            }
            body {
                font-family: 'Malgun Gothic', sans-serif;
                margin: 0;
                padding: 0;
            }
            .print-container {
                padding: 10px;
            }
            .print-title {
                font-size: ${parseInt(fontSize) + 6}px;
                font-weight: bold;
                text-align: center;
                margin-bottom: 10px;
            }
            .print-info {
                font-size: ${parseInt(fontSize) - 1}px;
                text-align: right;
                margin-bottom: 15px;
                color: #666;
            }
            .print-table {
                width: 100%;
                border-collapse: collapse;
                font-size: ${fontSize}px;
            }
            .print-table th,
            .print-table td {
                border: 1px solid #333;
                padding: 4px 6px;
                text-align: left;
            }
            .print-table th {
                background: #e0e0e0 !important;
                font-weight: bold;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }
            .print-table tr:nth-child(even) td {
                background: #f5f5f5 !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }
            .print-table thead {
                display: table-header-group;
            }
            .print-table tr {
                page-break-inside: avoid;
            }
        </style>
    `;
    
    // ì¸ì‡„ ë‚´ìš© ìƒì„±
    const now = new Date();
    const dateStr = now.toLocaleDateString('ko-KR') + ' ' + now.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'});
    
    let printContent = `
        <div class="print-container">
            <div class="print-title">${escHtml(title)}</div>
            <div class="print-info">ì¸ì‡„ì¼ì‹œ: ${dateStr} | ì´ ${sheet.data.length}ê±´</div>
            <table class="print-table">
                <thead>
                    <tr>
    `;
    
    if (includeRowNum) {
        printContent += '<th style="width:40px;text-align:center;">No.</th>';
    }
    
    const colOrder = COL_ORDER[SHEET] || sheet.headers.map((_, i) => i);
    const hiddenCols = HIDDEN_COLS[SHEET] || new Set();
    const visibleCols = colOrder.filter(c => !hiddenCols.has(c));
    
    for (const colIdx of visibleCols) {
        printContent += `<th>${escHtml(sheet.headers[colIdx] || '')}</th>`;
    }
    
    printContent += '</tr></thead><tbody>';
    
    for (let i = 0; i < sheet.data.length; i++) {
        const row = sheet.data[i];
        printContent += '<tr>';
        
        if (includeRowNum) {
            printContent += `<td style="text-align:center;color:#666;">${i + 1}</td>`;
        }
        
        for (const colIdx of visibleCols) {
            const cellVal = row[colIdx];
            printContent += `<td>${escHtml(cellVal !== undefined && cellVal !== null ? cellVal : '')}</td>`;
        }
        
        printContent += '</tr>';
    }
    
    printContent += '</tbody></table></div>';
    
    // ìƒˆ ì°½ì—ì„œ ì¸ì‡„
    const printWindow = window.open('', '_blank', 'width=800,height=600');
    printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>${escHtml(title)} - ì¸ì‡„</title>
            ${printStyles}
        </head>
        <body>
            ${printContent}
            <scr` + `ipt>
                window.onload = function() {
                    window.print();
                    setTimeout(function() { window.close(); }, 500);
                };
            </scr` + `ipt>
        </body>
        </html>
    `);
    printWindow.document.close();
    
    closePrintPreviewModal();
    toast('ì¸ì‡„ ëŒ€í™”ìƒìë¥¼ ì—´ì—ˆìŠµë‹ˆë‹¤');
}

// ===== ì„œë²„ ê´€ë¦¬ ê¸°ëŠ¥ (í´ë” ì§€ì›) =====
let serverManagerTab = 'sheets';
let serverSheetsList = [];
let serverFilesList = [];
let localSheetsList = [];
let localFilesList = [];
let serverFoldersList = []; // ì„œë²„ ì‹œíŠ¸í´ë” ëª©ë¡
let localFoldersList = []; // ë¡œì»¬ ì‹œíŠ¸í´ë” ëª©ë¡
let serverFileFoldersList = []; // ì„œë²„ íŒŒì¼í´ë” ëª©ë¡
let localFileFoldersList = []; // ë¡œì»¬ íŒŒì¼í´ë” ëª©ë¡
let currentLocalFolderSM = null; // ì„œë²„ê´€ë¦¬ ëª¨ë‹¬ìš© ë¡œì»¬ í´ë” (ì‹œíŠ¸)
let currentServerFolderSM = null; // ì„œë²„ê´€ë¦¬ ëª¨ë‹¬ìš© ì„œë²„ í´ë” (ì‹œíŠ¸)
let currentLocalFileFolderSM = null; // ì„œë²„ê´€ë¦¬ ëª¨ë‹¬ìš© ë¡œì»¬ íŒŒì¼í´ë”
let currentServerFileFolderSM = null; // ì„œë²„ê´€ë¦¬ ëª¨ë‹¬ìš© ì„œë²„ íŒŒì¼í´ë”
let modalDragState = { isDragging: false, startX: 0, startY: 0, startLeft: 0, startTop: 0 };
let selectedItems = { local: new Set(), server: new Set() };

// ì„œë²„ ê´€ë¦¬ ëª¨ë‹¬ ì—´ê¸°
async function openServerManager() {
    if (!db || !currentUser) {
        toast('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
        return;
    }
    
    const modalHtml = `
        <div class="modal-overlay server-manager-modal show" id="serverManagerModal">
            <div class="modal-content" id="serverManagerDialog" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);">
                <div class="modal-header" id="serverManagerHeader">
                    <h3>ğŸ“ ì„œë²„ ê´€ë¦¬</h3>
                    <button class="modal-close" onclick="closeServerManager()">Ã—</button>
                </div>
                
                <div class="server-manager-tabs">
                    <button class="server-manager-tab active" data-tab="sheets" onclick="switchServerManagerTab('sheets')">
                        ğŸ“Š ì‹œíŠ¸ <span id="serverSheetsCount"></span>
                    </button>
                    <button class="server-manager-tab" data-tab="files" onclick="switchServerManagerTab('files')">
                        ğŸ“„ íŒŒì¼ <span id="serverFilesCount"></span>
                    </button>
                </div>
                
                <div class="server-manager-body-wrapper" id="serverManagerContent">
                    <div class="server-loading">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
                </div>
                
                <div class="server-manager-footer">
                    <div class="server-manager-info">ë“œë˜ê·¸ë¡œ ì´ë™ | ìš°í´ë¦­ ë©”ë‰´ | ë”ë¸”í´ë¦­ ì—´ê¸°</div>
                    <div class="server-manager-btns">
                        <button class="modal-btn" onclick="refreshServerManager()">ìƒˆë¡œê³ ì¹¨</button>
                        <button class="modal-btn" onclick="closeServerManager()">ë‹«ê¸°</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    initServerModalDrag();
    document.addEventListener('click', closeContextMenu);
    document.addEventListener('contextmenu', handleGlobalContextMenu);
    
    await loadServerManagerData();
}

// ì„œë²„ ê´€ë¦¬ ëª¨ë‹¬ ë“œë˜ê·¸ ì´ë™
function initServerModalDrag() {
    const header = document.getElementById('serverManagerHeader');
    const dialog = document.getElementById('serverManagerDialog');
    if (!header || !dialog) return;
    
    header.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('modal-close')) return;
        modalDragState.isDragging = true;
        modalDragState.startX = e.clientX;
        modalDragState.startY = e.clientY;
        const rect = dialog.getBoundingClientRect();
        modalDragState.startLeft = rect.left;
        modalDragState.startTop = rect.top;
        dialog.style.transform = 'none';
        dialog.style.left = rect.left + 'px';
        dialog.style.top = rect.top + 'px';
        dialog.style.position = 'fixed';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', handleServerModalDrag);
    document.addEventListener('mouseup', () => { modalDragState.isDragging = false; });
}

function handleServerModalDrag(e) {
    if (!modalDragState.isDragging) return;
    const dialog = document.getElementById('serverManagerDialog');
    if (!dialog) return;
    const dx = e.clientX - modalDragState.startX;
    const dy = e.clientY - modalDragState.startY;
    
    let newLeft = modalDragState.startLeft + dx;
    let newTop = modalDragState.startTop + dy;
    
    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ
    newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - 100));
    newTop = Math.max(0, Math.min(newTop, window.innerHeight - 100));
    
    dialog.style.left = newLeft + 'px';
    dialog.style.top = newTop + 'px';
}

// ëª¨ë‹¬ ë‹«ê¸°
function closeServerManager() {
    const modal = document.getElementById('serverManagerModal');
    if (modal) modal.remove();
    closeContextMenu();
    document.removeEventListener('click', closeContextMenu);
    document.removeEventListener('contextmenu', handleGlobalContextMenu);
    document.removeEventListener('mousemove', handleServerModalDrag);
    serverSheetsList = [];
    serverFilesList = [];
    localSheetsList = [];
    localFilesList = [];
    serverFoldersList = [];
    localFoldersList = [];
    serverFileFoldersList = [];
    localFileFoldersList = [];
    currentLocalFolderSM = null;
    currentServerFolderSM = null;
    currentLocalFileFolderSM = null;
    currentServerFileFolderSM = null;
    selectedItems = { local: new Set(), server: new Set() };
}

// íƒ­ ì „í™˜
function switchServerManagerTab(tab) {
    serverManagerTab = tab;
    document.querySelectorAll('.server-manager-tab').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tab);
    });
    currentLocalFolderSM = null;
    currentServerFolderSM = null;
    currentLocalFileFolderSM = null;
    currentServerFileFolderSM = null;
    selectedItems = { local: new Set(), server: new Set() };
    renderServerManagerUI();
}

// ë°ì´í„° ë¡œë“œ
async function loadServerManagerData() {
    const content = document.getElementById('serverManagerContent');
    if (!content) return; // ëª¨ë‹¬ì´ ë‹«í˜€ìˆìœ¼ë©´ ì¢…ë£Œ
    content.innerHTML = '<div class="server-loading">ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>';
    
    try {
        // ===== ë¡œì»¬ ì‹œíŠ¸í´ë” ëª©ë¡ =====
        localFoldersList = Object.entries(sheetFolders).map(([id, folder]) => ({
            id, name: folder.name, type: 'folder',
            parentId: folder.parentId,
            itemCount: Object.values(sheetToFolder).filter(fid => fid === id).length
        }));
        
        // ===== ë¡œì»¬ íŒŒì¼í´ë” ëª©ë¡ =====
        localFileFoldersList = Object.entries(fileFolders).map(([id, folder]) => ({
            id, name: folder.name, type: 'folder',
            parentId: folder.parentId,
            itemCount: fileStorage.filter(f => 
                (fileToFolder[f.id] === id) || (fileToFolder[f.name] === id) || (f.folderId === id)
            ).length
        }));
        
        // ===== ë¡œì»¬ ì‹œíŠ¸ (í´ë” ì •ë³´ í¬í•¨) =====
        localSheetsList = Object.keys(WB).filter(n => WB[n].data && WB[n].data.length > 0).map(name => ({
            id: name, name: name, type: 'sheet',
            rowCount: WB[name].data.length,
            colCount: WB[name].headers ? WB[name].headers.length : 0,
            folderId: sheetToFolder[name] || null,
            folderName: sheetToFolder[name] ? (sheetFolders[sheetToFolder[name]]?.name || null) : null
        }));
        
        // ë¡œì»¬ íŒŒì¼ (í´ë” ì •ë³´ í¬í•¨) - íŒŒì¼ ë³´ê´€í•¨ì˜ ëª¨ë“  íŒŒì¼
        localFilesList = fileStorage.map(f => ({
            id: f.id || f.name, name: f.name, type: 'file',
            fileType: f.type, size: f.size, 
            folderId: fileToFolder[f.id] || fileToFolder[f.name] || f.folderId || null,
            folderName: (fileToFolder[f.id] || fileToFolder[f.name] || f.folderId) 
                ? (fileFolders[fileToFolder[f.id] || fileToFolder[f.name] || f.folderId]?.name || null) 
                : null
        }));
        
        // ===== ì„œë²„ ì‹œíŠ¸í´ë” ë¡œë“œ =====
        try {
            const foldersSnapshot = await db.collection('folders')
                .where('userId', '==', currentUser.uid).get();
            serverFoldersList = [];
            foldersSnapshot.forEach(doc => {
                const data = doc.data();
                serverFoldersList.push({
                    id: doc.id, name: data.name, type: 'folder',
                    parentId: data.parentId || null,
                    itemCount: 0 // ë‚˜ì¤‘ì— ê³„ì‚°
                });
            });
        } catch (e) {
            console.log('ì‹œíŠ¸í´ë” ì»¬ë ‰ì…˜ ì—†ìŒ:', e);
            serverFoldersList = [];
        }
        
        // ===== ì„œë²„ íŒŒì¼í´ë” ë¡œë“œ =====
        try {
            const fileFoldersSnapshot = await db.collection('fileFolders')
                .where('userId', '==', currentUser.uid).get();
            serverFileFoldersList = [];
            fileFoldersSnapshot.forEach(doc => {
                const data = doc.data();
                serverFileFoldersList.push({
                    id: doc.id, name: data.name, type: 'folder',
                    parentId: data.parentId || null,
                    itemCount: 0 // ë‚˜ì¤‘ì— ê³„ì‚°
                });
            });
        } catch (e) {
            console.log('íŒŒì¼í´ë” ì»¬ë ‰ì…˜ ì—†ìŒ:', e);
            serverFileFoldersList = [];
        }
        
        // ===== ì„œë²„ ì‹œíŠ¸ =====
        const sheetsSnapshot = await db.collection('sheets').get();
        serverSheetsList = [];
        for (const doc of sheetsSnapshot.docs) {
            const data = doc.data();
            let rowCount = data.totalRows || 0;  // ë©”íƒ€ë°ì´í„°ì—ì„œ ì§ì ‘ ê°€ì ¸ì˜´
            serverSheetsList.push({
                id: doc.id, name: doc.id, type: 'sheet',
                rowCount, colCount: data.headers ? data.headers.length : 0,
                updatedAt: data.updatedAt, folderId: data.folderId || null
            });
        }
        
        // ì„œë²„ ì‹œíŠ¸í´ë”ë³„ ì‹œíŠ¸ ê°œìˆ˜ ê³„ì‚°
        serverFoldersList.forEach(folder => {
            folder.itemCount = serverSheetsList.filter(s => s.folderId === folder.id).length;
        });
        
        // ì„œë²„ íŒŒì¼
        const filesSnapshot = await db.collection('userFiles')
            .where('userId', '==', currentUser.uid)
            .orderBy('uploadedAt', 'desc').get();
        serverFilesList = [];
        filesSnapshot.forEach(doc => {
            const data = doc.data();
            serverFilesList.push({
                id: doc.id, name: data.name, type: 'file',
                fileType: data.type, size: data.size,
                uploadedAt: data.uploadedAt, folderId: data.folderId || null
            });
        });
        
        // ì„œë²„ íŒŒì¼í´ë”ë³„ íŒŒì¼ ê°œìˆ˜ ê³„ì‚°
        serverFileFoldersList.forEach(folder => {
            folder.itemCount = serverFilesList.filter(f => f.folderId === folder.id).length;
        });
        
        // ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸ (í´ë” í¬í•¨)
        const localTotal = localSheetsList.length + localFoldersList.length;
        const serverTotal = serverSheetsList.length + serverFoldersList.length;
        const localFileTotal = localFilesList.length + localFileFoldersList.length;
        const serverFileTotal = serverFilesList.length + serverFileFoldersList.length;
        document.getElementById('serverSheetsCount').textContent = `(${localTotal}/${serverTotal})`;
        document.getElementById('serverFilesCount').textContent = `(${localFileTotal}/${serverFileTotal})`;
        
        renderServerManagerUI();
    } catch (error) {
        console.error('ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
        content.innerHTML = '<div class="server-empty">ë¡œë“œ ì‹¤íŒ¨: ' + error.message + '</div>';
    }
}

// UI ë Œë”ë§
function renderServerManagerUI() {
    const content = document.getElementById('serverManagerContent');
    
    let localItems = [];
    let serverItems = [];
    let localBreadcrumb = '';
    let serverBreadcrumb = '';
    
    if (serverManagerTab === 'sheets') {
        // í˜„ì¬ í´ë”ì˜ í•˜ìœ„ í´ë”ë“¤
        const localChildFolders = localFoldersList.filter(f => f.parentId === currentLocalFolderSM);
        const serverChildFolders = serverFoldersList.filter(f => f.parentId === currentServerFolderSM);
        
        // í˜„ì¬ í´ë”ì˜ ì‹œíŠ¸ë“¤
        const localChildSheets = currentLocalFolderSM === null 
            ? localSheetsList.filter(s => !s.folderId)
            : localSheetsList.filter(s => s.folderId === currentLocalFolderSM);
        const serverChildSheets = currentServerFolderSM === null
            ? serverSheetsList.filter(s => !s.folderId)
            : serverSheetsList.filter(s => s.folderId === currentServerFolderSM);
        
        localItems = [...localChildFolders, ...localChildSheets];
        serverItems = [...serverChildFolders, ...serverChildSheets];
        
        // ì‹œíŠ¸ ë¸Œë ˆë“œí¬ëŸ¼
        localBreadcrumb = buildBreadcrumb('local', currentLocalFolderSM, 'sheets');
        serverBreadcrumb = buildBreadcrumb('server', currentServerFolderSM, 'sheets');
    } else {
        // íŒŒì¼ íƒ­: íŒŒì¼í´ë” ì§€ì›
        const localChildFolders = localFileFoldersList.filter(f => f.parentId === currentLocalFileFolderSM);
        const serverChildFolders = serverFileFoldersList.filter(f => f.parentId === currentServerFileFolderSM);
        
        // í˜„ì¬ í´ë”ì˜ íŒŒì¼ë“¤
        const localChildFiles = currentLocalFileFolderSM === null 
            ? localFilesList.filter(f => !f.folderId)
            : localFilesList.filter(f => f.folderId === currentLocalFileFolderSM);
        const serverChildFiles = currentServerFileFolderSM === null
            ? serverFilesList.filter(f => !f.folderId)
            : serverFilesList.filter(f => f.folderId === currentServerFileFolderSM);
        
        localItems = [...localChildFolders, ...localChildFiles];
        serverItems = [...serverChildFolders, ...serverChildFiles];
        
        // íŒŒì¼ ë¸Œë ˆë“œí¬ëŸ¼
        localBreadcrumb = buildBreadcrumb('local', currentLocalFileFolderSM, 'files');
        serverBreadcrumb = buildBreadcrumb('server', currentServerFileFolderSM, 'files');
    }
    
    const showFolderBtn = serverManagerTab === 'sheets' || serverManagerTab === 'files';
    
    content.innerHTML = `
        <div class="server-manager-body">
            <div class="server-manager-panel" id="localPanel">
                <div class="server-panel-header local">
                    <span>ğŸ’» ë‚´ ì»´í“¨í„°</span>
                    <span class="server-panel-count">${localItems.length}ê°œ</span>
                </div>
                <div class="server-panel-toolbar">
                    <button onclick="smSelectAll('local')">ì „ì²´ì„ íƒ</button>
                    <button onclick="smDeselectAll('local')">í•´ì œ</button>
                    ${showFolderBtn ? `<button onclick="smCreateLocalFolder('${serverManagerTab}')">ìƒˆí´ë”</button>` : ''}
                </div>
                <div class="server-folder-path" id="localPath">
                    ${localBreadcrumb}
                </div>
                <div class="server-manager-list" id="localListContainer" 
                     oncontextmenu="smShowContextMenu(event, 'local', null)">
                    ${renderServerManagerItems(localItems, serverItems, 'local')}
                </div>
            </div>
            
            <div class="server-manager-actions">
                <button class="server-action-btn upload" onclick="smUploadSelected()" id="smUploadBtn">
                    ì„œë²„ ì €ì¥ â†’
                </button>
                <div class="sync-arrow">â‡„</div>
                <button class="server-action-btn delete" onclick="smDeleteSelected()" id="smDeleteBtn">
                    â† ì„œë²„ ì‚­ì œ
                </button>
            </div>
            
            <div class="server-manager-panel" id="serverPanel">
                <div class="server-panel-header server">
                    <span>â˜ï¸ ì„œë²„</span>
                    <span class="server-panel-count">${serverItems.length}ê°œ</span>
                </div>
                <div class="server-panel-toolbar">
                    <button onclick="smSelectAll('server')">ì „ì²´ì„ íƒ</button>
                    <button onclick="smDeselectAll('server')">í•´ì œ</button>
                </div>
                <div class="server-folder-path" id="serverPath">
                    ${serverBreadcrumb}
                </div>
                <div class="server-manager-list" id="serverListContainer"
                     oncontextmenu="smShowContextMenu(event, 'server', null)">
                    ${renderServerManagerItems(serverItems, localItems, 'server')}
                </div>
            </div>
        </div>
    `;
    
    updateSmButtons();
}

// ë¸Œë ˆë“œí¬ëŸ¼ ìƒì„± (tab: 'sheets' ë˜ëŠ” 'files')
function buildBreadcrumb(side, currentFolderId, tab = 'sheets') {
    const isFileTab = tab === 'files';
    const navFunc = isFileTab ? 'smNavigateFileFolder' : 'smNavigateFolder';
    
    let html = `<span class="path-item${currentFolderId === null ? ' current' : ''}" onclick="${navFunc}('${side}', null)">ğŸ“ ì „ì²´</span>`;
    
    if (currentFolderId !== null) {
        let folderList;
        if (isFileTab) {
            folderList = side === 'local' ? localFileFoldersList : serverFileFoldersList;
        } else {
            folderList = side === 'local' ? localFoldersList : serverFoldersList;
        }
        const folder = folderList.find(f => f.id === currentFolderId);
        if (folder) {
            html += `<span class="folder-breadcrumb-sep">â€º</span>`;
            html += `<span class="path-item current">${escHtml(folder.name)}</span>`;
        }
    }
    
    return html;
}

// ì‹œíŠ¸ í´ë” ë„¤ë¹„ê²Œì´ì…˜
function smNavigateFolder(side, folderId) {
    if (side === 'local') {
        currentLocalFolderSM = folderId;
    } else {
        currentServerFolderSM = folderId;
    }
    selectedItems[side].clear();
    renderServerManagerUI();
}

// íŒŒì¼ í´ë” ë„¤ë¹„ê²Œì´ì…˜
function smNavigateFileFolder(side, folderId) {
    if (side === 'local') {
        currentLocalFileFolderSM = folderId;
    } else {
        currentServerFileFolderSM = folderId;
    }
    selectedItems[side].clear();
    renderServerManagerUI();
}

// ì•„ì´í…œ ëª©ë¡ ë Œë”ë§ (í´ë” + ì‹œíŠ¸/íŒŒì¼)
function renderServerManagerItems(items, otherList, side) {
    if (items.length === 0) {
        let isInFolder;
        if (serverManagerTab === 'files') {
            isInFolder = side === 'local' ? currentLocalFileFolderSM !== null : currentServerFileFolderSM !== null;
        } else {
            isInFolder = side === 'local' ? currentLocalFolderSM !== null : currentServerFolderSM !== null;
        }
        if (isInFolder) {
            return '<div class="server-empty">ì´ í´ë”ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</div>';
        }
        return '<div class="server-empty">í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤</div>';
    }
    
    let html = '';
    
    for (const item of items) {
        if (item.type === 'folder') {
            // í´ë” ë Œë”ë§
            let otherFolders, navFunc, itemLabel;
            if (serverManagerTab === 'files') {
                otherFolders = side === 'local' ? serverFileFoldersList : localFileFoldersList;
                navFunc = 'smNavigateFileFolder';
                itemLabel = 'ê°œ íŒŒì¼';
            } else {
                otherFolders = side === 'local' ? serverFoldersList : localFoldersList;
                navFunc = 'smNavigateFolder';
                itemLabel = 'ê°œ ì‹œíŠ¸';
            }
            const synced = otherFolders.some(f => f.name === item.name);
            const statusClass = synced ? 'synced' : (side === 'local' ? 'local-only' : 'server-only');
            const statusText = synced ? 'ì–‘ìª½' : (side === 'local' ? 'ë¡œì»¬' : 'ì„œë²„');
            const selected = selectedItems[side].has(item.id) ? 'selected' : '';
            
            html += `
                <div class="server-item ${synced ? 'synced' : ''} ${selected}"
                     data-id="${escHtml(item.id)}" data-name="${escHtml(item.name)}" 
                     data-side="${side}" data-type="folder"
                     onclick="smItemClick(event, '${side}', '${escHtml(item.id)}')"
                     ondblclick="${navFunc}('${side}', '${escHtml(item.id)}')"
                     oncontextmenu="smShowFolderContextMenu(event, '${side}', '${escHtml(item.id)}', '${escHtml(item.name)}')">
                    <div class="server-item-icon" style="color:#f4c542;">ğŸ“</div>
                    <div class="server-item-info">
                        <div class="server-item-name">${escHtml(item.name)}</div>
                        <div class="server-item-meta">${item.itemCount}${itemLabel}</div>
                    </div>
                    <span class="server-item-status ${statusClass}">${statusText}</span>
                </div>
            `;
        } else {
            // ì‹œíŠ¸/íŒŒì¼ ë Œë”ë§
            const synced = otherList.some(o => o.name === item.name && o.type === item.type);
            const statusClass = synced ? 'synced' : (side === 'local' ? 'local-only' : 'server-only');
            const statusText = synced ? 'ì–‘ìª½' : (side === 'local' ? 'ë¡œì»¬' : 'ì„œë²„');
            const icon = item.type === 'sheet' ? 'ğŸ“Š' : getSmFileIcon(item.fileType);
            const meta = item.type === 'sheet' ? `${item.colCount}ì—´Ã—${item.rowCount}í–‰` : formatFileSize(item.size);
            const selected = selectedItems[side].has(item.id) ? 'selected' : '';
            
            html += `
                <div class="server-item ${synced ? 'synced' : ''} ${selected}"
                     data-id="${escHtml(item.id)}" data-name="${escHtml(item.name)}" 
                     data-side="${side}" data-type="${item.type}"
                     draggable="true"
                     onclick="smItemClick(event, '${side}', '${escHtml(item.id)}')"
                     ondblclick="smItemDblClick('${side}', '${escHtml(item.name)}')"
                     oncontextmenu="smShowContextMenu(event, '${side}', '${escHtml(item.id)}')"
                     ondragstart="smDragStart(event, '${side}', '${escHtml(item.id)}', '${escHtml(item.name)}')">
                    <div class="server-item-icon">${icon}</div>
                    <div class="server-item-info">
                        <div class="server-item-name">${escHtml(item.name)}</div>
                        <div class="server-item-meta">${meta}${item.folderName ? ` Â· ğŸ“${item.folderName}` : ''}</div>
                    </div>
                    <span class="server-item-status ${statusClass}">${statusText}</span>
                </div>
            `;
        }
    }
    
    return html;
}

function getSmFileIcon(type) {
    if (!type) return 'ğŸ“„';
    const t = type.toLowerCase();
    // í™•ì¥ì ì§ì ‘ ë¹„êµ
    if (t === 'pdf' || t.includes('pdf')) return 'ğŸ“•';
    if (t === 'pptx' || t === 'ppt' || t.includes('presentation')) return 'ğŸ“™';
    if (t === 'docx' || t === 'doc' || t.includes('word')) return 'ğŸ“˜';
    if (t === 'xlsx' || t === 'xls' || t === 'csv' || t.includes('spreadsheet') || t.includes('excel')) return 'ğŸ“Š';
    if (t === 'txt' || t.includes('text')) return 'ğŸ“';
    if (t === 'jpg' || t === 'jpeg' || t === 'png' || t === 'gif' || t === 'webp' || t.includes('image')) return 'ğŸ–¼ï¸';
    return 'ğŸ“„';
}

// ì•„ì´í…œ í´ë¦­ (ì„ íƒ)
function smItemClick(e, side, id) {
    e.stopPropagation();
    
    if (e.ctrlKey || e.metaKey) {
        // Ctrl+í´ë¦­: í† ê¸€
        if (selectedItems[side].has(id)) {
            selectedItems[side].delete(id);
        } else {
            selectedItems[side].add(id);
        }
    } else if (e.shiftKey) {
        // Shift+í´ë¦­: ë²”ìœ„ ì„ íƒ (ê°„ë‹¨ êµ¬í˜„)
        selectedItems[side].add(id);
    } else {
        // ì¼ë°˜ í´ë¦­: ë‹¨ì¼ ì„ íƒ
        selectedItems[side].clear();
        selectedItems[side].add(id);
    }
    
    updateItemSelectionUI(side);
    updateSmButtons();
}

function updateItemSelectionUI(side) {
    const container = document.getElementById(side + 'ListContainer');
    if (!container) return;
    container.querySelectorAll('.server-item').forEach(el => {
        const id = el.dataset.id;
        el.classList.toggle('selected', selectedItems[side].has(id));
    });
}

// ë”ë¸”í´ë¦­ (ì—´ê¸°)
function smItemDblClick(side, name) {
    if (serverManagerTab === 'sheets' && side === 'local') {
        SHEET = name;
        closeServerManager();
        renderSpreadsheet();
        updateStatus();
        toast(`'${name}' ì‹œíŠ¸ ì—´ê¸°`);
    }
}

// ì „ì²´ ì„ íƒ/í•´ì œ
function smSelectAll(side) {
    const list = side === 'local' 
        ? (serverManagerTab === 'sheets' ? localSheetsList : localFilesList)
        : (serverManagerTab === 'sheets' ? serverSheetsList : serverFilesList);
    const otherList = side === 'local'
        ? (serverManagerTab === 'sheets' ? serverSheetsList : serverFilesList)
        : (serverManagerTab === 'sheets' ? localSheetsList : localFilesList);
    
    list.forEach(item => {
        const synced = otherList.some(o => o.name === item.name);
        if (!(synced && side === 'local')) {
            selectedItems[side].add(item.id);
        }
    });
    updateItemSelectionUI(side);
    updateSmButtons();
}

function smDeselectAll(side) {
    selectedItems[side].clear();
    updateItemSelectionUI(side);
    updateSmButtons();
}

// ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
function updateSmButtons() {
    const localCount = selectedItems.local.size;
    const serverCount = selectedItems.server.size;
    
    const uploadBtn = document.getElementById('smUploadBtn');
    const deleteBtn = document.getElementById('smDeleteBtn');
    
    if (uploadBtn) uploadBtn.textContent = localCount > 0 ? `ì„œë²„ ì €ì¥ (${localCount}) â†’` : 'ì„œë²„ ì €ì¥ â†’';
    if (deleteBtn) deleteBtn.textContent = serverCount > 0 ? `â† ì„œë²„ ì‚­ì œ (${serverCount})` : 'â† ì„œë²„ ì‚­ì œ';
}

// ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
function smShowContextMenu(e, side, itemId) {
    e.preventDefault();
    e.stopPropagation();
    closeContextMenu();
    
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.id = 'contextMenu';
    
    let html = '';
    
    if (itemId) {
        // ì•„ì´í…œ ìš°í´ë¦­
        const list = side === 'local' 
            ? (serverManagerTab === 'sheets' ? localSheetsList : localFilesList)
            : (serverManagerTab === 'sheets' ? serverSheetsList : serverFilesList);
        const item = list.find(i => i.id === itemId);
        const itemName = item ? item.name : itemId;
        
        html += `<div class="context-menu-item" onclick="smRenameItem('${side}', '${escHtml(itemId)}')">âœï¸ ì´ë¦„ ë³€ê²½ (F2)</div>`;
        
        if (side === 'local') {
            html += `<div class="context-menu-item" onclick="smUploadSingle('${escHtml(itemName)}')">â˜ï¸ ì„œë²„ì— ì €ì¥</div>`;
        } else {
            html += `<div class="context-menu-item danger" onclick="smDeleteSingle('${escHtml(itemId)}', '${escHtml(itemName)}')">ğŸ—‘ï¸ ì„œë²„ì—ì„œ ì‚­ì œ</div>`;
        }
    } else {
        // ë¹ˆ ê³µê°„ ìš°í´ë¦­
        html += `<div class="context-menu-item" onclick="smCreateFolder('${side}')">ğŸ“ ìƒˆ í´ë”</div>`;
    }
    
    html += `<div class="context-menu-separator"></div>`;
    html += `<div class="context-menu-item" onclick="refreshServerManager()">ğŸ”„ ìƒˆë¡œê³ ì¹¨</div>`;
    
    menu.innerHTML = html;
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    document.body.appendChild(menu);
    
    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ ì¡°ì •
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
    if (rect.bottom > window.innerHeight) menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
}

function handleGlobalContextMenu(e) {
    // ì„œë²„ ê´€ë¦¬ ëª¨ë‹¬ ì™¸ë¶€ ìš°í´ë¦­ì€ ë¬´ì‹œ
}

function closeContextMenu() {
    const menu = document.getElementById('contextMenu');
    if (menu) menu.remove();
}

// ìƒˆ í´ë” ìƒì„± (ë¡œì»¬)
function smCreateLocalFolder(tab = 'sheets') {
    closeContextMenu();
    const name = prompt('ìƒˆ í´ë” ì´ë¦„:');
    if (!name || !name.trim()) return;
    
    const folderId = (tab === 'files' ? 'ff_' : 'folder_') + Date.now();
    
    if (tab === 'files') {
        fileFolders[folderId] = {
            name: name.trim(),
            parentId: currentLocalFileFolderSM,
            createdAt: new Date().toISOString()
        };
        saveFileFolderData();
    } else {
        sheetFolders[folderId] = {
            name: name.trim(),
            parentId: currentLocalFolderSM,
            createdAt: new Date().toISOString()
        };
        saveFolderData();
    }
    
    loadServerManagerData();
    toast(`í´ë” '${name}' ìƒì„± ì™„ë£Œ`);
}

// í´ë” ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ (ì„œë²„ ê´€ë¦¬ìš©)
function smShowFolderContextMenu(e, side, folderId, folderName) {
    e.preventDefault();
    e.stopPropagation();
    closeContextMenu();
    
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.id = 'contextMenu';
    
    const isFileTab = serverManagerTab === 'files';
    const navFunc = isFileTab ? 'smNavigateFileFolder' : 'smNavigateFolder';
    
    let html = `<div class="context-menu-item" onclick="${navFunc}('${side}', '${escHtml(folderId)}')">ğŸ“‚ í´ë” ì—´ê¸°</div>`;
    
    if (side === 'local') {
        html += `<div class="context-menu-item" onclick="smUploadFolderToServer('${escHtml(folderId)}', '${escHtml(folderName)}', '${serverManagerTab}')">â˜ï¸ í´ë” í†µì§¸ë¡œ ì„œë²„ ì €ì¥</div>`;
        html += `<div class="context-menu-item" onclick="smRenameLocalFolder('${escHtml(folderId)}', '${serverManagerTab}')">âœï¸ ì´ë¦„ ë³€ê²½</div>`;
        html += `<div class="context-menu-item danger" onclick="smDeleteLocalFolder('${escHtml(folderId)}', '${serverManagerTab}')">ğŸ—‘ï¸ ì‚­ì œ</div>`;
    } else {
        html += `<div class="context-menu-item danger" onclick="smDeleteServerFolder('${escHtml(folderId)}', '${escHtml(folderName)}', '${serverManagerTab}')">ğŸ—‘ï¸ ì„œë²„ì—ì„œ ì‚­ì œ</div>`;
    }
    
    menu.innerHTML = html;
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    document.body.appendChild(menu);
    
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
    if (rect.bottom > window.innerHeight) menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
}

// ë¡œì»¬ í´ë” ì´ë¦„ ë³€ê²½
function smRenameLocalFolder(folderId, tab = 'sheets') {
    closeContextMenu();
    
    const folders = tab === 'files' ? fileFolders : sheetFolders;
    const folder = folders[folderId];
    if (!folder) return;
    
    const newName = prompt('ìƒˆ í´ë” ì´ë¦„:', folder.name);
    if (!newName || !newName.trim() || newName === folder.name) return;
    
    folder.name = newName.trim();
    
    if (tab === 'files') {
        saveFileFolderData();
    } else {
        saveFolderData();
    }
    
    loadServerManagerData();
    toast('í´ë” ì´ë¦„ ë³€ê²½ ì™„ë£Œ');
}

// ë¡œì»¬ í´ë” ì‚­ì œ
function smDeleteLocalFolder(folderId, tab = 'sheets') {
    closeContextMenu();
    
    if (tab === 'files') {
        const folder = fileFolders[folderId];
        if (!folder) return;
        
        const fileCount = Object.values(fileToFolder).filter(fid => fid === folderId).length;
        const msg = fileCount > 0 
            ? `'${folder.name}' í´ë”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\në‚´ë¶€ ${fileCount}ê°œ íŒŒì¼ì€ 'ì „ì²´'ë¡œ ì´ë™ë©ë‹ˆë‹¤.`
            : `'${folder.name}' í´ë”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
        
        if (!confirm(msg)) return;
        
        // íŒŒì¼ë“¤ ë£¨íŠ¸ë¡œ ì´ë™
        for (const fileId in fileToFolder) {
            if (fileToFolder[fileId] === folderId) {
                delete fileToFolder[fileId];
            }
        }
        
        delete fileFolders[folderId];
        saveFileFolderData();
        
        if (currentLocalFileFolderSM === folderId) {
            currentLocalFileFolderSM = null;
        }
        
        loadServerManagerData();
        toast(`í´ë” '${folder.name}' ì‚­ì œ ì™„ë£Œ`);
    } else {
        const folder = sheetFolders[folderId];
        if (!folder) return;
        
        const sheetCount = Object.values(sheetToFolder).filter(fid => fid === folderId).length;
        const msg = sheetCount > 0 
            ? `'${folder.name}' í´ë”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\në‚´ë¶€ ${sheetCount}ê°œ ì‹œíŠ¸ëŠ” 'ì „ì²´'ë¡œ ì´ë™ë©ë‹ˆë‹¤.`
            : `'${folder.name}' í´ë”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
        
        if (!confirm(msg)) return;
        
        // ì‹œíŠ¸ë“¤ ë£¨íŠ¸ë¡œ ì´ë™
        for (const sheetName in sheetToFolder) {
            if (sheetToFolder[sheetName] === folderId) {
                delete sheetToFolder[sheetName];
            }
        }
        
        delete sheetFolders[folderId];
        saveFolderData();
        
        if (currentLocalFolderSM === folderId) {
            currentLocalFolderSM = null;
        }
        
        loadServerManagerData();
        toast(`í´ë” '${folder.name}' ì‚­ì œ ì™„ë£Œ`);
    }
}

// í´ë” í†µì§¸ë¡œ ì„œë²„ì— ì €ì¥
async function smUploadFolderToServer(folderId, folderName, tab = 'sheets') {
    closeContextMenu();
    
    if (tab === 'files') {
        const folder = fileFolders[folderId];
        if (!folder) return;
        
        // í´ë” ì•ˆì˜ íŒŒì¼ë“¤ (ëª¨ë“  íŒŒì¼)
        const filesInFolder = fileStorage.filter(f => 
            (fileToFolder[f.id] === folderId) || (fileToFolder[f.name] === folderId) || (f.folderId === folderId)
        );
        
        const msg = `'${folderName}' í´ë”ì™€ ë‚´ë¶€ ${filesInFolder.length}ê°œ íŒŒì¼ì„ ì„œë²„ì— ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
        if (!confirm(msg)) return;
        
        showLoading('íŒŒì¼ í´ë” ì €ì¥ ì¤‘...');
        
        try {
            // 1. í´ë” ì €ì¥
            updateLoadingText('í´ë” ì •ë³´ ì €ì¥ ì¤‘...');
            await db.collection('fileFolders').doc(folderId).set({
                name: folder.name,
                parentId: folder.parentId || null,
                createdAt: folder.createdAt,
                userId: currentUser.uid,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            // 2. íŒŒì¼ë“¤ ì €ì¥
            let savedCount = 0;
            const FIRESTORE_DOC_LIMIT = 700 * 1024;
            
            for (const file of filesInFolder) {
                updateLoadingText(`'${file.name}' ì €ì¥ ì¤‘... (${savedCount + 1}/${filesInFolder.length})`);
                
                let fileDoc = {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    textContent: file.textContent || null,
                    folderId: folderId,
                    uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    userId: currentUser.uid
                };
                
                // íŒŒì¼ í¬ê¸°ê°€ í¬ë©´ Storageì— ì €ì¥
                if (file.data && file.data.length > FIRESTORE_DOC_LIMIT) {
                    if (storage) {
                        try {
                            const storagePath = `userFiles/${currentUser.uid}/${Date.now()}_${file.name}`;
                            const storageRef = storage.ref(storagePath);
                            
                            const base64Data = file.data.split(',')[1] || file.data;
                            const byteChars = atob(base64Data);
                            const byteNumbers = new Array(byteChars.length);
                            for (let i = 0; i < byteChars.length; i++) {
                                byteNumbers[i] = byteChars.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray]);
                            
                            await storageRef.put(blob);
                            const downloadURL = await storageRef.getDownloadURL();
                            
                            fileDoc.storagePath = storagePath;
                            fileDoc.downloadURL = downloadURL;
                            fileDoc.data = null;
                        } catch (storageErr) {
                            console.error('Storage ì—…ë¡œë“œ ì‹¤íŒ¨:', storageErr);
                            continue;
                        }
                    } else {
                        console.warn('Storage ë¯¸ì´ˆê¸°í™” - í° íŒŒì¼ ìŠ¤í‚µ:', file.name);
                        continue;
                    }
                } else {
                    fileDoc.data = file.data;
                }
                
                if (file.id && !file.isLocal) {
                    // ê¸°ì¡´ ì„œë²„ íŒŒì¼ ì—…ë°ì´íŠ¸
                    await db.collection('userFiles').doc(file.id).update(fileDoc);
                } else {
                    // ìƒˆ íŒŒì¼ ì¶”ê°€
                    const docRef = await db.collection('userFiles').add(fileDoc);
                    file.id = docRef.id;
                    file.isLocal = false;
                }
                if (fileDoc.storagePath) file.storagePath = fileDoc.storagePath;
                savedCount++;
            }
            
            // íŒŒì¼-í´ë” ë§¤í•‘ ì €ì¥
            await db.collection('userSettings').doc(currentUser.uid).set({
                fileToFolder: fileToFolder
            }, { merge: true });
            
            hideLoading();
            toast(`í´ë” + ${savedCount}ê°œ íŒŒì¼ ì €ì¥ ì™„ë£Œ`);
            await loadServerManagerData();
            
        } catch (error) {
            hideLoading();
            console.error('íŒŒì¼ í´ë” ì €ì¥ ì˜¤ë¥˜:', error);
            toast('í´ë” ì €ì¥ ì‹¤íŒ¨: ' + error.message);
        }
    } else {
        const folder = sheetFolders[folderId];
        if (!folder) return;
        
        // í´ë” ì•ˆì˜ ì‹œíŠ¸ë“¤
        const sheetsInFolder = Object.entries(sheetToFolder)
            .filter(([name, fid]) => fid === folderId)
            .map(([name]) => name);
        
        const msg = `'${folderName}' í´ë”ì™€ ë‚´ë¶€ ${sheetsInFolder.length}ê°œ ì‹œíŠ¸ë¥¼ ì„œë²„ì— ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
        if (!confirm(msg)) return;
        
        showLoading('í´ë” ì €ì¥ ì¤‘...');
        
        try {
            // 1. í´ë” ì €ì¥
            updateLoadingText('í´ë” ì •ë³´ ì €ì¥ ì¤‘...');
            await db.collection('folders').doc(folderId).set({
                name: folder.name,
                parentId: folder.parentId || null,
                createdAt: folder.createdAt,
                userId: currentUser.uid,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            // 2. ì‹œíŠ¸ë“¤ ì €ì¥ (í´ë” ID í¬í•¨)
            let savedCount = 0;
            for (const sheetName of sheetsInFolder) {
                if (!WB[sheetName]) continue;
                
                updateLoadingText(`'${sheetName}' ì €ì¥ ì¤‘... (${savedCount + 1}/${sheetsInFolder.length})`);
                
                // ì‹œíŠ¸ ì €ì¥ (í´ë” ID í¬í•¨)
                await saveSheetToFirestoreWithFolder(sheetName, folderId);
                savedCount++;
            }
            
            hideLoading();
            toast(`í´ë” + ${savedCount}ê°œ ì‹œíŠ¸ ì €ì¥ ì™„ë£Œ`);
            await loadServerManagerData();
            
        } catch (error) {
            hideLoading();
            console.error('í´ë” ì €ì¥ ì˜¤ë¥˜:', error);
            toast('í´ë” ì €ì¥ ì‹¤íŒ¨: ' + error.message);
        }
    }
}

// ì‹œíŠ¸ë¥¼ í´ë” IDì™€ í•¨ê»˜ ì„œë²„ì— ì €ì¥
async function saveSheetToFirestoreWithFolder(sheetName, folderId) {
    const sheet = WB[sheetName];
    if (!sheet) return;
    
    const CHUNK_SIZE = 500;
    const rows = sheet.data;
    const chunks = [];
    
    for (let i = 0; i < rows.length; i += CHUNK_SIZE) {
        chunks.push(rows.slice(i, i + CHUNK_SIZE));
    }
    
    const sheetRef = db.collection('sheets').doc(sheetName);
    
    // ê¸°ì¡´ ì²­í¬ ì‚­ì œ
    const existingChunks = await sheetRef.collection('chunks').get();
    for (const doc of existingChunks.docs) {
        await doc.ref.delete();
    }
    
    // ìƒˆ ì²­í¬ ì €ì¥ (ì „ì²´ rowsë¥¼ JSON ë¬¸ìì—´ë¡œ ì €ì¥í•˜ì—¬ ì¤‘ì²© ë°°ì—´ ë¬¸ì œ ì™„ì „ ë°©ì§€)
    for (let i = 0; i < chunks.length; i++) {
        await sheetRef.collection('chunks').doc(String(i).padStart(5, '0')).set({
            chunkIndex: i,
            rowsJson: JSON.stringify(chunks[i])  // JSON ë¬¸ìì—´ë¡œ ì €ì¥
        });
    }
    
    // ë©”íƒ€ë°ì´í„° ì €ì¥ (í´ë” ID í¬í•¨)
    await sheetRef.set({
        headers: sheet.headers.map(h => String(h || '')),
        totalRows: rows.length,
        chunkCount: chunks.length,
        folderId: folderId || null,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    });
}

// ì„œë²„ í´ë” ì‚­ì œ
async function smDeleteServerFolder(folderId, folderName, tab = 'sheets') {
    closeContextMenu();
    
    if (tab === 'files') {
        const filesInFolder = serverFilesList.filter(f => f.folderId === folderId);
        const msg = filesInFolder.length > 0
            ? `'${folderName}' í´ë”ì™€ ë‚´ë¶€ ${filesInFolder.length}ê°œ íŒŒì¼ì„ ëª¨ë‘ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
            : `'${folderName}' í´ë”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
        
        if (!confirm(msg)) return;
        
        showLoading('íŒŒì¼ í´ë” ì‚­ì œ ì¤‘...');
        
        try {
            // 1. ë‚´ë¶€ íŒŒì¼ë“¤ ì‚­ì œ
            for (const file of filesInFolder) {
                updateLoadingText(`'${file.name}' ì‚­ì œ ì¤‘...`);
                await db.collection('userFiles').doc(file.id).delete();
                
                // ë¡œì»¬ fileStorageì—ì„œë„ ì œê±°
                const idx = fileStorage.findIndex(f => f.id === file.id);
                if (idx !== -1) fileStorage.splice(idx, 1);
                delete fileToFolder[file.id];
            }
            
            // 2. í´ë” ì‚­ì œ
            updateLoadingText('í´ë” ì‚­ì œ ì¤‘...');
            await db.collection('fileFolders').doc(folderId).delete();
            
            // ë¡œì»¬ fileFoldersì—ì„œë„ ì œê±°
            delete fileFolders[folderId];
            saveFileFolderData();
            
            hideLoading();
            toast(`í´ë” + ${filesInFolder.length}ê°œ íŒŒì¼ ì‚­ì œ ì™„ë£Œ`);
            
            if (currentServerFileFolderSM === folderId) {
                currentServerFileFolderSM = null;
            }
            
            renderFileStoragePanel();
            await loadServerManagerData();
            
        } catch (error) {
            hideLoading();
            console.error('íŒŒì¼ í´ë” ì‚­ì œ ì˜¤ë¥˜:', error);
            toast('í´ë” ì‚­ì œ ì‹¤íŒ¨: ' + error.message);
        }
    } else {
        const sheetsInFolder = serverSheetsList.filter(s => s.folderId === folderId);
        const msg = sheetsInFolder.length > 0
            ? `'${folderName}' í´ë”ì™€ ë‚´ë¶€ ${sheetsInFolder.length}ê°œ ì‹œíŠ¸ë¥¼ ëª¨ë‘ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
            : `'${folderName}' í´ë”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
        
        if (!confirm(msg)) return;
        
        showLoading('í´ë” ì‚­ì œ ì¤‘...');
        
        try {
            // 1. ë‚´ë¶€ ì‹œíŠ¸ë“¤ ì‚­ì œ
            for (const sheet of sheetsInFolder) {
                updateLoadingText(`'${sheet.name}' ì‚­ì œ ì¤‘...`);
                
                const chunksSnapshot = await db.collection('sheets').doc(sheet.id).collection('chunks').get();
                for (const chunk of chunksSnapshot.docs) {
                    await chunk.ref.delete();
                }
                await db.collection('sheets').doc(sheet.id).delete();
            }
            
            // 2. í´ë” ì‚­ì œ
            updateLoadingText('í´ë” ì‚­ì œ ì¤‘...');
            await db.collection('folders').doc(folderId).delete();
            
            hideLoading();
            toast(`í´ë” + ${sheetsInFolder.length}ê°œ ì‹œíŠ¸ ì‚­ì œ ì™„ë£Œ`);
            
            if (currentServerFolderSM === folderId) {
                currentServerFolderSM = null;
            }
            
            await loadServerManagerData();
            
        } catch (error) {
            hideLoading();
            console.error('í´ë” ì‚­ì œ ì˜¤ë¥˜:', error);
            toast('í´ë” ì‚­ì œ ì‹¤íŒ¨: ' + error.message);
        }
    }
}

// ì´ë¦„ ë³€ê²½
function smRenameItem(side, itemId) {
    closeContextMenu();
    const nameEl = document.getElementById(`name_${side}_${itemId}`);
    if (!nameEl) return;
    
    const currentName = nameEl.textContent;
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'server-item-name-input';
    input.value = currentName;
    
    nameEl.innerHTML = '';
    nameEl.appendChild(input);
    input.focus();
    input.select();
    
    const finishRename = async () => {
        const newName = input.value.trim();
        if (newName && newName !== currentName) {
            // ì‹¤ì œ ì´ë¦„ ë³€ê²½ ë¡œì§
            if (side === 'local') {
                if (serverManagerTab === 'sheets') {
                    // ë¡œì»¬ ì‹œíŠ¸ ì´ë¦„ ë³€ê²½
                    if (WB[currentName]) {
                        WB[newName] = WB[currentName];
                        delete WB[currentName];
                        
                        // ì—´ ìˆœì„œ ì´ì „
                        if (COL_ORDER[currentName]) {
                            COL_ORDER[newName] = COL_ORDER[currentName];
                            delete COL_ORDER[currentName];
                        }
                        
                        // ìˆ¨ê¸´ ì—´ ì´ì „
                        if (HIDDEN_COLS[currentName]) {
                            HIDDEN_COLS[newName] = HIDDEN_COLS[currentName];
                            delete HIDDEN_COLS[currentName];
                        }
                        
                        // ì—´ ë„ˆë¹„ ì´ì „
                        if (COL_WIDTHS[currentName]) {
                            COL_WIDTHS[newName] = COL_WIDTHS[currentName];
                            delete COL_WIDTHS[currentName];
                        }
                        
                        // í–‰ ë†’ì´ ì´ì „
                        if (ROW_HEIGHTS[currentName]) {
                            ROW_HEIGHTS[newName] = ROW_HEIGHTS[currentName];
                            delete ROW_HEIGHTS[currentName];
                        }
                        
                        // í´ë” ë§¤í•‘ ì´ì „
                        if (sheetToFolder[currentName]) {
                            sheetToFolder[newName] = sheetToFolder[currentName];
                            delete sheetToFolder[currentName];
                        }
                        saveFolderData();
                        
                        // ì¦ê²¨ì°¾ê¸° ì´ì „
                        if (favoriteSheets && favoriteSheets.has(currentName)) {
                            favoriteSheets.delete(currentName);
                            favoriteSheets.add(newName);
                        }
                        
                        // NEW ë°°ì§€ ì´ì „
                        if (newSheets && newSheets.has(currentName)) {
                            newSheets.delete(currentName);
                            newSheets.add(newName);
                        }
                        
                        // ë‹¤ì¤‘ ì„ íƒ ì´ì „
                        if (multiSelectedSheets && multiSelectedSheets.has(currentName)) {
                            multiSelectedSheets.delete(currentName);
                            multiSelectedSheets.add(newName);
                        }
                        
                        if (SHEET === currentName) SHEET = newName;
                        toast(`ì´ë¦„ ë³€ê²½: ${currentName} â†’ ${newName}`);
                    }
                } else if (serverManagerTab === 'files') {
                    // ë¡œì»¬ íŒŒì¼ ì´ë¦„ ë³€ê²½
                    const file = fileStorage.find(f => f.name === currentName);
                    if (file) {
                        // ì¤‘ë³µ ê²€ì‚¬
                        if (fileStorage.some(f => f.name === newName && f !== file)) {
                            toast('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” íŒŒì¼ ì´ë¦„ì…ë‹ˆë‹¤');
                            nameEl.textContent = currentName;
                            await loadServerManagerData();
                            return;
                        }
                        
                        file.name = newName;
                        
                        // Firestore ì—…ë°ì´íŠ¸ (ì„œë²„ íŒŒì¼ì¸ ê²½ìš°)
                        if (db && file.id && !file.isLocal) {
                            try {
                                await db.collection('userFiles').doc(file.id).update({ name: newName });
                            } catch (err) {
                                console.error('íŒŒì¼ ì´ë¦„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', err);
                            }
                        }
                        
                        renderFileStoragePanel();
                        toast(`ì´ë¦„ ë³€ê²½: ${currentName} â†’ ${newName}`);
                    }
                }
            } else {
                // ì„œë²„ ì¸¡ ì´ë¦„ ë³€ê²½ (ì„œë²„ ì‹œíŠ¸/íŒŒì¼)
                toast('ì„œë²„ í•­ëª© ì´ë¦„ ë³€ê²½ì€ ë¡œì»¬ì—ì„œ ë³€ê²½ í›„ ë‹¤ì‹œ ì €ì¥í•´ì£¼ì„¸ìš”');
            }
        }
        nameEl.textContent = newName || currentName;
        await loadServerManagerData();
    };
    
    input.addEventListener('blur', finishRename);
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { input.blur(); }
        if (e.key === 'Escape') { nameEl.textContent = currentName; }
    });
}

// ë“œë˜ê·¸ ì•¤ ë“œë¡­
let dragData = null;

function smDragStart(e, side, id, name) {
    dragData = { side, id, name };
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');
}

function smDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
}

function smDrop(e, targetSide) {
    e.preventDefault();
    if (!dragData) return;
    
    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
    
    if (dragData.side === 'local' && targetSide === 'server') {
        // ë¡œì»¬ â†’ ì„œë²„ (ì—…ë¡œë“œ)
        if (confirm(`'${dragData.name}'ì„(ë¥¼) ì„œë²„ì— ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
            smUploadSingle(dragData.name);
        }
    }
    
    dragData = null;
}

// ë‹¨ì¼ ì—…ë¡œë“œ
async function smUploadSingle(name) {
    closeContextMenu();
    showLoading('ì„œë²„ì— ì €ì¥ ì¤‘...');
    try {
        if (serverManagerTab === 'sheets') {
            await saveSheetToFirestore(name);
        } else {
            const file = fileStorage.find(f => f.name === name);
            if (file) {
                const fileFolderId = fileToFolder[file.id] || fileToFolder[file.name] || file.folderId || null;
                const FIRESTORE_DOC_LIMIT = 700 * 1024;
                
                let fileDoc = {
                    name: file.name, type: file.type, size: file.size,
                    textContent: file.textContent || null,
                    folderId: fileFolderId,
                    uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    userId: currentUser.uid
                };
                
                // íŒŒì¼ í¬ê¸°ê°€ í¬ë©´ Storageì— ì €ì¥
                if (file.data && file.data.length > FIRESTORE_DOC_LIMIT) {
                    if (storage) {
                        const storagePath = `userFiles/${currentUser.uid}/${Date.now()}_${file.name}`;
                        const storageRef = storage.ref(storagePath);
                        
                        const base64Data = file.data.split(',')[1] || file.data;
                        const byteChars = atob(base64Data);
                        const byteNumbers = new Array(byteChars.length);
                        for (let i = 0; i < byteChars.length; i++) {
                            byteNumbers[i] = byteChars.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray]);
                        
                        await storageRef.put(blob);
                        const downloadURL = await storageRef.getDownloadURL();
                        
                        fileDoc.storagePath = storagePath;
                        fileDoc.downloadURL = downloadURL;
                        fileDoc.data = null;
                    } else {
                        throw new Error('Storage ë¯¸ì´ˆê¸°í™” - í° íŒŒì¼ ì €ì¥ ë¶ˆê°€');
                    }
                } else {
                    fileDoc.data = file.data;
                }
                
                if (file.id && !file.isLocal) {
                    // ê¸°ì¡´ ì„œë²„ íŒŒì¼ ì—…ë°ì´íŠ¸
                    await db.collection('userFiles').doc(file.id).update(fileDoc);
                } else {
                    // ìƒˆ íŒŒì¼ ì¶”ê°€
                    const docRef = await db.collection('userFiles').add(fileDoc);
                    file.id = docRef.id;
                    file.isLocal = false;
                }
                if (fileDoc.storagePath) file.storagePath = fileDoc.storagePath;
                renderFileStoragePanel();
            }
        }
        toast(`'${name}' ì €ì¥ ì™„ë£Œ`);
        await loadServerManagerData();
    } catch (err) {
        toast('ì €ì¥ ì‹¤íŒ¨: ' + err.message);
    }
    hideLoading();
}

// ë‹¨ì¼ ì‚­ì œ
async function smDeleteSingle(id, name) {
    closeContextMenu();
    if (!confirm(`'${name}'ì„(ë¥¼) ì„œë²„ì—ì„œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
    
    showLoading('ì‚­ì œ ì¤‘...');
    try {
        if (serverManagerTab === 'sheets') {
            const chunks = await db.collection('sheets').doc(id).collection('chunks').get();
            for (const c of chunks.docs) await c.ref.delete();
            const rows = await db.collection('sheets').doc(id).collection('rows').get();
            for (const r of rows.docs) await r.ref.delete();
            await db.collection('sheets').doc(id).delete();
        } else {
            await db.collection('userFiles').doc(id).delete();
            const idx = fileStorage.findIndex(f => f.id === id);
            if (idx !== -1) fileStorage.splice(idx, 1);
            delete fileToFolder[id]; // í´ë” ë§¤í•‘ë„ ì‚­ì œ
            saveFileFolderData();
            renderFileStoragePanel();
        }
        toast(`'${name}' ì‚­ì œ ì™„ë£Œ`);
        await loadServerManagerData();
    } catch (err) {
        toast('ì‚­ì œ ì‹¤íŒ¨: ' + err.message);
    }
    hideLoading();
}

// ì„ íƒ í•­ëª© ì—…ë¡œë“œ (í´ë” í¬í•¨)
async function smUploadSelected() {
    if (selectedItems.local.size === 0) {
        toast('ì €ì¥í•  í•­ëª©ì„ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    
    // ì„ íƒëœ í´ë”ì™€ ì‹œíŠ¸/íŒŒì¼ ë¶„ë¦¬ (íƒ­ì— ë”°ë¼ ë‹¤ë¥¸ í´ë” ëª©ë¡ ì‚¬ìš©)
    const selectedFolders = serverManagerTab === 'sheets' 
        ? localFoldersList.filter(f => selectedItems.local.has(f.id))
        : localFileFoldersList.filter(f => selectedItems.local.has(f.id));
    const selectedSheets = serverManagerTab === 'sheets' 
        ? localSheetsList.filter(s => selectedItems.local.has(s.id))
        : [];
    const selectedFiles = serverManagerTab === 'files'
        ? localFilesList.filter(f => selectedItems.local.has(f.id) && f.type === 'file')
        : [];
    
    const totalCount = selectedFolders.length + selectedSheets.length + selectedFiles.length;
    
    let msg = `${totalCount}ê°œ í•­ëª©ì„ ì„œë²„ì— ì €ì¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
    if (selectedFolders.length > 0) {
        msg += `\n\nğŸ“ í´ë” ${selectedFolders.length}ê°œ (ë‚´ë¶€ ì‹œíŠ¸ í¬í•¨)`;
    }
    if (selectedSheets.length > 0) {
        msg += `\nğŸ“Š ì‹œíŠ¸ ${selectedSheets.length}ê°œ`;
    }
    
    if (!confirm(msg)) return;
    
    showLoading('ì„œë²„ì— ì €ì¥ ì¤‘...');
    let count = 0;
    
    try {
        // 1. í´ë” ì €ì¥ (ì‹œíŠ¸ íƒ­ vs íŒŒì¼ íƒ­)
        for (const folder of selectedFolders) {
            updateLoadingText(`í´ë” '${folder.name}' ì €ì¥ ì¤‘...`);
            
            if (serverManagerTab === 'sheets') {
                // ì‹œíŠ¸ í´ë” ì €ì¥
                await db.collection('folders').doc(folder.id).set({
                    name: folder.name,
                    parentId: folder.parentId || null,
                    createdAt: sheetFolders[folder.id]?.createdAt || new Date().toISOString(),
                    userId: currentUser.uid,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // í´ë” ì•ˆì˜ ì‹œíŠ¸ë“¤ ì €ì¥
                const sheetsInFolder = Object.entries(sheetToFolder)
                    .filter(([name, fid]) => fid === folder.id)
                    .map(([name]) => name);
                
                for (const sheetName of sheetsInFolder) {
                    if (!WB[sheetName]) continue;
                    updateLoadingText(`'${sheetName}' ì €ì¥ ì¤‘...`);
                    await saveSheetToFirestoreWithFolder(sheetName, folder.id);
                }
            } else {
                // íŒŒì¼ í´ë” ì €ì¥
                await db.collection('fileFolders').doc(folder.id).set({
                    name: folder.name,
                    parentId: folder.parentId || null,
                    createdAt: fileFolders[folder.id]?.createdAt || new Date().toISOString(),
                    userId: currentUser.uid,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // í´ë” ì•ˆì˜ íŒŒì¼ë“¤ ì €ì¥
                const filesInFolder = fileStorage.filter(f => 
                    (fileToFolder[f.id] === folder.id) || (fileToFolder[f.name] === folder.id) || (f.folderId === folder.id)
                );
                
                for (const file of filesInFolder) {
                    updateLoadingText(`'${file.name}' ì €ì¥ ì¤‘...`);
                    const FIRESTORE_DOC_LIMIT = 700 * 1024;
                    
                    let fileDoc = {
                        name: file.name, type: file.type, size: file.size,
                        textContent: file.textContent || null,
                        folderId: folder.id,
                        uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        userId: currentUser.uid
                    };
                    
                    // íŒŒì¼ í¬ê¸°ê°€ í¬ë©´ Storageì— ì €ì¥
                    if (file.data && file.data.length > FIRESTORE_DOC_LIMIT) {
                        if (storage) {
                            try {
                                const storagePath = `userFiles/${currentUser.uid}/${Date.now()}_${file.name}`;
                                const storageRef = storage.ref(storagePath);
                                
                                const base64Data = file.data.split(',')[1] || file.data;
                                const byteChars = atob(base64Data);
                                const byteNumbers = new Array(byteChars.length);
                                for (let i = 0; i < byteChars.length; i++) {
                                    byteNumbers[i] = byteChars.charCodeAt(i);
                                }
                                const byteArray = new Uint8Array(byteNumbers);
                                const blob = new Blob([byteArray]);
                                
                                await storageRef.put(blob);
                                const downloadURL = await storageRef.getDownloadURL();
                                
                                fileDoc.storagePath = storagePath;
                                fileDoc.downloadURL = downloadURL;
                                fileDoc.data = null;
                            } catch (storageErr) {
                                console.error('Storage ì—…ë¡œë“œ ì‹¤íŒ¨:', storageErr);
                                continue;
                            }
                        } else {
                            continue;
                        }
                    } else {
                        fileDoc.data = file.data;
                    }
                    
                    if (file.id && !file.isLocal) {
                        await db.collection('userFiles').doc(file.id).update(fileDoc);
                    } else {
                        const docRef = await db.collection('userFiles').add(fileDoc);
                        file.id = docRef.id;
                        file.isLocal = false;
                    }
                    if (fileDoc.storagePath) file.storagePath = fileDoc.storagePath;
                }
                
                // íŒŒì¼-í´ë” ë§¤í•‘ ì €ì¥
                await db.collection('userSettings').doc(currentUser.uid).set({
                    fileToFolder: fileToFolder
                }, { merge: true });
            }
            
            count++;
        }
        
        // 2. ê°œë³„ ì‹œíŠ¸ ì €ì¥
        for (const sheet of selectedSheets) {
            updateLoadingText(`'${sheet.name}' ì €ì¥ ì¤‘...`);
            const folderId = sheetToFolder[sheet.name] || null;
            await saveSheetToFirestoreWithFolder(sheet.name, folderId);
            count++;
        }
        
        // 3. íŒŒì¼ ì €ì¥
        for (const fileItem of selectedFiles) {
            const file = fileStorage.find(f => f.name === fileItem.name);
            if (file) {
                updateLoadingText(`'${file.name}' ì €ì¥ ì¤‘...`);
                const fileFolderId = fileToFolder[file.id] || fileToFolder[file.name] || file.folderId || null;
                const FIRESTORE_DOC_LIMIT = 700 * 1024;
                
                let fileDoc = {
                    name: file.name, type: file.type, size: file.size,
                    textContent: file.textContent || null,
                    folderId: fileFolderId,
                    uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    userId: currentUser.uid
                };
                
                // íŒŒì¼ í¬ê¸°ê°€ í¬ë©´ Storageì— ì €ì¥
                if (file.data && file.data.length > FIRESTORE_DOC_LIMIT) {
                    if (storage) {
                        try {
                            const storagePath = `userFiles/${currentUser.uid}/${Date.now()}_${file.name}`;
                            const storageRef = storage.ref(storagePath);
                            
                            const base64Data = file.data.split(',')[1] || file.data;
                            const byteChars = atob(base64Data);
                            const byteNumbers = new Array(byteChars.length);
                            for (let i = 0; i < byteChars.length; i++) {
                                byteNumbers[i] = byteChars.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray]);
                            
                            await storageRef.put(blob);
                            const downloadURL = await storageRef.getDownloadURL();
                            
                            fileDoc.storagePath = storagePath;
                            fileDoc.downloadURL = downloadURL;
                            fileDoc.data = null;
                        } catch (storageErr) {
                            console.error('Storage ì—…ë¡œë“œ ì‹¤íŒ¨:', storageErr);
                            continue;
                        }
                    } else {
                        continue;
                    }
                } else {
                    fileDoc.data = file.data;
                }
                
                if (file.id && !file.isLocal) {
                    // ê¸°ì¡´ ì„œë²„ íŒŒì¼ ì—…ë°ì´íŠ¸
                    await db.collection('userFiles').doc(file.id).update(fileDoc);
                } else {
                    // ìƒˆ íŒŒì¼ ì¶”ê°€
                    const docRef = await db.collection('userFiles').add(fileDoc);
                    file.id = docRef.id;
                    file.isLocal = false;
                }
                if (fileDoc.storagePath) file.storagePath = fileDoc.storagePath;
                count++;
            }
        }
        
        hideLoading();
        toast(`${count}ê°œ ì €ì¥ ì™„ë£Œ`);
        selectedItems.local.clear();
        if (serverManagerTab === 'files') renderFileStoragePanel();
        await loadServerManagerData();
        
    } catch (e) {
        hideLoading();
        console.error('ì €ì¥ ì‹¤íŒ¨:', e);
        toast('ì €ì¥ ì‹¤íŒ¨: ' + e.message);
    }
}

// ì„ íƒ í•­ëª© ì‚­ì œ (í´ë” í¬í•¨)
async function smDeleteSelected() {
    if (selectedItems.server.size === 0) {
        toast('ì‚­ì œí•  í•­ëª©ì„ ì„ íƒí•˜ì„¸ìš”');
        return;
    }
    
    // ì„ íƒëœ í´ë”ì™€ ì‹œíŠ¸/íŒŒì¼ ë¶„ë¦¬ (íƒ­ì— ë”°ë¼ ë‹¤ë¥¸ í´ë” ëª©ë¡ ì‚¬ìš©)
    const selectedFolders = serverManagerTab === 'sheets'
        ? serverFoldersList.filter(f => selectedItems.server.has(f.id))
        : serverFileFoldersList.filter(f => selectedItems.server.has(f.id));
    const selectedSheets = serverManagerTab === 'sheets'
        ? serverSheetsList.filter(s => selectedItems.server.has(s.id))
        : [];
    const selectedFiles = serverManagerTab === 'files'
        ? serverFilesList.filter(f => selectedItems.server.has(f.id) && f.type === 'file')
        : [];
    
    const totalCount = selectedFolders.length + selectedSheets.length + selectedFiles.length;
    
    let msg = `${totalCount}ê°œ í•­ëª©ì„ ì„œë²„ì—ì„œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
    if (selectedFolders.length > 0) {
        msg += serverManagerTab === 'sheets' 
            ? `\n\nğŸ“ í´ë” ${selectedFolders.length}ê°œ (ë‚´ë¶€ ì‹œíŠ¸ í¬í•¨)`
            : `\n\nğŸ“ í´ë” ${selectedFolders.length}ê°œ (ë‚´ë¶€ íŒŒì¼ í¬í•¨)`;
    }
    msg += '\n\në˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
    
    if (!confirm(msg)) return;
    
    showLoading('ì„œë²„ì—ì„œ ì‚­ì œ ì¤‘...');
    let count = 0;
    
    try {
        // 1. í´ë” ì‚­ì œ (ë‚´ë¶€ ì‹œíŠ¸/íŒŒì¼ í¬í•¨)
        for (const folder of selectedFolders) {
            updateLoadingText(`í´ë” '${folder.name}' ì‚­ì œ ì¤‘...`);
            
            if (serverManagerTab === 'sheets') {
                // ì‹œíŠ¸ í´ë”: ë‚´ë¶€ ì‹œíŠ¸ë“¤ ì‚­ì œ
                const sheetsInFolder = serverSheetsList.filter(s => s.folderId === folder.id);
                for (const sheet of sheetsInFolder) {
                    const chunks = await db.collection('sheets').doc(sheet.id).collection('chunks').get();
                    for (const c of chunks.docs) await c.ref.delete();
                    await db.collection('sheets').doc(sheet.id).delete();
                }
                
                // ì‹œíŠ¸ í´ë” ì‚­ì œ
                await db.collection('folders').doc(folder.id).delete();
            } else {
                // íŒŒì¼ í´ë”: ë‚´ë¶€ íŒŒì¼ë“¤ ì‚­ì œ
                const filesInFolder = serverFilesList.filter(f => f.folderId === folder.id);
                for (const file of filesInFolder) {
                    await db.collection('userFiles').doc(file.id).delete();
                    const idx = fileStorage.findIndex(f => f.id === file.id);
                    if (idx !== -1) fileStorage.splice(idx, 1);
                    delete fileToFolder[file.id];
                }
                
                // íŒŒì¼ í´ë” ì‚­ì œ
                await db.collection('fileFolders').doc(folder.id).delete();
                delete fileFolders[folder.id];
            }
            
            count++;
        }
        
        // íŒŒì¼ í´ë” ì‚­ì œê°€ ìˆì—ˆìœ¼ë©´ ë§¤í•‘ ì €ì¥
        if (serverManagerTab === 'files' && selectedFolders.length > 0) {
            saveFileFolderData();
        }
        
        // 2. ê°œë³„ ì‹œíŠ¸ ì‚­ì œ
        for (const sheet of selectedSheets) {
            updateLoadingText(`'${sheet.name}' ì‚­ì œ ì¤‘...`);
            const chunks = await db.collection('sheets').doc(sheet.id).collection('chunks').get();
            for (const c of chunks.docs) await c.ref.delete();
            const rows = await db.collection('sheets').doc(sheet.id).collection('rows').get();
            for (const r of rows.docs) await r.ref.delete();
            await db.collection('sheets').doc(sheet.id).delete();
            count++;
        }
        
        // 3. íŒŒì¼ ì‚­ì œ
        for (const file of selectedFiles) {
            updateLoadingText(`'${file.name}' ì‚­ì œ ì¤‘...`);
            await db.collection('userFiles').doc(file.id).delete();
            const idx = fileStorage.findIndex(f => f.id === file.id);
            if (idx !== -1) fileStorage.splice(idx, 1);
            delete fileToFolder[file.id]; // í´ë” ë§¤í•‘ë„ ì‚­ì œ
            count++;
        }
        
        // íŒŒì¼ ì‚­ì œê°€ ìˆì—ˆìœ¼ë©´ ë§¤í•‘ ì €ì¥
        if (selectedFiles.length > 0) {
            saveFileFolderData();
        }
        
        hideLoading();
        toast(`${count}ê°œ ì‚­ì œ ì™„ë£Œ`);
        selectedItems.server.clear();
        if (serverManagerTab === 'files') renderFileStoragePanel();
        await loadServerManagerData();
        
    } catch (e) {
        hideLoading();
        console.error('ì‚­ì œ ì‹¤íŒ¨:', e);
        toast('ì‚­ì œ ì‹¤íŒ¨: ' + e.message);
    }
}

// ìƒˆë¡œê³ ì¹¨
async function refreshServerManager() {
    closeContextMenu();
    currentLocalFolderSM = null;
    currentServerFolderSM = null;
    selectedItems = { local: new Set(), server: new Set() };
    await loadServerManagerData();
    toast('ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ');
}

// ===== ë©”ì¸ í™”ë©´ í´ë” ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤ =====

// í´ë” ë„¤ë¹„ê²Œì´ì…˜ ì—…ë°ì´íŠ¸
function updateFolderBreadcrumb() {
    const breadcrumb = document.getElementById('folderBreadcrumb');
    if (!breadcrumb) return;
    
    let html = '';
    if (currentFolderId !== null) {
        // í´ë” ì•ˆì— ìˆì„ ë•Œ - "ì „ì²´"ì— ë“œë¡­ ê°€ëŠ¥
        html += `<span class="folder-breadcrumb-item" 
                       onclick="navigateToFolder(null)"
                       ondragover="event.preventDefault(); this.classList.add('drag-over')"
                       ondragleave="this.classList.remove('drag-over')"
                       ondrop="handleSheetDropToRoot(event)">ğŸ“ ì „ì²´</span>`;
        const folder = sheetFolders[currentFolderId];
        if (folder) {
            html += '<span class="folder-breadcrumb-sep">â€º</span>';
            html += `<span class="folder-breadcrumb-item current">${escHtml(folder.name)}</span>`;
        }
    } else {
        html = '<span class="folder-breadcrumb-item current" onclick="navigateToFolder(null)">ğŸ“ ì „ì²´</span>';
    }
    
    breadcrumb.innerHTML = html;
    
    // ë’¤ë¡œ/ì•ìœ¼ë¡œ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    updateFolderHistoryButtons();
}

// ì‹œíŠ¸ë¥¼ ë£¨íŠ¸(ì „ì²´)ë¡œ ë“œë¡­
function handleSheetDropToRoot(event) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    try {
        const data = JSON.parse(event.dataTransfer.getData('text/plain'));
        
        if (data.type === 'sheet') {
            const sheetsToMove = data.selectedSheets && data.selectedSheets.length > 0 
                ? data.selectedSheets 
                : [data.sheetName];
            
            sheetsToMove.forEach(sheetName => {
                delete sheetToFolder[sheetName]; // í´ë” ë§¤í•‘ ì œê±° = ë£¨íŠ¸ë¡œ ì´ë™
            });
            
            saveFolderData();
            multiSelectedSheets.clear();
            renderMainScreen();
            
            toast(`${sheetsToMove.length}ê°œ ì‹œíŠ¸ë¥¼ 'ì „ì²´'ë¡œ ì´ë™`);
        }
    } catch (e) {
        console.error('ë“œë¡­ ì²˜ë¦¬ ì˜¤ë¥˜:', e);
    }
}

// í´ë”ë¡œ ì´ë™
function navigateToFolder(folderId, addToHistory = true) {
    // ê°™ì€ í´ë”ë©´ ë¬´ì‹œ
    if (currentFolderId === folderId) return;
    
    // íˆìŠ¤í† ë¦¬ì— ì¶”ê°€ (ë’¤ë¡œ/ì•ìœ¼ë¡œë¡œ ì´ë™í•œ ê²½ìš° ì œì™¸)
    if (addToHistory) {
        // í˜„ì¬ ìœ„ì¹˜ ì´í›„ì˜ íˆìŠ¤í† ë¦¬ ì‚­ì œ (ìƒˆ ê²½ë¡œ íƒìƒ‰)
        folderHistory = folderHistory.slice(0, folderHistoryIndex + 1);
        
        // ìƒˆ í´ë” ì¶”ê°€
        folderHistory.push(folderId);
        folderHistoryIndex = folderHistory.length - 1;
        
        // ìµœëŒ€ ê¸°ë¡ ìˆ˜ ì œí•œ
        if (folderHistory.length > MAX_FOLDER_HISTORY) {
            folderHistory.shift();
            folderHistoryIndex--;
        }
    }
    
    currentFolderId = folderId;
    updateFolderHistoryButtons();
    renderMainScreen();
}

// ë’¤ë¡œ ê°€ê¸°
function folderGoBack() {
    if (folderHistoryIndex > 0) {
        folderHistoryIndex--;
        const folderId = folderHistory[folderHistoryIndex];
        navigateToFolder(folderId, false); // íˆìŠ¤í† ë¦¬ì— ì¶”ê°€í•˜ì§€ ì•ŠìŒ
    }
}

// ì•ìœ¼ë¡œ ê°€ê¸°
function folderGoForward() {
    if (folderHistoryIndex < folderHistory.length - 1) {
        folderHistoryIndex++;
        const folderId = folderHistory[folderHistoryIndex];
        navigateToFolder(folderId, false); // íˆìŠ¤í† ë¦¬ì— ì¶”ê°€í•˜ì§€ ì•ŠìŒ
    }
}

// ë’¤ë¡œ/ì•ìœ¼ë¡œ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
function updateFolderHistoryButtons() {
    const backBtn = document.getElementById('folderBackBtn');
    const forwardBtn = document.getElementById('folderForwardBtn');
    
    if (backBtn) {
        backBtn.disabled = folderHistoryIndex <= 0;
    }
    if (forwardBtn) {
        forwardBtn.disabled = folderHistoryIndex >= folderHistory.length - 1;
    }
}

// ìƒˆ í´ë” ìƒì„± (í˜„ì¬ íƒ­ì— ë”°ë¼ ì‹œíŠ¸ í´ë” ë˜ëŠ” íŒŒì¼ í´ë”)
function createNewFolder() {
    // í˜„ì¬ íƒ­ì´ íŒŒì¼ ë³´ê´€í•¨ì´ë©´ íŒŒì¼ í´ë” ìƒì„±
    if (currentMainTab === 'files') {
        createNewFileFolder();
        return;
    }
    
    // ì‹œíŠ¸ í´ë” ìƒì„±
    // ê¸°ì¡´ í´ë” ì´ë¦„ì—ì„œ "ìƒˆ í´ë”" ë²ˆí˜¸ í™•ì¸
    const existingNumbers = Object.values(sheetFolders)
        .map(f => {
            const match = f.name.match(/^ìƒˆ í´ë”\s*(\d*)$/);
            if (match) return match[1] ? parseInt(match[1]) : 1;
            return 0;
        })
        .filter(n => n > 0);
    
    // ë‹¤ìŒ ë²ˆí˜¸ ê²°ì •
    let nextNum = 1;
    while (existingNumbers.includes(nextNum)) {
        nextNum++;
    }
    
    const name = nextNum === 1 ? 'ìƒˆ í´ë”' : `ìƒˆ í´ë” ${nextNum}`;
    
    const folderId = 'folder_' + Date.now();
    sheetFolders[folderId] = {
        name: name,
        parentId: currentFolderId,
        createdAt: new Date().toISOString()
    };
    
    saveFolderData();
    renderMainScreen();
    toast(`í´ë” '${name}' ìƒì„± ì™„ë£Œ`);
    
    // ìƒì„± í›„ ë°”ë¡œ ì´ë¦„ ë³€ê²½ ëª¨ë“œë¡œ ì „í™˜
    setTimeout(() => {
        startRenameFolderCard(folderId);
    }, 100);
}

// ìƒˆ íŒŒì¼ í´ë” ìƒì„± (ìë™ ì´ë¦„ ë¶€ì—¬)
function createNewFileFolder() {
    // ê¸°ì¡´ í´ë” ì´ë¦„ì—ì„œ "ìƒˆ í´ë”" ë²ˆí˜¸ í™•ì¸
    const existingNumbers = Object.values(fileFolders)
        .map(f => {
            const match = f.name.match(/^ìƒˆ í´ë”\s*(\d*)$/);
            if (match) return match[1] ? parseInt(match[1]) : 1;
            return 0;
        })
        .filter(n => n > 0);
    
    // ë‹¤ìŒ ë²ˆí˜¸ ê²°ì •
    let nextNum = 1;
    while (existingNumbers.includes(nextNum)) {
        nextNum++;
    }
    
    const name = nextNum === 1 ? 'ìƒˆ í´ë”' : `ìƒˆ í´ë” ${nextNum}`;
    
    const folderId = 'ff_' + Date.now();
    fileFolders[folderId] = {
        name: name,
        parentId: currentFileFolderId,
        createdAt: new Date().toISOString()
    };
    
    saveFileFolderData();
    renderFileStoragePanel();
    toast(`í´ë” '${name}' ìƒì„± ì™„ë£Œ`);
    
    // ìƒì„± í›„ ë°”ë¡œ ì´ë¦„ ë³€ê²½ ëª¨ë“œë¡œ ì „í™˜
    setTimeout(() => {
        startRenameFileFolderCard(folderId);
    }, 100);
}

// í´ë” ì‚­ì œ í™•ì¸
function confirmDeleteFolder(folderId) {
    const folder = sheetFolders[folderId];
    if (!folder) return;
    
    const sheetsInFolder = Object.keys(sheetToFolder).filter(name => sheetToFolder[name] === folderId);
    const sheetCount = sheetsInFolder.length;
    
    if (sheetCount > 0) {
        // ì‹œíŠ¸ê°€ ìˆìœ¼ë©´ ì„ íƒ ì˜µì…˜ ì œê³µ
        const choice = confirm(
            `'${folder.name}' í´ë”ì— ${sheetCount}ê°œ ì‹œíŠ¸ê°€ ìˆìŠµë‹ˆë‹¤.\n\n` +
            `[í™•ì¸] ì‹œíŠ¸ë„ í•¨ê»˜ ì‚­ì œ\n` +
            `[ì·¨ì†Œ] í›„ ë‹¤ì‹œ ì‹œë„í•˜ì—¬ ì‹œíŠ¸ë¥¼ 'ì „ì²´'ë¡œ ì´ë™`
        );
        
        if (choice) {
            // í™•ì¸: ì‹œíŠ¸ë„ í•¨ê»˜ ì‚­ì œ
            if (!confirm(`ì •ë§ ${sheetCount}ê°œ ì‹œíŠ¸ë¥¼ í•¨ê»˜ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`)) return;
            
            for (const sheetName of sheetsInFolder) {
                delete WB[sheetName];
                delete COL_ORDER[sheetName];
                delete HIDDEN_COLS[sheetName];
                delete COL_WIDTHS[sheetName];
                delete ROW_HEIGHTS[sheetName];
                delete sheetToFolder[sheetName];
                if (favoriteSheets) favoriteSheets.delete(sheetName);
                if (newSheets) newSheets.delete(sheetName);
                if (multiSelectedSheets) multiSelectedSheets.delete(sheetName);
            }
            
            delete sheetFolders[folderId];
            
            // ì‚­ì œëœ í´ë”ê°€ í˜„ì¬ í´ë”ë©´ ë£¨íŠ¸ë¡œ ì´ë™
            if (currentFolderId === folderId) {
                currentFolderId = null;
            }
            
            saveFolderData();
            renderMainScreen();
            toast(`í´ë” + ${sheetCount}ê°œ ì‹œíŠ¸ ì‚­ì œ ì™„ë£Œ`);
        } else {
            // ì·¨ì†Œ í›„ ë‹¤ì‹œ ì‹œë„: ì‹œíŠ¸ë¥¼ ì „ì²´ë¡œ ì´ë™
            const moveChoice = confirm(
                `ì‹œíŠ¸ë¥¼ 'ì „ì²´'ë¡œ ì´ë™í•˜ê³  í´ë”ë§Œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`
            );
            
            if (moveChoice) {
                for (const sheetName of sheetsInFolder) {
                    delete sheetToFolder[sheetName];
                }
                
                delete sheetFolders[folderId];
                
                // ì‚­ì œëœ í´ë”ê°€ í˜„ì¬ í´ë”ë©´ ë£¨íŠ¸ë¡œ ì´ë™
                if (currentFolderId === folderId) {
                    currentFolderId = null;
                }
                
                saveFolderData();
                renderMainScreen();
                toast(`í´ë” ì‚­ì œ ì™„ë£Œ (${sheetCount}ê°œ ì‹œíŠ¸ëŠ” 'ì „ì²´'ë¡œ ì´ë™)`);
            }
        }
    } else {
        // ì‹œíŠ¸ê°€ ì—†ìœ¼ë©´ ë°”ë¡œ ì‚­ì œ
        if (!confirm(`'${folder.name}' í´ë”ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
        
        delete sheetFolders[folderId];
        
        // ì‚­ì œëœ í´ë”ê°€ í˜„ì¬ í´ë”ë©´ ë£¨íŠ¸ë¡œ ì´ë™
        if (currentFolderId === folderId) {
            currentFolderId = null;
        }
        
        saveFolderData();
        renderMainScreen();
        toast(`í´ë” '${folder.name}' ì‚­ì œ ì™„ë£Œ`);
    }
}

// í´ë” ì´ë¦„ ë³€ê²½ (prompt)
function renameFolder(folderId) {
    closeFolderContextMenu();
    const folder = sheetFolders[folderId];
    if (!folder) return;
    
    const newName = prompt('ìƒˆ í´ë” ì´ë¦„:', folder.name);
    if (!newName || !newName.trim() || newName === folder.name) return;
    
    folder.name = newName.trim();
    saveFolderData();
    renderMainScreen();
    toast(`í´ë” ì´ë¦„ ë³€ê²½ ì™„ë£Œ`);
}

// í´ë” ì´ë¦„ ë³€ê²½ ì‹œì‘ (ì¸ë¼ì¸ - ë”ë¸”í´ë¦­)
function startRenameFolderCard(folderId) {
    const folder = sheetFolders[folderId];
    if (!folder) return;

    const nameEl = document.getElementById(`folderName_${folderId}`);
    if (!nameEl) return;

    createInlineEdit({
        targetEl: nameEl,
        currentValue: folder.name,
        styleStr: 'font-size:14px;font-weight:600;padding:4px 8px;border:2px solid var(--retro-blue);border-radius:4px;width:100%;box-sizing:border-box;text-align:center;',
        onFinish: (newName) => {
            folder.name = newName;
            saveFolderData();
            toast(`í´ë” ì´ë¦„ ë³€ê²½ ì™„ë£Œ`);
            renderMainScreen();
        },
        onCancel: () => renderMainScreen()
    });
}

// í´ë” ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
function showFolderContextMenu(e, folderId, folderName) {
    e.preventDefault();
    e.stopPropagation();
    
    // ê¸°ì¡´ ë©”ë‰´ ë‹«ê¸°
    const existing = document.querySelector('.folder-context-menu');
    if (existing) existing.remove();
    
    const menu = document.createElement('div');
    menu.className = 'context-menu folder-context-menu show';
    menu.innerHTML = `
        <div class="menu-item" onclick="navigateToFolder('${folderId}'); closeFolderContextMenu();">ğŸ“‚ í´ë” ì—´ê¸°</div>
        <div class="menu-item" onclick="renameFolder('${folderId}')">âœï¸ ì´ë¦„ ë³€ê²½</div>
        <div class="menu-item danger" onclick="confirmDeleteFolder('${folderId}'); closeFolderContextMenu();">ğŸ—‘ï¸ ì‚­ì œ</div>
    `;
    
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    
    document.body.appendChild(menu);
    
    // í™”ë©´ ë°– ì²´í¬
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
    if (rect.bottom > window.innerHeight) menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
    
    // ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
    setTimeout(() => {
        document.addEventListener('click', closeFolderContextMenu, { once: true });
    }, 10);
}

function closeFolderContextMenu() {
    const menu = document.querySelector('.folder-context-menu');
    if (menu) menu.remove();
}

// ì‹œíŠ¸ ì¹´ë“œ ìš°í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
function showSheetCardContextMenu(e, sheetName) {
    e.preventDefault();
    e.stopPropagation();
    
    // ê¸°ì¡´ ë©”ë‰´ ë‹«ê¸°
    const existing = document.querySelector('.sheet-context-menu');
    if (existing) existing.remove();
    
    const safeName = sheetName.replace(/'/g, "\\'");
    const isFavorite = favoriteSheets.has(sheetName);
    
    // í´ë” ëª©ë¡ ìƒì„±
    const folderOptions = Object.entries(sheetFolders)
        .filter(([id, f]) => id !== sheetToFolder[sheetName])
        .map(([id, f]) => `<div class="menu-item" onclick="moveSheetToFolderFromMenu('${safeName}', '${id}')">ğŸ“ '${escHtml(f.name)}'ë¡œ ì´ë™</div>`)
        .join('');
    
    const currentFolderId = sheetToFolder[sheetName];
    const moveToRootOption = currentFolderId 
        ? `<div class="menu-item" onclick="moveSheetToFolderFromMenu('${safeName}', null)">â†© ì „ì²´ë¡œ ì´ë™</div>` 
        : '';
    
    const menu = document.createElement('div');
    menu.className = 'context-menu sheet-context-menu show';
    menu.innerHTML = `
        <div class="menu-item" onclick="handleSheetCardClick('${safeName}'); closeSheetContextMenu();">ğŸ“Š ì‹œíŠ¸ ì—´ê¸°</div>
        <div class="menu-item" onclick="startRenameSheetFromMenu('${safeName}')">âœï¸ ì´ë¦„ ë³€ê²½</div>
        <div class="menu-item" onclick="toggleFavorite('${safeName}'); closeSheetContextMenu();">${isFavorite ? 'â˜† ì¦ê²¨ì°¾ê¸° í•´ì œ' : 'â˜… ì¦ê²¨ì°¾ê¸°'}</div>
        <div class="context-menu-separator"></div>
        ${folderOptions}
        ${moveToRootOption}
        ${folderOptions || moveToRootOption ? '<div class="context-menu-separator"></div>' : ''}
        <div class="menu-item danger" onclick="confirmDeleteSheet('${safeName}'); closeSheetContextMenu();">ğŸ—‘ï¸ ì‚­ì œ</div>
    `;
    
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    
    document.body.appendChild(menu);
    
    // í™”ë©´ ë°– ì²´í¬
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
    if (rect.bottom > window.innerHeight) menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
    
    // ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
    setTimeout(() => {
        document.addEventListener('click', closeSheetContextMenu, { once: true });
    }, 10);
}

function closeSheetContextMenu() {
    const menu = document.querySelector('.sheet-context-menu');
    if (menu) menu.remove();
}

// ë©”ë‰´ì—ì„œ ì‹œíŠ¸ ì´ë¦„ ë³€ê²½ ì‹œì‘
function startRenameSheetFromMenu(sheetName) {
    closeSheetContextMenu();
    
    const newName = prompt('ìƒˆ ì‹œíŠ¸ ì´ë¦„:', sheetName);
    if (!newName || !newName.trim() || newName === sheetName) return;
    
    if (WB[newName]) {
        toast('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‹œíŠ¸ ì´ë¦„ì…ë‹ˆë‹¤');
        return;
    }
    
    renameSheet(sheetName, newName.trim());
    renderMainScreen();
    toast(`ì‹œíŠ¸ ì´ë¦„ ë³€ê²½: '${newName.trim()}'`);
}

// ë©”ë‰´ì—ì„œ ì‹œíŠ¸ë¥¼ í´ë”ë¡œ ì´ë™
function moveSheetToFolderFromMenu(sheetName, folderId) {
    closeSheetContextMenu();
    
    if (folderId === null) {
        delete sheetToFolder[sheetName];
        toast(`'${sheetName}'ì„(ë¥¼) ì „ì²´ë¡œ ì´ë™`);
    } else {
        sheetToFolder[sheetName] = folderId;
        const folderName = sheetFolders[folderId]?.name || 'í´ë”';
        toast(`'${sheetName}'ì„(ë¥¼) '${folderName}'ë¡œ ì´ë™`);
    }
    
    saveFolderData();
    renderMainScreen();
}

// ì‹œíŠ¸ ë“œë˜ê·¸ ì‹œì‘
function handleSheetDragStart(e, sheetName) {
    // ë‹¤ì¤‘ ì„ íƒëœ ìƒíƒœì—ì„œ ë“œë˜ê·¸í•˜ë©´, ì„ íƒëœ ì‹œíŠ¸ê°€ ì—†ê±°ë‚˜ í˜„ì¬ ì‹œíŠ¸ê°€ ì„ íƒ ì•ˆë˜ì–´ìˆìœ¼ë©´ í˜„ì¬ ì‹œíŠ¸ë§Œ
    if (multiSelectedSheets.size > 0 && !multiSelectedSheets.has(sheetName)) {
        // ì„ íƒ ì•ˆëœ ì‹œíŠ¸ë¥¼ ë“œë˜ê·¸í•˜ë©´ ê¸°ì¡´ ì„ íƒ ì´ˆê¸°í™”í•˜ê³  ì´ ì‹œíŠ¸ë§Œ
        multiSelectedSheets.clear();
        document.querySelectorAll('.sheet-card.multi-selected').forEach(el => {
            el.classList.remove('multi-selected');
        });
    }
    
    // ë‹¤ì¤‘ ì„ íƒì´ ì—†ìœ¼ë©´ í˜„ì¬ ì‹œíŠ¸ë¥¼ ì„ íƒì— ì¶”ê°€
    if (multiSelectedSheets.size === 0) {
        multiSelectedSheets.add(sheetName);
    }
    
    folderDragItem = { type: 'sheet', name: sheetName };
    e.dataTransfer.effectAllowed = 'move';
    
    // JSON í˜•ì‹ìœ¼ë¡œ ë°ì´í„° ì „ë‹¬ (ë‹¤ì¤‘ ì„ íƒ í¬í•¨)
    const dragData = {
        type: 'sheet',
        sheetName: sheetName,
        selectedSheets: Array.from(multiSelectedSheets)
    };
    e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
    e.target.classList.add('dragging');
    
    // ë“œë˜ê·¸ ì‹œ ì„ íƒëœ ê°œìˆ˜ í‘œì‹œ
    if (multiSelectedSheets.size > 1) {
        toast(`${multiSelectedSheets.size}ê°œ ì‹œíŠ¸ ë“œë˜ê·¸ ì¤‘...`);
    }
}

// ì‹œíŠ¸ ë“œë˜ê·¸ ì¢…ë£Œ
function handleSheetDragEnd(e) {
    e.target.classList.remove('dragging');
    folderDragItem = null;
    document.querySelectorAll('.folder-card.drag-over').forEach(el => el.classList.remove('drag-over'));
}

// í´ë” ìœ„ì— ë“œë˜ê·¸ ì˜¤ë²„
function handleFolderDragOver(e) {
    e.preventDefault();
    e.currentTarget.classList.add('drag-over');
}

// í´ë”ì—ì„œ ë“œë˜ê·¸ ë– ë‚¨
function handleFolderDragLeave(e) {
    e.currentTarget.classList.remove('drag-over');
}

// í´ë”ì— ë“œë¡­
function handleFolderDrop(e, folderId) {
    e.preventDefault();
    e.currentTarget.classList.remove('drag-over');
    
    const folder = sheetFolders[folderId];
    if (!folder) return;
    
    // ë‹¤ì¤‘ ì„ íƒëœ ì‹œíŠ¸ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒë“¤ì„ ì´ë™
    let sheetsToMove = [];
    if (multiSelectedSheets.size > 0) {
        sheetsToMove = Array.from(multiSelectedSheets);
    } else if (folderDragItem && folderDragItem.type === 'sheet') {
        sheetsToMove = [folderDragItem.name];
    }
    
    if (sheetsToMove.length === 0) return;
    
    // ë³‘í•© ëŒ€ìƒ ì°¾ê¸°
    const mergeTargets = []; // { source, target, sourceRows, targetRows }
    const justMove = []; // ê·¸ëƒ¥ ì´ë™í•  ì‹œíŠ¸ë“¤
    
    for (const sheetName of sheetsToMove) {
        if (!WB[sheetName]) continue;
        
        const movingSheet = WB[sheetName];
        const movingHeaders = JSON.stringify(movingSheet.headers);
        
        // ëŒ€ìƒ í´ë”ì—ì„œ ê°™ì€ í—¤ë”ë¥¼ ê°€ì§„ ì‹œíŠ¸ ì°¾ê¸°
        let targetSheetName = null;
        for (const [name, fid] of Object.entries(sheetToFolder)) {
            if (fid === folderId && WB[name] && name !== sheetName) {
                if (JSON.stringify(WB[name].headers) === movingHeaders) {
                    targetSheetName = name;
                    break;
                }
            }
        }
        
        if (targetSheetName) {
            mergeTargets.push({
                source: sheetName,
                target: targetSheetName,
                sourceRows: movingSheet.data.length,
                targetRows: WB[targetSheetName].data.length
            });
        } else {
            justMove.push(sheetName);
        }
    }
    
    // ë³‘í•© ëŒ€ìƒì´ ìˆìœ¼ë©´ í™•ì¸ ëª¨ë‹¬ í‘œì‹œ
    if (mergeTargets.length > 0) {
        showMergeConfirmModal(folderId, folder.name, mergeTargets, justMove);
    } else {
        // ë³‘í•© ëŒ€ìƒ ì—†ìœ¼ë©´ ë°”ë¡œ ì´ë™
        executeFolderMove(folderId, folder.name, [], justMove);
    }
}

// ë³‘í•© í™•ì¸ ëª¨ë‹¬ í‘œì‹œ
function showMergeConfirmModal(folderId, folderName, mergeTargets, justMove) {
    let mergeListHtml = '';
    for (const item of mergeTargets) {
        mergeListHtml += `
            <div class="merge-confirm-item">
                <label>
                    <input type="checkbox" class="merge-checkbox" 
                           data-source="${escHtml(item.source)}" 
                           data-target="${escHtml(item.target)}" checked>
                    <span class="merge-source">"${escHtml(item.source)}" (${item.sourceRows}í–‰)</span>
                    <span class="merge-arrow">â†’</span>
                    <span class="merge-target">"${escHtml(item.target)}" (${item.targetRows}í–‰)ì— ë³‘í•©</span>
                </label>
                <div class="merge-option">
                    <label>
                        <input type="radio" name="merge_${item.source.replace(/[^a-zA-Z0-9]/g, '_')}" value="merge" checked>
                        ë³‘í•©í•˜ê¸°
                    </label>
                    <label>
                        <input type="radio" name="merge_${item.source.replace(/[^a-zA-Z0-9]/g, '_')}" value="move">
                        ê·¸ëƒ¥ ì´ë™ (ë³„ë„ ì‹œíŠ¸ ìœ ì§€)
                    </label>
                </div>
            </div>
        `;
    }
    
    const modalHtml = `
        <div class="modal-overlay merge-confirm-modal show" id="mergeConfirmModal">
            <div class="modal-content" style="max-width:550px;">
                <div class="modal-header">
                    <h3>ğŸ“ "${escHtml(folderName)}" í´ë”ë¡œ ì´ë™</h3>
                    <button class="modal-close" onclick="closeMergeConfirmModal()">Ã—</button>
                </div>
                
                <div style="padding:15px 0;">
                    <p style="margin-bottom:15px;color:var(--retro-warm-gray);">
                        ê°™ì€ í—¤ë”ë¥¼ ê°€ì§„ ì‹œíŠ¸ê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤. ë³‘í•© ì—¬ë¶€ë¥¼ ì„ íƒí•˜ì„¸ìš”.
                    </p>
                    
                    <div class="merge-confirm-list">
                        ${mergeListHtml}
                    </div>
                    
                    ${justMove.length > 0 ? `
                        <div style="margin-top:15px;padding-top:15px;border-top:1px solid var(--retro-border);">
                            <div style="font-size:13px;color:var(--retro-warm-gray);">
                                ê·¸ëƒ¥ ì´ë™: ${justMove.map(n => `"${n}"`).join(', ')}
                            </div>
                        </div>
                    ` : ''}
                </div>
                
                <div class="modal-footer" style="display:flex;justify-content:flex-end;gap:10px;padding-top:15px;border-top:2px solid var(--retro-border);">
                    <button onclick="closeMergeConfirmModal()" style="padding:10px 20px;border:2px solid var(--retro-charcoal);border-radius:4px;background:white;font-weight:600;cursor:pointer;">ì·¨ì†Œ</button>
                    <button onclick="executeMergeConfirm('${folderId}')" style="padding:10px 20px;border:2px solid var(--retro-charcoal);border-radius:4px;background:var(--retro-blue);color:white;font-weight:600;cursor:pointer;">í™•ì¸</button>
                </div>
            </div>
        </div>
    `;
    
    // ì„ì‹œ ë°ì´í„° ì €ì¥
    window._pendingMerge = { folderId, folderName, mergeTargets, justMove };
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

// ë³‘í•© í™•ì¸ ëª¨ë‹¬ ë‹«ê¸°
function closeMergeConfirmModal() {
    const modal = document.getElementById('mergeConfirmModal');
    if (modal) modal.remove();
    window._pendingMerge = null;
    
    // ë‹¤ì¤‘ ì„ íƒ ì´ˆê¸°í™”
    multiSelectedSheets.clear();
    folderDragItem = null;
}

// ë³‘í•© í™•ì¸ í›„ ì‹¤í–‰
function executeMergeConfirm(folderId) {
    const pending = window._pendingMerge;
    if (!pending) return;
    
    const toMerge = [];
    const toMove = [...pending.justMove];
    
    // ê° ë³‘í•© ëŒ€ìƒì˜ ì„ íƒ í™•ì¸
    for (const item of pending.mergeTargets) {
        const radioName = `merge_${item.source.replace(/[^a-zA-Z0-9]/g, '_')}`;
        const selected = document.querySelector(`input[name="${radioName}"]:checked`);
        
        if (selected && selected.value === 'merge') {
            toMerge.push(item);
        } else {
            toMove.push(item.source);
        }
    }
    
    closeMergeConfirmModal();
    executeFolderMove(folderId, pending.folderName, toMerge, toMove);
}

// ì‹¤ì œ í´ë” ì´ë™/ë³‘í•© ì‹¤í–‰
function executeFolderMove(folderId, folderName, toMerge, toMove) {
    let movedCount = 0;
    let mergedCount = 0;
    let totalAddedRows = 0;
    
    // ë³‘í•© ì‹¤í–‰
    for (const item of toMerge) {
        const sourceSheet = WB[item.source];
        const targetSheet = WB[item.target];
        
        if (!sourceSheet || !targetSheet) continue;
        
        // ì¤‘ë³µ ì œê±°í•˜ë©° ë³‘í•©
        const existingSet = new Set(targetSheet.data.map(row => JSON.stringify(row)));
        let addedRows = 0;
        
        for (const row of sourceSheet.data) {
            const rowStr = JSON.stringify(row);
            if (!existingSet.has(rowStr)) {
                targetSheet.data.push(row);
                existingSet.add(rowStr);
                addedRows++;
            }
        }
        
        // ì›ë³¸ ì‹œíŠ¸ ì‚­ì œ
        delete WB[item.source];
        delete COL_ORDER[item.source];
        delete HIDDEN_COLS[item.source];
        delete COL_WIDTHS[item.source];
        delete ROW_HEIGHTS[item.source];
        delete sheetToFolder[item.source];
        favoriteSheets.delete(item.source);
        if (newSheets) newSheets.delete(item.source);
        if (multiSelectedSheets) multiSelectedSheets.delete(item.source);
        
        mergedCount++;
        totalAddedRows += addedRows;
        console.log(`'${item.source}' â†’ '${item.target}'ì— ${addedRows}í–‰ ë³‘í•©`);
    }
    
    // ë‹¨ìˆœ ì´ë™ ì‹¤í–‰
    for (const sheetName of toMove) {
        if (!WB[sheetName]) continue;
        if (folderId === null || folderId === '__root__') {
            delete sheetToFolder[sheetName]; // ë£¨íŠ¸ë¡œ ì´ë™
        } else {
            sheetToFolder[sheetName] = folderId;
        }
        movedCount++;
    }
    
    // ë‹¤ì¤‘ ì„ íƒ ì´ˆê¸°í™”
    multiSelectedSheets.clear();
    folderDragItem = null;
    
    saveFolderData();
    renderMainScreen();
    
    // ê²°ê³¼ ë©”ì‹œì§€
    let msg = '';
    if (movedCount > 0) msg += `${movedCount}ê°œ ì´ë™`;
    if (mergedCount > 0) {
        if (msg) msg += ', ';
        msg += `${mergedCount}ê°œ ë³‘í•© (+${totalAddedRows}í–‰)`;
    }
    if (msg) {
        toast(`'${folderName}' í´ë”ë¡œ ${msg}`);
    }
}

// ===== ë‹¤ì¤‘ ì„ íƒ (ë“œë˜ê·¸ ë°•ìŠ¤) =====
let multiSelectedSheets = new Set();
let isDragSelecting = false;
let dragSelectStart = { x: 0, y: 0 };
let dragSelectBox = null;
let dragSelectInitialized = false;
let dragSelectPending = false; // ë“œë˜ê·¸ ëŒ€ê¸° ìƒíƒœ
let dragSelectMinDistance = 5; // ìµœì†Œ ë“œë˜ê·¸ ê±°ë¦¬ (px)

// ë“œë˜ê·¸ ì„ íƒ ì´ˆê¸°í™” (sheetGridì— ì´ë²¤íŠ¸ ë“±ë¡)
function initDragSelect() {
    const mainContent = document.querySelector('.main-content');
    if (!mainContent) return;
    
    // ì¤‘ë³µ ë“±ë¡ ë°©ì§€
    if (dragSelectInitialized) return;
    dragSelectInitialized = true;
    
    mainContent.addEventListener('mousedown', prepareDragSelect);
    document.addEventListener('mousemove', handleDragSelectMove);
    document.addEventListener('mouseup', endDragSelect);
}

// ë“œë˜ê·¸ ì„ íƒ ì¤€ë¹„ (ë§ˆìš°ìŠ¤ ë‹¤ìš´)
function prepareDragSelect(e) {
    // ë²„íŠ¼, ì²´í¬ë°•ìŠ¤, ì…ë ¥ í•„ë“œ ë“±ì€ ë¬´ì‹œ
    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.closest('button')) {
        return;
    }
    
    // í´ë” ì¹´ë“œ ìœ„ì—ì„œëŠ” ë¬´ì‹œ
    if (e.target.closest('.folder-card')) {
        return;
    }
    
    // íŒŒì¼ ì¹´ë“œ ìœ„ì—ì„œëŠ” ë¬´ì‹œ (íŒŒì¼ ë“œë˜ê·¸ í—ˆìš©)
    if (e.target.closest('.file-card') || e.target.closest('.file-storage-item')) {
        const fileCard = e.target.closest('.file-card') || e.target.closest('.file-storage-item');
        const fileId = fileCard.dataset.fileId;
        // Ctrl/Cmd í´ë¦­ì´ë©´ ë‹¤ì¤‘ ì„ íƒ í† ê¸€
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (multiSelectedFiles.has(fileId)) {
                multiSelectedFiles.delete(fileId);
                fileCard.classList.remove('selected');
            } else {
                multiSelectedFiles.add(fileId);
                fileCard.classList.add('selected');
            }
            return;
        }
        // íŒŒì¼ ì¹´ë“œ ìœ„ì—ì„œëŠ” ê¸°ì¡´ draggable ë™ì‘ì— ë§¡ê¹€ (ë‹¨ì¼ ë“œë˜ê·¸ ì´ë™)
        return;
    }
    
    // ì™¼ìª½ ë²„íŠ¼ë§Œ
    if (e.button !== 0) return;
    
    // ì‹œíŠ¸ ì¹´ë“œ ìœ„ì—ì„œ ì‹œì‘í•˜ëŠ” ê²½ìš°
    const sheetCard = e.target.closest('.sheet-card');
    if (sheetCard) {
        const sheetName = sheetCard.dataset.sheet;
        // Ctrl/Cmd í´ë¦­ì´ë©´ ë‹¤ì¤‘ ì„ íƒ í† ê¸€
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (multiSelectedSheets.has(sheetName)) {
                multiSelectedSheets.delete(sheetName);
                sheetCard.classList.remove('multi-selected');
            } else {
                multiSelectedSheets.add(sheetName);
                sheetCard.classList.add('multi-selected');
            }
            updateMergeActionButton();
            return;
        }
        // ì‹œíŠ¸ ì¹´ë“œ ìœ„ì—ì„œëŠ” ê¸°ì¡´ draggable ë™ì‘ì— ë§¡ê¹€ (ë‹¨ì¼ ë“œë˜ê·¸ ì´ë™)
        return;
    }
    
    // ë¹ˆ ê³µê°„ì—ì„œë§Œ ë“œë˜ê·¸ ì„ íƒ ì‹œì‘
    // ë“œë˜ê·¸ ëŒ€ê¸° ìƒíƒœë¡œ ì „í™˜
    dragSelectPending = true;
    dragSelectStart = { x: e.clientX, y: e.clientY };
    
    e.preventDefault();
}

// ë“œë˜ê·¸ ì´ë™ ì²˜ë¦¬
function handleDragSelectMove(e) {
    if (!dragSelectPending && !isDragSelecting) return;
    
    const dx = e.clientX - dragSelectStart.x;
    const dy = e.clientY - dragSelectStart.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // ëŒ€ê¸° ìƒíƒœì—ì„œ ìµœì†Œ ê±°ë¦¬ ì´ìƒ ì´ë™í•˜ë©´ ë“œë˜ê·¸ ì„ íƒ ì‹œì‘
    if (dragSelectPending && distance >= dragSelectMinDistance) {
        startDragSelect(e);
        return;
    }
    
    // ë“œë˜ê·¸ ì„ íƒ ì¤‘ì´ë©´ ë°•ìŠ¤ ì—…ë°ì´íŠ¸
    if (isDragSelecting) {
        updateDragSelect(e);
    }
}

// ë“œë˜ê·¸ ì„ íƒ ì‹œì‘
function startDragSelect(e) {
    dragSelectPending = false;
    isDragSelecting = true;
    
    // ê¸°ì¡´ ì„ íƒ ì´ˆê¸°í™” (Shift ì•ˆ ëˆ„ë¥´ë©´)
    if (!e.shiftKey) {
        multiSelectedSheets.clear();
        document.querySelectorAll('.sheet-card.multi-selected').forEach(el => {
            el.classList.remove('multi-selected');
        });
    }
    
    // ì„ íƒ ë°•ìŠ¤ ìƒì„±
    dragSelectBox = document.createElement('div');
    dragSelectBox.className = 'drag-select-box';
    dragSelectBox.style.cssText = `
        position: fixed;
        border: 2px dashed var(--retro-teal);
        background: rgba(45, 140, 158, 0.15);
        pointer-events: none;
        z-index: 10000;
        border-radius: 4px;
        transition: none;
    `;
    document.body.appendChild(dragSelectBox);
    
    document.getElementById('sheetGrid')?.classList.add('selecting');
    document.body.style.userSelect = 'none';
    document.body.style.cursor = 'crosshair';
    
    updateDragSelect(e);
}

// ë“œë˜ê·¸ ì„ íƒ ì—…ë°ì´íŠ¸
function updateDragSelect(e) {
    if (!isDragSelecting || !dragSelectBox) return;
    
    const x = Math.min(e.clientX, dragSelectStart.x);
    const y = Math.min(e.clientY, dragSelectStart.y);
    const w = Math.abs(e.clientX - dragSelectStart.x);
    const h = Math.abs(e.clientY - dragSelectStart.y);
    
    dragSelectBox.style.left = x + 'px';
    dragSelectBox.style.top = y + 'px';
    dragSelectBox.style.width = w + 'px';
    dragSelectBox.style.height = h + 'px';
    
    // ì„ íƒ ë°•ìŠ¤ì™€ ê²¹ì¹˜ëŠ” ì‹œíŠ¸ ì¹´ë“œ í•˜ì´ë¼ì´íŠ¸
    const boxRect = { left: x, top: y, right: x + w, bottom: y + h };
    
    document.querySelectorAll('.sheet-card').forEach(card => {
        const cardRect = card.getBoundingClientRect();
        const intersects = !(
            cardRect.right < boxRect.left ||
            cardRect.left > boxRect.right ||
            cardRect.bottom < boxRect.top ||
            cardRect.top > boxRect.bottom
        );
        
        if (intersects) {
            card.classList.add('drag-selecting');
        } else {
            card.classList.remove('drag-selecting');
        }
    });
}

// ë“œë˜ê·¸ ì„ íƒ ì¢…ë£Œ
function endDragSelect(e) {
    // ëŒ€ê¸° ìƒíƒœì˜€ë‹¤ë©´ (ë“œë˜ê·¸ ì•ˆ í•˜ê³  í´ë¦­ë§Œ)
    if (dragSelectPending) {
        dragSelectPending = false;
        
        // ë¹ˆ ê³µê°„ í´ë¦­ì´ë©´ ì„ íƒ í•´ì œ
        const sheetCard = e.target.closest('.sheet-card');
        if (!sheetCard && !(e.ctrlKey || e.metaKey)) {
            multiSelectedSheets.clear();
            document.querySelectorAll('.sheet-card.multi-selected').forEach(el => {
                el.classList.remove('multi-selected');
            });
            updateMergeActionButton();
        }
        return;
    }
    
    if (!isDragSelecting) return;
    
    isDragSelecting = false;
    document.getElementById('sheetGrid')?.classList.remove('selecting');
    document.body.style.userSelect = '';
    document.body.style.cursor = '';
    
    // ì„ íƒëœ ì‹œíŠ¸ë“¤ í™•ì •
    const selectedCount = document.querySelectorAll('.sheet-card.drag-selecting').length;
    document.querySelectorAll('.sheet-card.drag-selecting').forEach(card => {
        const sheetName = card.dataset.sheet;
        if (sheetName) {
            multiSelectedSheets.add(sheetName);
            card.classList.add('multi-selected');
        }
        card.classList.remove('drag-selecting');
    });
    
    // ì„ íƒ ë°•ìŠ¤ ì œê±°
    if (dragSelectBox) {
        dragSelectBox.remove();
        dragSelectBox = null;
    }
    
    // ì„ íƒ ê°œìˆ˜ í‘œì‹œ ë° ë³‘í•© ë²„íŠ¼ ì—…ë°ì´íŠ¸
    if (selectedCount > 0) {
        toast(`${multiSelectedSheets.size}ê°œ ì‹œíŠ¸ ì„ íƒë¨ (Ctrl+í´ë¦­ìœ¼ë¡œ ì¶”ê°€/ì œê±°)`);
    }
    updateMergeActionButton();
}

// ì‹œíŠ¸ ì¹´ë“œ í´ë¦­ ì‹œ ë‹¤ì¤‘ ì„ íƒ í† ê¸€
function toggleMultiSelect(e, sheetName) {
    if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        e.stopPropagation();
        
        if (multiSelectedSheets.has(sheetName)) {
            multiSelectedSheets.delete(sheetName);
            e.currentTarget.classList.remove('multi-selected');
        } else {
            multiSelectedSheets.add(sheetName);
            e.currentTarget.classList.add('multi-selected');
        }
        
        if (multiSelectedSheets.size > 0) {
            toast(`${multiSelectedSheets.size}ê°œ ì‹œíŠ¸ ì„ íƒë¨`);
        }
        updateMergeActionButton();
        
        return true; // ì²˜ë¦¬ë¨
    }
    return false; // ê¸°ë³¸ ë™ì‘ ì§„í–‰
}

// ë‹¤ì¤‘ ì„ íƒ ì´ˆê¸°í™”
function clearMultiSelect() {
    multiSelectedSheets.clear();
    document.querySelectorAll('.sheet-card.multi-selected').forEach(el => {
        el.classList.remove('multi-selected');
    });
    updateMergeActionButton();
}

// ì‹œíŠ¸ë¥¼ í´ë”ì—ì„œ ë¹¼ê¸° (ë£¨íŠ¸ë¡œ ì´ë™)
function removeSheetFromFolder(sheetName) {
    if (sheetToFolder[sheetName]) {
        delete sheetToFolder[sheetName];
        saveFolderData();
        renderMainScreen();
        toast(`'${sheetName}' â†’ ì „ì²´ë¡œ ì´ë™`);
    }
}

// í´ë” ë°ì´í„° ì €ì¥ (ë¡œì»¬ìŠ¤í† ë¦¬ì§€)
function saveFolderData() {
    try {
        localStorage.setItem('excelmaster_folders', JSON.stringify(sheetFolders));
        localStorage.setItem('excelmaster_sheetToFolder', JSON.stringify(sheetToFolder));
    } catch (e) {
        console.error('í´ë” ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:', e);
    }
}

// í´ë” ë°ì´í„° ë¡œë“œ (ë¡œì»¬ìŠ¤í† ë¦¬ì§€)
function loadFolderData() {
    try {
        const foldersData = localStorage.getItem('excelmaster_folders');
        const mappingData = localStorage.getItem('excelmaster_sheetToFolder');
        
        if (foldersData) {
            sheetFolders = JSON.parse(foldersData);
        }
        if (mappingData) {
            sheetToFolder = JSON.parse(mappingData);
        }
        
        // ì •ë¦¬ëŠ” WBê°€ ë¡œë“œëœ í›„ ìˆ˜í–‰ (loadFromLocalStorageì—ì„œ í˜¸ì¶œ)
    } catch (e) {
        console.error('í´ë” ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', e);
        sheetFolders = {};
        sheetToFolder = {};
    }
}

// WBì— ì—†ëŠ” ì‹œíŠ¸ ë§¤í•‘ ì •ë¦¬
function cleanupOrphanedMappings() {
    // WBê°€ ë¹„ì–´ìˆìœ¼ë©´ ì •ë¦¬í•˜ì§€ ì•ŠìŒ (ì´ˆê¸°í™” ì „ í˜¸ì¶œ ë°©ì§€)
    if (Object.keys(WB).length === 0) {
        return;
    }
    
    let cleaned = false;
    
    // sheetToFolderì—ì„œ WBì— ì™„ì „íˆ ì—†ëŠ” ì‹œíŠ¸ë§Œ ì œê±° (ë¹ˆ ì‹œíŠ¸ëŠ” ìœ ì§€)
    for (const sheetName in sheetToFolder) {
        // WBì— ì‹œíŠ¸ ìì²´ê°€ ì—†ëŠ” ê²½ìš°ë§Œ ë§¤í•‘ ì œê±°
        if (!WB[sheetName]) {
            delete sheetToFolder[sheetName];
            cleaned = true;
        }
    }
    
    // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í´ë”ì— ëŒ€í•œ ë§¤í•‘ ì •ë¦¬
    for (const sheetName in sheetToFolder) {
        const folderId = sheetToFolder[sheetName];
        if (folderId && !sheetFolders[folderId]) {
            delete sheetToFolder[sheetName];
            cleaned = true;
        }
    }
    
    if (cleaned) {
        saveFolderData();
    }
}

// ì•± ì´ˆê¸°í™” ì‹œ í´ë” ë°ì´í„° ë¡œë“œ
document.addEventListener('DOMContentLoaded', () => {
    loadFolderData();
});

// ===== ì¤‘ë³µ ì‹œíŠ¸ ê°ì§€ ë° ë³‘í•© ê¸°ëŠ¥ =====

// ì¤‘ë³µ ì‹œíŠ¸ í (ì—¬ëŸ¬ ê°œ ì¤‘ë³µ ì‹œ ìˆœì°¨ ì²˜ë¦¬)
let duplicateQueue = [];
let duplicateGroupQueue = []; // ê·¸ë£¹ ë³‘í•©ìš© í
let currentDuplicateData = null;
let currentDuplicateGroup = null; // í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ê·¸ë£¹
let isMerging = false; // ë³‘í•© ì¤‘ë³µ í´ë¦­ ë°©ì§€

// ê·¸ë£¹ ë³‘í•© íì— ì¶”ê°€
function queueDuplicateGroup(group) {
    duplicateGroupQueue.push(group);
    
    // í˜„ì¬ ëª¨ë‹¬ì´ ì—†ìœ¼ë©´ ë°”ë¡œ í‘œì‹œ
    if (!document.getElementById('duplicateModalOverlay') && !document.getElementById('groupMergeModalOverlay')) {
        processNextDuplicateGroup();
    }
}

// ë‹¤ìŒ ê·¸ë£¹ ë³‘í•© ì²˜ë¦¬
function processNextDuplicateGroup() {
    if (duplicateGroupQueue.length > 0) {
        const group = duplicateGroupQueue.shift();
        showGroupMergeModal(group);
    } else {
        // ê·¸ë£¹ íê°€ ë¹„ë©´ ì¼ë°˜ ì¤‘ë³µ í ì²˜ë¦¬
        processNextDuplicate();
    }
}

// ê·¸ë£¹ ë³‘í•© ëª¨ë‹¬ í‘œì‹œ (ìµœëŒ€ 10ê°œ)
function showGroupMergeModal(group) {
    // ê¸°ì¡´ ëª¨ë‹¬ ì œê±°
    const existingModal = document.getElementById('groupMergeModalOverlay');
    if (existingModal) existingModal.remove();
    
    currentDuplicateGroup = group;
    isMerging = false;
    
    // ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ í‘œì‹œ
    const displaySheets = group.newSheets.slice(0, 10);
    const totalSheets = group.newSheets.length + 1; // ê¸°ì¡´ ì‹œíŠ¸ í¬í•¨
    
    // ì´ í–‰ ìˆ˜ ê³„ì‚°
    let totalRows = group.existingRows;
    group.newSheets.forEach(s => totalRows += s.rows);
    
    // ì‹œíŠ¸ëª…ì—ì„œ ìµœì‹  ë‚ ì§œ ì¶”ì¶œí•˜ì—¬ ê¸°ë³¸ ì´ë¦„ ìƒì„±
    const allNames = [group.existingSheet, ...group.newSheets.map(s => s.name)];
    const defaultMergedName = getLatestDateName(allNames) || group.existingSheet + '_í†µí•©';
    
    // ëª¨ë‹¬ HTML ìƒì„±
    let listHtml = '';
    
    // ê¸°ì¡´ ì‹œíŠ¸ (ê¸°ì¤€)
    listHtml += `
        <div class="group-merge-item existing">
            <span class="group-merge-item-badge">ê¸°ì¤€</span>
            <span class="group-merge-item-name">${escHtml(group.existingSheet)}</span>
            <span class="group-merge-item-rows">${group.existingRows.toLocaleString()}í–‰</span>
        </div>
    `;
    
    // ìƒˆ ì‹œíŠ¸ë“¤
    displaySheets.forEach((sheet, idx) => {
        listHtml += `
            <div class="group-merge-item">
                <span class="group-merge-item-name">ğŸ“Š ${escHtml(sheet.name)}</span>
                <span class="group-merge-item-rows">${sheet.rows.toLocaleString()}í–‰</span>
            </div>
        `;
    });
    
    // 10ê°œ ì´ˆê³¼ ì‹œ ì•ˆë‚´
    if (group.newSheets.length > 10) {
        listHtml += `
            <div class="group-merge-item" style="background:#fff3cd;justify-content:center;">
                <span style="color:#856404;font-size:12px;">ì™¸ ${group.newSheets.length - 10}ê°œ ì‹œíŠ¸ ë” ìˆìŒ</span>
            </div>
        `;
    }
    
    const modalHtml = `
        <div class="duplicate-modal-overlay" id="groupMergeModalOverlay">
            <div class="group-merge-modal">
                <div class="group-merge-header">
                    ë™ì¼ êµ¬ì¡° ì‹œíŠ¸ ${totalSheets}ê°œ ê°ì§€
                </div>
                <div class="group-merge-body">
                    <div class="group-merge-list">
                        ${listHtml}
                    </div>
                    <div class="group-merge-summary">
                        <span class="group-merge-summary-label">ë³‘í•© ì‹œ ì´ í–‰ ìˆ˜</span>
                        <span class="group-merge-summary-value">${totalRows.toLocaleString()}í–‰</span>
                    </div>
                    <input type="text" class="group-merge-name-input" id="groupMergedName" 
                           value="${escHtml(defaultMergedName)}" placeholder="ë³‘í•© í›„ ì‹œíŠ¸ëª…">
                    <div class="group-merge-footer">
                        <button class="duplicate-btn cancel" onclick="cancelGroupMerge()">ì·¨ì†Œ</button>
                        <button class="duplicate-btn separate" onclick="saveGroupSeparate()">ê°ê° ë¶„ë¦¬</button>
                        <button class="duplicate-btn merge" onclick="mergeGroupSheets()">í•˜ë‚˜ë¡œ ë³‘í•©</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤
    setTimeout(() => {
        document.getElementById('groupMergedName')?.focus();
    }, 100);
}

// ì‹œíŠ¸ëª…ë“¤ì—ì„œ ìµœì‹  ë‚ ì§œë¥¼ ì¶”ì¶œí•˜ì—¬ ì´ë¦„ ìƒì„±
function getLatestDateName(names) {
    let latestDate = null;
    let baseName = '';
    
    const patterns = [
        /(\d{4})[.\-_](\d{2})[.\-_](\d{2})/,
        /(\d{4})(\d{2})(\d{2})/
    ];
    
    for (const name of names) {
        for (const pattern of patterns) {
            const match = name.match(pattern);
            if (match) {
                const date = new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                if (!latestDate || date > latestDate) {
                    latestDate = date;
                }
                // ê¸°ë³¸ ì´ë¦„ ì¶”ì¶œ (ë‚ ì§œ ë¶€ë¶„ ì œê±°)
                if (!baseName) {
                    baseName = name.replace(/[\s_]*\d{4}[.\-_]?\d{2}[.\-_]?\d{2}[\s_]*/g, '').trim();
                }
                break;
            }
        }
    }
    
    if (latestDate && baseName) {
        const y = latestDate.getFullYear();
        const m = String(latestDate.getMonth() + 1).padStart(2, '0');
        const d = String(latestDate.getDate()).padStart(2, '0');
        return `${baseName} ${y}.${m}.${d}`;
    }
    
    return null;
}

// ê·¸ë£¹ ë³‘í•© ì·¨ì†Œ
function cancelGroupMerge() {
    if (isMerging) return;
    isMerging = true;
    toast('ì—…ë¡œë“œ ì·¨ì†Œë¨');
    closeGroupMergeModal();
}

// ê·¸ë£¹ ê°ê° ë¶„ë¦¬ ì €ì¥
function saveGroupSeparate() {
    if (!currentDuplicateGroup) return;
    if (isMerging) return;
    isMerging = true;
    
    const group = currentDuplicateGroup;
    let savedCount = 0;
    
    // ê° ì‹œíŠ¸ë¥¼ ìƒˆ ì´ë¦„ìœ¼ë¡œ ì €ì¥
    group.newSheets.forEach(sheet => {
        let newName = sheet.name;
        let suffix = 2;
        while (WB[newName]) {
            newName = `${sheet.name}_${suffix}`;
            suffix++;
        }
        
        WB[newName] = { headers: group.headers, data: sheet.data };
        COL_ORDER[newName] = group.headers.map((_, i) => i);
        HIDDEN_COLS[newName] = new Set();
        savedCount++;
    });
    
    toast(`${savedCount}ê°œ ì‹œíŠ¸ ë³„ë„ ì €ì¥ ì™„ë£Œ`);
    closeGroupMergeModal();
    saveToLocalStorage();
    renderMainScreen();
    renderSpreadsheet();
}

// ê·¸ë£¹ í•˜ë‚˜ë¡œ ë³‘í•©
function mergeGroupSheets() {
    if (!currentDuplicateGroup) return;
    if (isMerging) return;
    isMerging = true;
    
    const group = currentDuplicateGroup;
    const mergedName = document.getElementById('groupMergedName')?.value.trim() || group.existingSheet;
    
    // ê¸°ì¡´ ì‹œíŠ¸ ë°ì´í„° (ê¸°ì¤€)
    const existingData = WB[group.existingSheet];
    if (!existingData) {
        toast('ê¸°ì¡´ ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        closeGroupMergeModal();
        return;
    }
    
    // ê¸°ì¡´ ë°ì´í„°ë¥¼ Setìœ¼ë¡œ ë³€í™˜ (ì¤‘ë³µ ì œê±°ìš©)
    const existingSet = new Set(existingData.data.map(row => JSON.stringify(row)));
    let mergedData = [...existingData.data];
    let addedCount = 0;
    
    // ìƒˆ ì‹œíŠ¸ë“¤ì˜ ë°ì´í„° ë³‘í•©
    group.newSheets.forEach(sheet => {
        sheet.data.forEach(row => {
            const rowStr = JSON.stringify(row);
            if (!existingSet.has(rowStr)) {
                existingSet.add(rowStr);
                mergedData.push(row);
                addedCount++;
            }
        });
    });
    
    // ê¸°ì¡´ ì‹œíŠ¸ ì‚­ì œ (ì´ë¦„ì´ ë‹¤ë¥¸ ê²½ìš°)
    if (mergedName !== group.existingSheet) {
        delete WB[group.existingSheet];
        delete COL_ORDER[group.existingSheet];
        delete HIDDEN_COLS[group.existingSheet];
    }
    
    // ë³‘í•©ëœ ì‹œíŠ¸ ì €ì¥
    WB[mergedName] = {
        headers: group.headers,
        data: mergedData
    };
    COL_ORDER[mergedName] = group.headers.map((_, i) => i);
    HIDDEN_COLS[mergedName] = new Set();
    
    // NEW ë°°ì§€ í‘œì‹œ
    newSheets.add(mergedName);
    
    const totalSheets = group.newSheets.length + 1;
    toast(`${totalSheets}ê°œ ì‹œíŠ¸ ë³‘í•© ì™„ë£Œ (+${addedCount}í–‰ ì¶”ê°€)`);
    
    closeGroupMergeModal();
    saveToLocalStorage();
    renderMainScreen();
    renderSpreadsheet();
}

// ê·¸ë£¹ ë³‘í•© ëª¨ë‹¬ ë‹«ê¸°
function closeGroupMergeModal() {
    const overlay = document.getElementById('groupMergeModalOverlay');
    if (overlay) overlay.remove();
    currentDuplicateGroup = null;
    isMerging = false;
    
    // ë‹¤ìŒ ê·¸ë£¹ ë˜ëŠ” ì¼ë°˜ ì¤‘ë³µ ì²˜ë¦¬
    processNextDuplicateGroup();
}

// ì¤‘ë³µ ì‹œíŠ¸ ê°ì§€ ëª¨ë‹¬ í‘œì‹œ
function showDuplicateModal(existingName, existingRows, newName, newRows, newData) {
    // ê¸°ì¡´ ëª¨ë‹¬ ì œê±°
    const existingModal = document.getElementById('duplicateModalOverlay');
    if (existingModal) existingModal.remove();
    
    // ìœ íš¨ì„± ì²´í¬
    if (!newData || !newData.headers || !newData.data || newData.data.length === 0) {
        processNextDuplicate(); // ë‹¤ìŒ í•­ëª© ì²˜ë¦¬
        return;
    }
    
    if (!WB[existingName] || !WB[existingName].data) {
        processNextDuplicate(); // ë‹¤ìŒ í•­ëª© ì²˜ë¦¬
        return;
    }
    
    const diff = newRows - existingRows;
    
    // ë³‘í•© í”Œë˜ê·¸ ë¦¬ì…‹
    isMerging = false;
    
    // í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ë°ì´í„° ì €ì¥
    currentDuplicateData = {
        existingName: existingName,
        newName: newName,
        newData: newData,
        existingRows: existingRows,
        newRows: newRows
    };
    
    // ì‹œíŠ¸ëª…ì—ì„œ ë‚ ì§œ ì¶”ì¶œí•˜ì—¬ ìµœì‹  ë‚ ì§œ ê¸°ì¤€ ì´ë¦„ ìƒì„±
    function extractDateFromName(name) {
        // ë‹¤ì–‘í•œ ë‚ ì§œ íŒ¨í„´ ë§¤ì¹­: 2026.01.15, 2026-01-15, 2026_01_15, 20260115
        const patterns = [
            /(\d{4})[.\-_](\d{2})[.\-_](\d{2})/,  // 2026.01.15, 2026-01-15, 2026_01_15
            /(\d{4})(\d{2})(\d{2})/                // 20260115
        ];
        for (const pattern of patterns) {
            const match = name.match(pattern);
            if (match) {
                return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
            }
        }
        return null;
    }
    
    function getBaseName(name) {
        // ë‚ ì§œ ë¶€ë¶„ ì œê±°í•˜ì—¬ ê¸°ë³¸ ì´ë¦„ ì¶”ì¶œ
        return name.replace(/[\s_]*\d{4}[.\-_]?\d{2}[.\-_]?\d{2}[\s_]*/g, '').trim();
    }
    
    function formatDateForName(date) {
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const d = String(date.getDate()).padStart(2, '0');
        return `${y}.${m}.${d}`;
    }
    
    // ìµœì‹  ë‚ ì§œ ê¸°ì¤€ ì´ë¦„ ê²°ì •
    const existingDate = extractDateFromName(existingName);
    const newDate = extractDateFromName(newName);
    const baseName = getBaseName(existingName) || getBaseName(newName) || existingName;
    
    let defaultMergedName;
    if (existingDate && newDate) {
        // ë‘˜ ë‹¤ ë‚ ì§œê°€ ìˆìœ¼ë©´ ìµœì‹  ë‚ ì§œ ì‚¬ìš©
        const latestDate = existingDate > newDate ? existingDate : newDate;
        defaultMergedName = `${baseName} ${formatDateForName(latestDate)}`;
    } else if (newDate) {
        // ìƒˆ ì‹œíŠ¸ì—ë§Œ ë‚ ì§œê°€ ìˆìœ¼ë©´ ìƒˆ ë‚ ì§œ ì‚¬ìš©
        defaultMergedName = `${baseName} ${formatDateForName(newDate)}`;
    } else if (existingDate) {
        // ê¸°ì¡´ì—ë§Œ ë‚ ì§œê°€ ìˆìœ¼ë©´ ê¸°ì¡´ ì´ë¦„ ìœ ì§€
        defaultMergedName = existingName;
    } else {
        // ë‘˜ ë‹¤ ë‚ ì§œ ì—†ìœ¼ë©´ ê¸°ì¡´ ì´ë¦„ì— _í†µí•©
        defaultMergedName = `${existingName}_í†µí•©`;
    }
    
    // ë™ì¼í•œ í–‰ ìˆ˜ì¸ ê²½ìš° - ë®ì–´ì“°ê¸° í™•ì¸ ëª¨ë‹¬
    if (diff === 0) {
        const modalHtml = `
            <div class="duplicate-modal-overlay" id="duplicateModalOverlay">
                <div class="duplicate-modal">
                    <div class="duplicate-modal-header">
                        ê°™ì€ ì‹œíŠ¸ê°€ ì¡´ì¬í•©ë‹ˆë‹¤
                    </div>
                    <div class="duplicate-modal-body">
                        <div class="duplicate-info">
                            <div class="duplicate-row">
                                <span class="duplicate-label">ê¸°ì¡´</span>
                                <span class="duplicate-value">${existingName} (${existingRows}í–‰)</span>
                            </div>
                            <div class="duplicate-row">
                                <span class="duplicate-label">ìƒˆë¡œìš´</span>
                                <span class="duplicate-value">${newName} (${newRows}í–‰)</span>
                            </div>
                        </div>
                        <div class="duplicate-diff">
                            ë™ì¼í•œ í–‰ ìˆ˜ì…ë‹ˆë‹¤ (ìƒˆ íŒŒì¼ë¡œ ë®ì–´ì“°ê¸°)
                        </div>
                        <div class="duplicate-modal-footer">
                            <button class="duplicate-btn cancel" onclick="cancelDuplicateUpload()">ì·¨ì†Œ</button>
                            <button class="duplicate-btn merge" onclick="overwriteSheet()" style="background:var(--retro-teal);">ë®ì–´ì“°ê¸°</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        return;
    }
    
    // í–‰ ìˆ˜ê°€ ë‹¤ë¥¸ ê²½ìš° - ë§ì€ ìª½ ê¸°ì¤€ìœ¼ë¡œ ë³‘í•©
    const moreRows = existingRows > newRows ? existingRows : newRows;
    const lessRows = existingRows > newRows ? newRows : existingRows;
    const baseLabel = existingRows >= newRows ? 'ê¸°ì¡´ (ê¸°ì¤€)' : 'ìƒˆë¡œìš´ (ê¸°ì¤€)';
    const addLabel = existingRows >= newRows ? 'ìƒˆë¡œìš´' : 'ê¸°ì¡´';
    const baseName2 = existingRows >= newRows ? existingName : newName;
    const addName = existingRows >= newRows ? newName : existingName;
    
    const modalHtml = `
        <div class="duplicate-modal-overlay" id="duplicateModalOverlay">
            <div class="duplicate-modal">
                <div class="duplicate-modal-header">
                    ê°™ì€ ì‹œíŠ¸ê°€ ì¡´ì¬í•©ë‹ˆë‹¤
                </div>
                <div class="duplicate-modal-body">
                    <div class="duplicate-info">
                        <div class="duplicate-row">
                            <span class="duplicate-label" style="background:var(--retro-teal);color:white;">${baseLabel}</span>
                            <span class="duplicate-value">${baseName2} (${moreRows}í–‰)</span>
                        </div>
                        <div class="duplicate-row">
                            <span class="duplicate-label">${addLabel}</span>
                            <span class="duplicate-value">${addName} (${lessRows}í–‰)</span>
                        </div>
                    </div>
                    <div class="duplicate-diff" style="background:#d4edda;border-color:#28a745;">
                        ${moreRows}í–‰ ê¸°ì¤€ + ${lessRows}í–‰ ì¤‘ ìƒˆë¡œìš´ ë°ì´í„° ì¶”ê°€
                    </div>
                    <div style="font-size:11px;color:#666;margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px;">
                        â€» í–‰ ìˆ˜ê°€ ì ì–´ë„ ë‹¤ë¥¸ ë‚´ìš©ì´ ìˆìœ¼ë©´ ì¶”ê°€ë©ë‹ˆë‹¤
                    </div>
                    <input type="text" class="duplicate-name-input" id="duplicateMergedName" 
                           value="${defaultMergedName}" placeholder="ë³‘í•© í›„ ì‹œíŠ¸ëª…">
                    <div class="duplicate-modal-footer">
                        <button class="duplicate-btn cancel" onclick="cancelDuplicateUpload()">ì·¨ì†Œ</button>
                        <button class="duplicate-btn separate" onclick="saveSeparate()">ë³„ë„ ì €ì¥</button>
                        <button class="duplicate-btn merge" onclick="mergeSheetsWithMore()">ë³‘í•©</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤
    setTimeout(() => {
        document.getElementById('duplicateMergedName')?.focus();
    }, 100);
}

// ì—…ë¡œë“œ ì·¨ì†Œ
function cancelDuplicateUpload() {
    if (isMerging) return; // ì¤‘ë³µ í´ë¦­ ë°©ì§€
    isMerging = true;
    toast('ì—…ë¡œë“œ ì·¨ì†Œë¨');
    closeDuplicateModal();
}

// ë®ì–´ì“°ê¸° (ë™ì¼í•œ íŒŒì¼ì¼ ë•Œ)
function overwriteSheet() {
    if (!currentDuplicateData) return;
    if (isMerging) return; // ì¤‘ë³µ í´ë¦­ ë°©ì§€
    isMerging = true;
    
    const { existingName, newData } = currentDuplicateData;
    
    // newData ìœ íš¨ì„± ì²´í¬
    if (!newData || !newData.headers || !newData.data) {
        toast('ìƒˆ ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        closeDuplicateModal();
        return;
    }
    
    // ìƒˆ ë°ì´í„°ë¡œ ë®ì–´ì“°ê¸°
    WB[existingName] = {
        headers: newData.headers,
        data: newData.data
    };
    
    // ì—´ ìˆœì„œ/ìˆ¨ê¹€ ì´ˆê¸°í™” (í—¤ë”ê°€ ë°”ë€” ìˆ˜ ìˆìœ¼ë¯€ë¡œ)
    COL_ORDER[existingName] = newData.headers.map((_, i) => i);
    HIDDEN_COLS[existingName] = new Set();
    
    toast(`'${existingName}' ë®ì–´ì“°ê¸° ì™„ë£Œ`);
    
    closeDuplicateModal();
    renderMainScreen();
    renderSpreadsheet();
}

// ì¤‘ë³µ ëª¨ë‹¬ ë‹«ê¸°
function closeDuplicateModal() {
    const overlay = document.getElementById('duplicateModalOverlay');
    if (overlay) overlay.remove();
    currentDuplicateData = null;
    isMerging = false; // ë³‘í•© í”Œë˜ê·¸ ë¦¬ì…‹
    
    // íì— ë‚¨ì€ í•­ëª© ì²˜ë¦¬
    processNextDuplicate();
}

// ë³„ë„ ì €ì¥ (ìƒˆ ì´ë¦„ìœ¼ë¡œ ì¶”ê°€)
function saveSeparate() {
    if (!currentDuplicateData) return;
    if (isMerging) return; // ì¤‘ë³µ í´ë¦­ ë°©ì§€
    isMerging = true;
    
    const { existingName, newData } = currentDuplicateData;
    
    // newData ìœ íš¨ì„± ì²´í¬
    if (!newData || !newData.headers || !newData.data) {
        toast('ìƒˆ ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        closeDuplicateModal();
        return;
    }
    
    // ìƒˆ ì´ë¦„ ìƒì„±
    let newName = existingName;
    let suffix = 2;
    while (WB[newName]) {
        newName = `${existingName}_${suffix}`;
        suffix++;
    }
    
    // ìƒˆ ì‹œíŠ¸ë¡œ ì €ì¥
    WB[newName] = {
        headers: newData.headers,
        data: newData.data
    };
    COL_ORDER[newName] = newData.headers.map((_, i) => i);
    HIDDEN_COLS[newName] = new Set();
    
    toast(`'${newName}' ì‹œíŠ¸ë¡œ ë³„ë„ ì €ì¥ë¨`);
    
    closeDuplicateModal();
    renderMainScreen();
    renderSpreadsheet();
}

// ì‹œíŠ¸ ë³‘í•© (ë§ì€ í–‰ ê¸°ì¤€)
function mergeSheetsWithMore() {
    if (!currentDuplicateData) return;
    if (isMerging) return; // ì¤‘ë³µ í´ë¦­ ë°©ì§€
    isMerging = true;
    
    const { existingName, newData, existingRows, newRows } = currentDuplicateData;
    
    // newData ìœ íš¨ì„± ì²´í¬
    if (!newData || !newData.headers || !newData.data) {
        toast('ìƒˆ ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        closeDuplicateModal();
        return;
    }
    
    const mergedName = document.getElementById('duplicateMergedName')?.value?.trim() || `${existingName}_í†µí•©`;
    
    // ê¸°ì¡´ ì‹œíŠ¸ ë°ì´í„°
    const existingSheet = WB[existingName];
    if (!existingSheet) {
        toast('ê¸°ì¡´ ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        closeDuplicateModal();
        return;
    }
    const existingData = existingSheet.data;
    const existingHeaders = existingSheet.headers;
    
    // ë§ì€ ìª½ì„ ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
    let baseData, addData, baseHeaders;
    if (existingRows >= newRows) {
        // ê¸°ì¡´ì´ ë” ë§ê±°ë‚˜ ê°™ìœ¼ë©´ ê¸°ì¡´ ê¸°ì¤€
        baseData = [...existingData];
        addData = newData.data;
        baseHeaders = existingHeaders;
    } else {
        // ìƒˆ ë°ì´í„°ê°€ ë” ë§ìœ¼ë©´ ìƒˆ ë°ì´í„° ê¸°ì¤€
        baseData = [...newData.data];
        addData = existingData;
        baseHeaders = newData.headers || existingHeaders;
    }
    
    // ì¤‘ë³µ ì œê±°í•˜ê³  ë³‘í•©
    const existingSet = new Set();
    for (const row of baseData) {
        existingSet.add(JSON.stringify(row));
    }
    
    let addedCount = 0;
    
    for (const row of addData) {
        const rowStr = JSON.stringify(row);
        if (!existingSet.has(rowStr)) {
            // ì—´ ìˆ˜ ë§ì¶”ê¸°
            const newRow = [...row];
            while (newRow.length < baseHeaders.length) newRow.push('');
            baseData.push(newRow.slice(0, baseHeaders.length));
            existingSet.add(rowStr);
            addedCount++;
        }
    }
    
    // ê¸°ì¡´ ì‹œíŠ¸ ì‚­ì œ
    delete WB[existingName];
    delete COL_ORDER[existingName];
    delete HIDDEN_COLS[existingName];
    delete COL_WIDTHS[existingName];
    delete ROW_HEIGHTS[existingName];
    newSheets.delete(existingName); // NEW ë°°ì§€ë„ ì œê±°
    
    // ë³‘í•©ëœ ì‹œíŠ¸ ì €ì¥
    WB[mergedName] = {
        headers: baseHeaders,
        data: baseData
    };
    COL_ORDER[mergedName] = baseHeaders.map((_, i) => i);
    HIDDEN_COLS[mergedName] = new Set();
    
    // í´ë” ë§¤í•‘ ì´ì „
    if (sheetToFolder[existingName]) {
        sheetToFolder[mergedName] = sheetToFolder[existingName];
        delete sheetToFolder[existingName];
    }
    
    // ì¦ê²¨ì°¾ê¸° ì´ì „
    if (favoriteSheets.has(existingName)) {
        favoriteSheets.delete(existingName);
        favoriteSheets.add(mergedName);
    }
    
    // ë‹¤ì¤‘ ì„ íƒì—ì„œ ì œê±°
    if (multiSelectedSheets) {
        multiSelectedSheets.delete(existingName);
    }
    
    // í´ë” ë§¤í•‘ ë³€ê²½ ì €ì¥
    saveFolderData();
    
    // NEW ë°°ì§€ ì„¤ì • (ìƒˆë¡œ ì¶”ê°€ëœ ë°ì´í„°ê°€ ìˆì„ ë•Œë§Œ)
    if (addedCount > 0) {
        newSheets.add(mergedName);
    }
    
    const baseRows = existingRows >= newRows ? existingRows : newRows;
    toast(`'${mergedName}' ë³‘í•© ì™„ë£Œ (${baseRows}í–‰ ê¸°ì¤€ + ${addedCount}ê±´ ì¶”ê°€ = ${baseData.length}í–‰)`);
    
    closeDuplicateModal();
    renderMainScreen();
    renderSpreadsheet();
}

// ì‹œíŠ¸ ë³‘í•© (ê¸°ì¡´ ë°©ì‹ - í˜¸í™˜ìš©)
function mergeSheets() {
    mergeSheetsWithMore();
}

// ë‹¤ìŒ ì¤‘ë³µ í•­ëª© ì²˜ë¦¬
function processNextDuplicate() {
    // ê·¸ë£¹ íê°€ ìˆìœ¼ë©´ ê·¸ë£¹ ë¨¼ì € ì²˜ë¦¬
    if (duplicateGroupQueue.length > 0) {
        processNextDuplicateGroup();
        return;
    }
    
    if (duplicateQueue.length > 0) {
        const next = duplicateQueue.shift();
        showDuplicateModal(
            next.existingName,
            next.existingRows,
            next.newName,
            next.newRows,
            next.newData
        );
    }
}

// ì¤‘ë³µ ì‹œíŠ¸ íì— ì¶”ê°€
function queueDuplicate(existingName, existingRows, newName, newRows, newData) {
    duplicateQueue.push({
        existingName,
        existingRows,
        newName,
        newRows,
        newData
    });
    
    // í˜„ì¬ ëª¨ë‹¬ì´ ì—†ìœ¼ë©´ ë°”ë¡œ í‘œì‹œ
    if (!document.getElementById('duplicateModalOverlay') && !document.getElementById('groupMergeModalOverlay')) {
        processNextDuplicate();
    }
}

// ===== ìˆ˜ë™ ë³‘í•© ê¸°ëŠ¥ (ì‹œíŠ¸ ì„ íƒ í›„ ë³‘í•©) =====

// ë³‘í•© ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€ ì—…ë°ì´íŠ¸
function updateMergeActionButton() {
    const btn = document.getElementById('mergeActionBtn');
    if (!btn) return;
    
    if (multiSelectedSheets.size >= 2) {
        btn.style.display = 'inline-block';
        btn.textContent = `ì‹œíŠ¸ë³‘í•© (${multiSelectedSheets.size})`;
    } else {
        btn.style.display = 'none';
    }
}

// ìˆ˜ë™ ë³‘í•© ëª¨ë‹¬ ì—´ê¸°
function openManualMergeModal() {
    // ê¸°ì¡´ ëª¨ë‹¬ ì œê±°
    const existingModal = document.getElementById('manualMergeModalOverlay');
    if (existingModal) existingModal.remove();
    
    if (multiSelectedSheets.size < 2) {
        toast('2ê°œ ì´ìƒì˜ ì‹œíŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš” (Ctrl+í´ë¦­)');
        return;
    }
    
    const selectedSheets = Array.from(multiSelectedSheets);
    
    // ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ” ì‹œíŠ¸ë§Œ í•„í„°ë§
    const validSheets = selectedSheets.filter(name => WB[name] && WB[name].headers);
    if (validSheets.length < 2) {
        toast('ìœ íš¨í•œ ì‹œíŠ¸ê°€ 2ê°œ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤');
        return;
    }
    
    // ê° ì‹œíŠ¸ ì •ë³´
    const sheetInfo = validSheets.map(name => {
        const sheet = WB[name];
        return {
            name: name,
            rows: sheet && sheet.data ? sheet.data.length : 0,
            headers: sheet && sheet.headers ? sheet.headers : []
        };
    });
    
    // í—¤ë” ë¹„êµ (ì²« ë²ˆì§¸ ì‹œíŠ¸ ê¸°ì¤€)
    const baseHeaders = JSON.stringify(sheetInfo[0].headers);
    const headerMismatch = sheetInfo.some(s => JSON.stringify(s.headers) !== baseHeaders);
    
    const totalRows = sheetInfo.reduce((sum, s) => sum + s.rows, 0);
    
    const modalHtml = `
        <div class="duplicate-modal-overlay" id="manualMergeModalOverlay">
            <div class="duplicate-modal" style="width:500px;">
                <div class="duplicate-modal-header" style="background:var(--retro-teal);">
                    ì‹œíŠ¸ ë³‘í•© (${selectedSheets.length}ê°œ)
                </div>
                <div class="duplicate-modal-body">
                    ${headerMismatch ? `
                        <div style="background:#fff3cd;border:2px solid #ffc107;padding:10px;border-radius:6px;margin-bottom:15px;font-size:12px;">
                            âš ï¸ í—¤ë”ê°€ ì„œë¡œ ë‹¤ë¦…ë‹ˆë‹¤. ê¸°ì¤€ ì‹œíŠ¸ì˜ í—¤ë”ë¥¼ ë”°ë¦…ë‹ˆë‹¤.
                        </div>
                    ` : `
                        <div style="background:#d4edda;border:2px solid #28a745;padding:10px;border-radius:6px;margin-bottom:15px;font-size:12px;">
                            âœ“ ëª¨ë“  ì‹œíŠ¸ì˜ í—¤ë”ê°€ ë™ì¼í•©ë‹ˆë‹¤.
                        </div>
                    `}
                    
                    <div style="margin-bottom:15px;">
                        <label style="font-weight:600;font-size:13px;">ê¸°ì¤€ ì‹œíŠ¸ ì„ íƒ:</label>
                        <select id="mergeBaseSheet" style="width:100%;padding:8px;margin-top:5px;border:2px solid var(--retro-border);border-radius:6px;font-size:13px;">
                            ${sheetInfo.map((s, idx) => `
                                <option value="${idx}">${s.name} (${s.rows}í–‰, ${s.headers.length}ì—´)</option>
                            `).join('')}
                        </select>
                        <div style="font-size:11px;color:#666;margin-top:5px;">ê¸°ì¤€ ì‹œíŠ¸ì˜ í—¤ë”ì™€ ë°ì´í„°ê°€ ë¨¼ì € ì ìš©ë©ë‹ˆë‹¤.</div>
                    </div>
                    
                    <div class="duplicate-info" style="max-height:150px;overflow-y:auto;">
                        ${sheetInfo.map((s, idx) => `
                            <div class="duplicate-row" id="mergeSheetRow_${idx}">
                                <span class="duplicate-label" id="mergeLabel_${idx}" style="min-width:40px;">${idx === 0 ? 'ê¸°ì¤€' : 'ì¶”ê°€'}</span>
                                <span class="duplicate-value">${s.name} (${s.rows}í–‰)</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="duplicate-diff">
                        ë³‘í•© ì‹œ ì˜ˆìƒ: ìµœëŒ€ ${totalRows}í–‰ (ì¤‘ë³µ ì œê±° í›„ ê°ì†Œ ê°€ëŠ¥)
                    </div>
                    
                    <input type="text" class="duplicate-name-input" id="manualMergeName" 
                           value="${sheetInfo[0].name}_í†µí•©" placeholder="ë³‘í•© í›„ ì‹œíŠ¸ëª…">
                    
                    <div style="margin-top:12px;">
                        <label style="font-size:12px;cursor:pointer;">
                            <input type="checkbox" id="manualMergeDeleteOriginal" checked>
                            ë³‘í•© í›„ ì›ë³¸ ì‹œíŠ¸ ì‚­ì œ
                        </label>
                    </div>
                    <div style="margin-top:8px;">
                        <label style="font-size:12px;cursor:pointer;">
                            <input type="checkbox" id="manualMergeRemoveDuplicates" checked>
                            ì¤‘ë³µ í–‰ ìë™ ì œê±°
                        </label>
                    </div>
                    
                    <div class="duplicate-modal-footer" style="margin-top:15px;">
                        <button class="duplicate-btn cancel" onclick="closeManualMergeModal()">ì·¨ì†Œ</button>
                        <button class="duplicate-btn merge" onclick="executeManualMerge()">ë³‘í•©</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // ê¸°ì¤€ ì‹œíŠ¸ ë³€ê²½ ì‹œ ë¼ë²¨ ì—…ë°ì´íŠ¸
    const mergeBaseSelect = document.getElementById('mergeBaseSheet');
    if (mergeBaseSelect) {
        mergeBaseSelect.addEventListener('change', (e) => {
            const baseIdx = parseInt(e.target.value);
            
            // ëª¨ë“  ë¼ë²¨ ì—…ë°ì´íŠ¸
            sheetInfo.forEach((s, idx) => {
                const label = document.getElementById('mergeLabel_' + idx);
                if (label) {
                    label.textContent = idx === baseIdx ? 'ê¸°ì¤€' : 'ì¶”ê°€';
                    label.style.background = idx === baseIdx ? 'var(--retro-teal)' : '';
                    label.style.color = idx === baseIdx ? 'white' : '';
                }
            });
            
            // ê¸°ë³¸ ì‹œíŠ¸ëª… ì—…ë°ì´íŠ¸
            document.getElementById('manualMergeName').value = sheetInfo[baseIdx].name + '_í†µí•©';
        });
    }
    
    setTimeout(() => document.getElementById('manualMergeName')?.focus(), 100);
}

// ìˆ˜ë™ ë³‘í•© ëª¨ë‹¬ ë‹«ê¸°
function closeManualMergeModal() {
    const overlay = document.getElementById('manualMergeModalOverlay');
    if (overlay) overlay.remove();
    isManualMerging = false;
}

// ìˆ˜ë™ ë³‘í•© ì‹¤í–‰
let isManualMerging = false;

function executeManualMerge() {
    if (isManualMerging) return; // ì¤‘ë³µ í´ë¦­ ë°©ì§€
    isManualMerging = true;
    
    const selectedSheets = Array.from(multiSelectedSheets).filter(name => WB[name] && WB[name].headers);
    if (selectedSheets.length < 2) {
        toast('ìœ íš¨í•œ ì‹œíŠ¸ê°€ 2ê°œ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤');
        isManualMerging = false;
        closeManualMergeModal();
        return;
    }
    
    const baseIdx = parseInt(document.getElementById('mergeBaseSheet')?.value || '0', 10);
    // baseIdxê°€ NaNì´ê±°ë‚˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ 0ìœ¼ë¡œ
    const safeBaseIdx = (!isNaN(baseIdx) && baseIdx >= 0 && baseIdx < selectedSheets.length) ? baseIdx : 0;
    const mergedName = document.getElementById('manualMergeName')?.value?.trim() || `${selectedSheets[safeBaseIdx]}_í†µí•©`;
    const deleteOriginal = document.getElementById('manualMergeDeleteOriginal')?.checked;
    const removeDuplicates = document.getElementById('manualMergeRemoveDuplicates')?.checked !== false;
    
    // ê¸°ì¤€ ì‹œíŠ¸ë¥¼ ì²« ë²ˆì§¸ë¡œ ì¬ì •ë ¬
    const reorderedSheets = [selectedSheets[safeBaseIdx], ...selectedSheets.filter((_, i) => i !== safeBaseIdx)];
    
    // ê¸°ì¤€ ì‹œíŠ¸
    const baseSheet = WB[reorderedSheets[0]];
    if (!baseSheet) {
        toast('ê¸°ì¤€ ì‹œíŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        isManualMerging = false;
        closeManualMergeModal();
        return;
    }
    
    const baseHeaders = baseSheet.headers;
    const mergedData = [...baseSheet.data];
    
    // ì¤‘ë³µ ì²´í¬ìš© Set
    const existingSet = new Set();
    if (removeDuplicates) {
        for (const row of mergedData) {
            existingSet.add(JSON.stringify(row));
        }
    }
    
    let addedCount = 0;
    let duplicateCount = 0;
    
    // ë‚˜ë¨¸ì§€ ì‹œíŠ¸ ë°ì´í„° ì¶”ê°€
    for (let i = 1; i < reorderedSheets.length; i++) {
        const sheet = WB[reorderedSheets[i]];
        if (!sheet || !sheet.data) continue;
        
        for (const row of sheet.data) {
            const rowStr = JSON.stringify(row);
            
            if (removeDuplicates && existingSet.has(rowStr)) {
                duplicateCount++;
                continue;
            }
            
            // ì—´ ìˆ˜ ë§ì¶”ê¸°
            const newRow = [...row];
            while (newRow.length < baseHeaders.length) newRow.push('');
            mergedData.push(newRow.slice(0, baseHeaders.length));
            
            if (removeDuplicates) {
                existingSet.add(rowStr);
            }
            addedCount++;
        }
    }
    
    // ì›ë³¸ ì‚­ì œ (ì˜µì…˜)
    if (deleteOriginal) {
        for (const name of selectedSheets) {
            delete WB[name];
            delete COL_ORDER[name];
            delete HIDDEN_COLS[name];
            delete COL_WIDTHS[name];
            delete ROW_HEIGHTS[name];
            delete sheetToFolder[name];
            if (favoriteSheets) favoriteSheets.delete(name);
            if (newSheets) newSheets.delete(name);
            if (multiSelectedSheets) multiSelectedSheets.delete(name);
        }
        saveFolderData(); // í´ë” ë§¤í•‘ ë³€ê²½ ì €ì¥
    }
    
    // ë³‘í•©ëœ ì‹œíŠ¸ ì €ì¥
    WB[mergedName] = {
        headers: baseHeaders,
        data: mergedData
    };
    COL_ORDER[mergedName] = baseHeaders.map((_, i) => i);
    HIDDEN_COLS[mergedName] = new Set();
    
    // NEW ë°°ì§€ ì„¤ì • (ìƒˆë¡œ ì¶”ê°€ëœ ë°ì´í„°ê°€ ìˆì„ ë•Œë§Œ)
    if (addedCount > 0) {
        newSheets.add(mergedName);
    }
    
    // ë‹¤ì¤‘ ì„ íƒ ì´ˆê¸°í™”
    multiSelectedSheets.clear();
    updateMergeActionButton();
    
    closeManualMergeModal();
    
    let msg = `'${mergedName}'ì— ${addedCount}ê±´ ë³‘í•© ì™„ë£Œ (ì´ ${mergedData.length}í–‰)`;
    if (removeDuplicates && duplicateCount > 0) {
        msg += ` / ì¤‘ë³µ ${duplicateCount}ê±´ ì œì™¸`;
    }
    toast(msg);
    
    renderMainScreen();
    renderSpreadsheet();
}

// ===== ì•„ì´ì½˜ ììœ  ë°°ì¹˜ ì‹œìŠ¤í…œ =====

// ìœ„ì¹˜ ë°ì´í„° ì €ì¥
function saveIconPositions() {
    try {
        localStorage.setItem('excelmaster_sheetIconPositions', JSON.stringify(sheetIconPositions));
        localStorage.setItem('excelmaster_folderIconPositions', JSON.stringify(folderIconPositions));
        localStorage.setItem('excelmaster_fileIconPositions', JSON.stringify(fileIconPositions));
        localStorage.setItem('excelmaster_fileFolderIconPositions', JSON.stringify(fileFolderIconPositions));
    } catch (e) {
        console.error('ì•„ì´ì½˜ ìœ„ì¹˜ ì €ì¥ ì‹¤íŒ¨:', e);
    }
}

// ìœ„ì¹˜ ë°ì´í„° ë¡œë“œ
function loadIconPositions() {
    try {
        const sheet = localStorage.getItem('excelmaster_sheetIconPositions');
        const folder = localStorage.getItem('excelmaster_folderIconPositions');
        const file = localStorage.getItem('excelmaster_fileIconPositions');
        const fileFolder = localStorage.getItem('excelmaster_fileFolderIconPositions');
        
        if (sheet) sheetIconPositions = JSON.parse(sheet);
        if (folder) folderIconPositions = JSON.parse(folder);
        if (file) fileIconPositions = JSON.parse(file);
        if (fileFolder) fileFolderIconPositions = JSON.parse(fileFolder);
    } catch (e) {
        console.error('ì•„ì´ì½˜ ìœ„ì¹˜ ë¡œë“œ ì‹¤íŒ¨:', e);
    }
}

// ì‹œíŠ¸/í´ë”/íŒŒì¼ ìœ„ì¹˜ ë“œë˜ê·¸ ì‹œì‘ (ì•„ì´ì½˜ ë·° ì „ìš©)
let dragAnimationFrame = null;
let dragStarted = false; // ì‹¤ì œ ë“œë˜ê·¸ê°€ ì‹œì‘ë˜ì—ˆëŠ”ì§€
let currentHighlightedFolder = null; // í˜„ì¬ í•˜ì´ë¼ì´íŠ¸ëœ í´ë” ìºì‹œ
let lastHoverCheckTime = 0; // ë§ˆì§€ë§‰ í˜¸ë²„ ì²´í¬ ì‹œê°„
const HOVER_CHECK_INTERVAL = 50; // í˜¸ë²„ ì²´í¬ ê°„ê²© (ms)

function startPositionDrag(e, type, id) {
    // ì‹œíŠ¸ ëª©ë¡: sheetViewMode === VIEW_MODE.ICON
    // íŒŒì¼ ë³´ê´€í•¨: fileViewMode === VIEW_MODE.ICON
    const isSheetIcon = (type === 'sheet' || type === 'folder') && sheetViewMode === VIEW_MODE.ICON;
    const isFileIcon = (type === 'file' || type === 'fileFolder') && fileViewMode === VIEW_MODE.ICON;
    
    if (!freePositionMode) return;
    if (!isSheetIcon && !isFileIcon) return;
    if (e.button !== 0) return; // ì™¼ìª½ ë²„íŠ¼ë§Œ
    
    const element = e.currentTarget;
    const rect = element.getBoundingClientRect();
    const container = element.parentElement;
    const containerRect = container.getBoundingClientRect();
    
    dragStarted = false; // ì•„ì§ ë“œë˜ê·¸ ì‹œì‘ ì•ˆë¨
    
    positionDragState = {
        element: element,
        type: type,
        id: id,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        containerLeft: containerRect.left,
        containerTop: containerRect.top,
        startX: e.clientX,
        startY: e.clientY,
        lastX: e.clientX,
        lastY: e.clientY
    };
    
    // preventDefault í•˜ì§€ ì•ŠìŒ - í´ë¦­ ì´ë²¤íŠ¸ í—ˆìš©
}

// ìœ„ì¹˜ ë“œë˜ê·¸ ì´ë™ (requestAnimationFrame ì‚¬ìš©) - ì„±ëŠ¥ ìµœì í™” ë²„ì „
function handlePositionDragMove(e) {
    if (!positionDragState) return;
    
    // ë§ˆì§€ë§‰ ì¢Œí‘œ ì €ì¥
    positionDragState.lastX = e.clientX;
    positionDragState.lastY = e.clientY;
    
    // ìµœì†Œ ì´ë™ ê±°ë¦¬ ì²´í¬ (5px ì´ìƒ ì´ë™í•´ì•¼ ë“œë˜ê·¸ ì‹œì‘)
    if (!dragStarted) {
        const dx = e.clientX - positionDragState.startX;
        const dy = e.clientY - positionDragState.startY;
        // Math.sqrt ëŒ€ì‹  ì œê³± ë¹„êµë¡œ ìµœì í™”
        if (dx * dx + dy * dy < 25) return; // 5*5 = 25
        
        // ë“œë˜ê·¸ ì‹œì‘
        dragStarted = true;
        positionDragState.element.classList.add('dragging-position');
    }
    
    // ì´ë¯¸ ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ì´ ì˜ˆì•½ë˜ì–´ ìˆìœ¼ë©´ ìŠ¤í‚µ
    if (dragAnimationFrame) return;
    
    dragAnimationFrame = requestAnimationFrame(() => {
        if (!positionDragState) {
            dragAnimationFrame = null;
            return;
        }
        
        const { element, type, containerLeft, containerTop, offsetX, offsetY, lastX, lastY } = positionDragState;
        
        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        let newX = lastX - containerLeft - offsetX;
        let newY = lastY - containerTop - offsetY;
        
        // ìŒìˆ˜ ë°©ì§€
        newX = Math.max(0, newX);
        newY = Math.max(0, newY);
        
        element.style.left = newX + 'px';
        element.style.top = newY + 'px';
        
        // í´ë” í•˜ì´ë¼ì´íŠ¸ ì²˜ë¦¬ (ì‹œíŠ¸/íŒŒì¼ ë“œë˜ê·¸ ì‹œì—ë§Œ) - ì“°ë¡œí‹€ë§ ì ìš©
        if (type === 'sheet' || type === 'file') {
            const now = performance.now();
            if (now - lastHoverCheckTime >= HOVER_CHECK_INTERVAL) {
                lastHoverCheckTime = now;
                
                // pointerEvents ì¡°ì‘ ìµœì†Œí™”
                const originalPointerEvents = element.style.pointerEvents;
                element.style.pointerEvents = 'none';
                const hoverTarget = document.elementFromPoint(lastX, lastY);
                element.style.pointerEvents = originalPointerEvents;
                
                const folderCard = hoverTarget?.closest('.folder-card');
                
                // ì´ì „ í•˜ì´ë¼ì´íŠ¸ì™€ ë‹¤ë¥¼ ë•Œë§Œ DOM ì¡°ì‘
                if (folderCard !== currentHighlightedFolder) {
                    // ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±° (ìºì‹œëœ ìš”ì†Œë§Œ)
                    if (currentHighlightedFolder) {
                        currentHighlightedFolder.classList.remove('drag-over');
                    }
                    
                    // ìƒˆ í•˜ì´ë¼ì´íŠ¸ ì¶”ê°€
                    if (folderCard) {
                        folderCard.classList.add('drag-over');
                    }
                    
                    currentHighlightedFolder = folderCard;
                }
            }
        }
        
        dragAnimationFrame = null;
    });
}

// ìœ„ì¹˜ ë“œë˜ê·¸ ì¢…ë£Œ
function endPositionDrag(e) {
    if (!positionDragState) return;
    
    // ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ ì·¨ì†Œ
    if (dragAnimationFrame) {
        cancelAnimationFrame(dragAnimationFrame);
        dragAnimationFrame = null;
    }
    
    // í´ë” í•˜ì´ë¼ì´íŠ¸ ì œê±° (ìºì‹œ ì‚¬ìš©)
    if (currentHighlightedFolder) {
        currentHighlightedFolder.classList.remove('drag-over');
        currentHighlightedFolder = null;
    }
    // í˜¹ì‹œ ë‚¨ì•„ìˆëŠ” í•˜ì´ë¼ì´íŠ¸ ì •ë¦¬ (ë“œë˜ê·¸ ì¢…ë£Œ ì‹œì—ë§Œ í•œ ë²ˆ)
    document.querySelectorAll('.folder-card.drag-over').forEach(f => f.classList.remove('drag-over'));
    
    const { element, type, id, containerLeft, containerTop, offsetX, offsetY, lastX, lastY } = positionDragState;
    
    // ë“œë˜ê·¸ê°€ ì‹¤ì œë¡œ ì‹œì‘ë˜ì§€ ì•Šì•˜ìœ¼ë©´ (í´ë¦­ë§Œ í•œ ê²½ìš°)
    if (!dragStarted) {
        positionDragState = null;
        dragStarted = false;
        // í´ë¦­ ì´ë²¤íŠ¸ëŠ” ìì—°ìŠ¤ëŸ½ê²Œ ë°œìƒí•˜ë¯€ë¡œ ì•„ë¬´ê²ƒë„ ì•ˆí•¨
        return;
    }
    
    // IDì—ì„œ escape ë³µì› (\'ë¥¼ 'ë¡œ)
    const originalId = id.replace(/\\'/g, "'");
    
    // ë“œë¡­ ìœ„ì¹˜ì— í´ë”ê°€ ìˆëŠ”ì§€ í™•ì¸
    element.style.pointerEvents = 'none'; // ìì‹ ì€ ì œì™¸
    const dropTarget = document.elementFromPoint(lastX, lastY);
    element.style.pointerEvents = '';
    
    const folderCard = dropTarget?.closest('.folder-card');
    
    // ì‹œíŠ¸/íŒŒì¼ì„ í´ë” ìœ„ì— ë“œë¡­í•œ ê²½ìš° â†’ í´ë”ë¡œ ì´ë™
    if (folderCard && (type === 'sheet' || type === 'file')) {
        const folderId = folderCard.dataset.folder;
        
        if (type === 'sheet' && folderId) {
            // ì‹œíŠ¸ë¥¼ í´ë”ë¡œ ì´ë™
            sheetToFolder[originalId] = folderId;
            const folderName = sheetFolders[folderId]?.name || 'í´ë”';
            toast(`'${originalId}' ì‹œíŠ¸ë¥¼ '${folderName}'ë¡œ ì´ë™`);
            element.classList.remove('dragging-position');
            positionDragState = null;
            saveToLocalStorage();
            renderMainScreen();
            return;
        } else if (type === 'file' && folderId) {
            // íŒŒì¼ì„ í´ë”ë¡œ ì´ë™
            fileToFolder[originalId] = folderId;
            const folderName = fileFolders[folderId]?.name || 'í´ë”';
            toast(`íŒŒì¼ì„ '${folderName}'ë¡œ ì´ë™`);
            element.classList.remove('dragging-position');
            positionDragState = null;
            // íŒŒì¼ í´ë” ë§¤í•‘ ì €ì¥
            try {
                localStorage.setItem('excelmaster_fileToFolder', JSON.stringify(fileToFolder));
            } catch (err) {
                console.error('fileToFolder ì €ì¥ ì‹¤íŒ¨:', err);
            }
            renderFileStoragePanel();
            return;
        }
    }
    
    // í´ë”ê°€ ì•„ë‹Œ ê³³ì— ë“œë¡­ â†’ ìœ„ì¹˜ ë³€ê²½
    let newX = lastX - containerLeft - offsetX;
    let newY = lastY - containerTop - offsetY;
    
    // ìŒìˆ˜ ë°©ì§€
    newX = Math.max(0, newX);
    newY = Math.max(0, newY);
    
    // ê²©ìì— ìŠ¤ëƒ… (ìœˆë„ìš° ìŠ¤íƒ€ì¼ ì •ë ¬)
    const gridWidth = 90;
    const gridHeight = 95;
    newX = Math.round(newX / gridWidth) * gridWidth + 10;
    newY = Math.round(newY / gridHeight) * gridHeight + 10;
    
    // ìœ„ì¹˜ ì €ì¥
    if (type === 'sheet') {
        sheetIconPositions[originalId] = { x: newX, y: newY };
    } else if (type === 'folder') {
        folderIconPositions[originalId] = { x: newX, y: newY };
    } else if (type === 'file') {
        fileIconPositions[originalId] = { x: newX, y: newY };
    } else if (type === 'fileFolder') {
        fileFolderIconPositions[originalId] = { x: newX, y: newY };
    }
    
    element.classList.remove('dragging-position');
    saveIconPositions();
    
    positionDragState = null;
    dragStarted = false;
}

// ì•„ì´ì½˜ ìœ„ì¹˜ ì´ˆê¸°í™”
function resetIconPositions(type) {
    if (type === 'sheet') {
        sheetIconPositions = {};
        folderIconPositions = {};
        toast('ì‹œíŠ¸ ì•„ì´ì½˜ ìœ„ì¹˜ ì´ˆê¸°í™”');
    } else if (type === 'file') {
        fileIconPositions = {};
        fileFolderIconPositions = {};
        toast('íŒŒì¼ ì•„ì´ì½˜ ìœ„ì¹˜ ì´ˆê¸°í™”');
    }
    saveIconPositions();
    
    if (type === 'sheet') {
        renderMainScreen();
    } else {
        renderFileStoragePanel();
    }
}

// ìœ„ì¹˜ ë“œë˜ê·¸ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
document.addEventListener('mousemove', handlePositionDragMove);
document.addEventListener('mouseup', endPositionDrag);

// ì´ˆê¸°í™” ì‹œ ìœ„ì¹˜ ë°ì´í„° ë¡œë“œ
document.addEventListener('DOMContentLoaded', loadIconPositions);
</script>
</body>
</html>
